/**
 * Client
 **/

import * as runtime from './runtime/client.js'
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>

/**
 * Model FactOrder
 *
 */
export type FactOrder = $Result.DefaultSelection<Prisma.$FactOrderPayload>
/**
 * Model FactOrderItem
 *
 */
export type FactOrderItem =
  $Result.DefaultSelection<Prisma.$FactOrderItemPayload>
/**
 * Model FactPayment
 *
 */
export type FactPayment = $Result.DefaultSelection<Prisma.$FactPaymentPayload>
/**
 * Model FactShipment
 *
 */
export type FactShipment = $Result.DefaultSelection<Prisma.$FactShipmentPayload>
/**
 * Model FactSession
 *
 */
export type FactSession = $Result.DefaultSelection<Prisma.$FactSessionPayload>
/**
 * Model FactPageview
 *
 */
export type FactPageview = $Result.DefaultSelection<Prisma.$FactPageviewPayload>
/**
 * Model FactSearch
 *
 */
export type FactSearch = $Result.DefaultSelection<Prisma.$FactSearchPayload>
/**
 * Model FactCartActivity
 *
 */
export type FactCartActivity =
  $Result.DefaultSelection<Prisma.$FactCartActivityPayload>
/**
 * Model FactReview
 *
 */
export type FactReview = $Result.DefaultSelection<Prisma.$FactReviewPayload>
/**
 * Model DimProduct
 *
 */
export type DimProduct = $Result.DefaultSelection<Prisma.$DimProductPayload>
/**
 * Model DimUser
 *
 */
export type DimUser = $Result.DefaultSelection<Prisma.$DimUserPayload>
/**
 * Model DimDate
 *
 */
export type DimDate = $Result.DefaultSelection<Prisma.$DimDatePayload>
/**
 * Model DimMarketing
 *
 */
export type DimMarketing = $Result.DefaultSelection<Prisma.$DimMarketingPayload>
/**
 * Model DimLocation
 *
 */
export type DimLocation = $Result.DefaultSelection<Prisma.$DimLocationPayload>
/**
 * Model IngestOffset
 *
 */
export type IngestOffset = $Result.DefaultSelection<Prisma.$IngestOffsetPayload>
/**
 * Model StagingRawEvent
 *
 */
export type StagingRawEvent =
  $Result.DefaultSelection<Prisma.$StagingRawEventPayload>
/**
 * Model AggDailyStats
 *
 */
export type AggDailyStats =
  $Result.DefaultSelection<Prisma.$AggDailyStatsPayload>
/**
 * Model AggProductPerformance
 *
 */
export type AggProductPerformance =
  $Result.DefaultSelection<Prisma.$AggProductPerformancePayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more FactOrders
 * const factOrders = await prisma.factOrder.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions
    ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions['log']>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more FactOrders
   * const factOrders = await prisma.factOrder.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(
    optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>
  )
  $on<V extends U>(
    eventType: V,
    callback: (
      event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent
    ) => void
  ): PrismaClient

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<number>

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<number>

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<T>

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<T>

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
    options?: { isolationLevel?: Prisma.TransactionIsolationLevel }
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(
    fn: (
      prisma: Omit<PrismaClient, runtime.ITXClientDenyList>
    ) => $Utils.JsPromise<R>,
    options?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  ): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<
    'extends',
    Prisma.TypeMapCb<ClientOptions>,
    ExtArgs,
    $Utils.Call<
      Prisma.TypeMapCb<ClientOptions>,
      {
        extArgs: ExtArgs
      }
    >
  >

  /**
   * `prisma.factOrder`: Exposes CRUD operations for the **FactOrder** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more FactOrders
   * const factOrders = await prisma.factOrder.findMany()
   * ```
   */
  get factOrder(): Prisma.FactOrderDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.factOrderItem`: Exposes CRUD operations for the **FactOrderItem** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more FactOrderItems
   * const factOrderItems = await prisma.factOrderItem.findMany()
   * ```
   */
  get factOrderItem(): Prisma.FactOrderItemDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.factPayment`: Exposes CRUD operations for the **FactPayment** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more FactPayments
   * const factPayments = await prisma.factPayment.findMany()
   * ```
   */
  get factPayment(): Prisma.FactPaymentDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.factShipment`: Exposes CRUD operations for the **FactShipment** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more FactShipments
   * const factShipments = await prisma.factShipment.findMany()
   * ```
   */
  get factShipment(): Prisma.FactShipmentDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.factSession`: Exposes CRUD operations for the **FactSession** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more FactSessions
   * const factSessions = await prisma.factSession.findMany()
   * ```
   */
  get factSession(): Prisma.FactSessionDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.factPageview`: Exposes CRUD operations for the **FactPageview** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more FactPageviews
   * const factPageviews = await prisma.factPageview.findMany()
   * ```
   */
  get factPageview(): Prisma.FactPageviewDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.factSearch`: Exposes CRUD operations for the **FactSearch** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more FactSearches
   * const factSearches = await prisma.factSearch.findMany()
   * ```
   */
  get factSearch(): Prisma.FactSearchDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.factCartActivity`: Exposes CRUD operations for the **FactCartActivity** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more FactCartActivities
   * const factCartActivities = await prisma.factCartActivity.findMany()
   * ```
   */
  get factCartActivity(): Prisma.FactCartActivityDelegate<
    ExtArgs,
    ClientOptions
  >

  /**
   * `prisma.factReview`: Exposes CRUD operations for the **FactReview** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more FactReviews
   * const factReviews = await prisma.factReview.findMany()
   * ```
   */
  get factReview(): Prisma.FactReviewDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.dimProduct`: Exposes CRUD operations for the **DimProduct** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more DimProducts
   * const dimProducts = await prisma.dimProduct.findMany()
   * ```
   */
  get dimProduct(): Prisma.DimProductDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.dimUser`: Exposes CRUD operations for the **DimUser** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more DimUsers
   * const dimUsers = await prisma.dimUser.findMany()
   * ```
   */
  get dimUser(): Prisma.DimUserDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.dimDate`: Exposes CRUD operations for the **DimDate** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more DimDates
   * const dimDates = await prisma.dimDate.findMany()
   * ```
   */
  get dimDate(): Prisma.DimDateDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.dimMarketing`: Exposes CRUD operations for the **DimMarketing** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more DimMarketings
   * const dimMarketings = await prisma.dimMarketing.findMany()
   * ```
   */
  get dimMarketing(): Prisma.DimMarketingDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.dimLocation`: Exposes CRUD operations for the **DimLocation** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more DimLocations
   * const dimLocations = await prisma.dimLocation.findMany()
   * ```
   */
  get dimLocation(): Prisma.DimLocationDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.ingestOffset`: Exposes CRUD operations for the **IngestOffset** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more IngestOffsets
   * const ingestOffsets = await prisma.ingestOffset.findMany()
   * ```
   */
  get ingestOffset(): Prisma.IngestOffsetDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.stagingRawEvent`: Exposes CRUD operations for the **StagingRawEvent** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more StagingRawEvents
   * const stagingRawEvents = await prisma.stagingRawEvent.findMany()
   * ```
   */
  get stagingRawEvent(): Prisma.StagingRawEventDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.aggDailyStats`: Exposes CRUD operations for the **AggDailyStats** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more AggDailyStats
   * const aggDailyStats = await prisma.aggDailyStats.findMany()
   * ```
   */
  get aggDailyStats(): Prisma.AggDailyStatsDelegate<ExtArgs, ClientOptions>

  /**
   * `prisma.aggProductPerformance`: Exposes CRUD operations for the **AggProductPerformance** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more AggProductPerformances
   * const aggProductPerformances = await prisma.aggProductPerformance.findMany()
   * ```
   */
  get aggProductPerformance(): Prisma.AggProductPerformanceDelegate<
    ExtArgs,
    ClientOptions
  >
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.3.0
   * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */

  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> =
    T extends PromiseLike<infer U> ? U : T

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<
    T extends (...args: any) => $Utils.JsPromise<any>,
  > = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P]
  }

  export type Enumerable<T> = T | Array<T>

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  }

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } & (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } & K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never }

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object
    ? U extends object
      ? (Without<T, U> & U) | (Without<U, T> & T)
      : U
    : T

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> =
    T extends Array<any>
      ? False
      : T extends Date
        ? False
        : T extends Uint8Array
          ? False
          : T extends BigInt
            ? False
            : T extends object
              ? True
              : False

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K]
  } & {}

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>
      }
    >
  >

  type Key = string | number | symbol
  type AtBasic<O extends object, K extends Key> = K extends keyof O
    ? O[K]
    : never
  type AtStrict<O extends object, K extends Key> = O[K & keyof O]
  type AtLoose<O extends object, K extends Key> = O extends unknown
    ? AtStrict<O, K>
    : never
  export type At<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = {
    1: AtStrict<O, K>
    0: AtLoose<O, K>
  }[strict]

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K]
      } & {}

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K]
  } & {}

  type _Record<K extends keyof any, T> = {
    [P in K]: T
  }

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ?
          | (K extends keyof O ? { [P in K]: O[P] } & O : O)
          | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
      : never
  >

  type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B

  export const type: unique symbol

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never
      }
    : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>,
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<
            UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never
          >
        : never
      : {} extends FieldPaths<T[K]>
        ? never
        : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<
    T,
    K extends Enumerable<keyof T> | keyof T,
  > = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}`
    ? never
    : T

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never
    ? never
    : FieldRef<Model, FieldType>

  export const ModelName: {
    FactOrder: 'FactOrder'
    FactOrderItem: 'FactOrderItem'
    FactPayment: 'FactPayment'
    FactShipment: 'FactShipment'
    FactSession: 'FactSession'
    FactPageview: 'FactPageview'
    FactSearch: 'FactSearch'
    FactCartActivity: 'FactCartActivity'
    FactReview: 'FactReview'
    DimProduct: 'DimProduct'
    DimUser: 'DimUser'
    DimDate: 'DimDate'
    DimMarketing: 'DimMarketing'
    DimLocation: 'DimLocation'
    IngestOffset: 'IngestOffset'
    StagingRawEvent: 'StagingRawEvent'
    AggDailyStats: 'AggDailyStats'
    AggProductPerformance: 'AggProductPerformance'
  }

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]

  interface TypeMapCb<ClientOptions = {}>
    extends $Utils.Fn<
      { extArgs: $Extensions.InternalArgs },
      $Utils.Record<string, any>
    > {
    returns: Prisma.TypeMap<
      this['params']['extArgs'],
      ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}
    >
  }

  export type TypeMap<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps:
        | 'factOrder'
        | 'factOrderItem'
        | 'factPayment'
        | 'factShipment'
        | 'factSession'
        | 'factPageview'
        | 'factSearch'
        | 'factCartActivity'
        | 'factReview'
        | 'dimProduct'
        | 'dimUser'
        | 'dimDate'
        | 'dimMarketing'
        | 'dimLocation'
        | 'ingestOffset'
        | 'stagingRawEvent'
        | 'aggDailyStats'
        | 'aggProductPerformance'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      FactOrder: {
        payload: Prisma.$FactOrderPayload<ExtArgs>
        fields: Prisma.FactOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FactOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FactOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactOrderPayload>
          }
          findFirst: {
            args: Prisma.FactOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FactOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactOrderPayload>
          }
          findMany: {
            args: Prisma.FactOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactOrderPayload>[]
          }
          create: {
            args: Prisma.FactOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactOrderPayload>
          }
          createMany: {
            args: Prisma.FactOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FactOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactOrderPayload>[]
          }
          delete: {
            args: Prisma.FactOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactOrderPayload>
          }
          update: {
            args: Prisma.FactOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactOrderPayload>
          }
          deleteMany: {
            args: Prisma.FactOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FactOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FactOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactOrderPayload>[]
          }
          upsert: {
            args: Prisma.FactOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactOrderPayload>
          }
          aggregate: {
            args: Prisma.FactOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFactOrder>
          }
          groupBy: {
            args: Prisma.FactOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<FactOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.FactOrderCountArgs<ExtArgs>
            result: $Utils.Optional<FactOrderCountAggregateOutputType> | number
          }
        }
      }
      FactOrderItem: {
        payload: Prisma.$FactOrderItemPayload<ExtArgs>
        fields: Prisma.FactOrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FactOrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactOrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FactOrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactOrderItemPayload>
          }
          findFirst: {
            args: Prisma.FactOrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactOrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FactOrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactOrderItemPayload>
          }
          findMany: {
            args: Prisma.FactOrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactOrderItemPayload>[]
          }
          create: {
            args: Prisma.FactOrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactOrderItemPayload>
          }
          createMany: {
            args: Prisma.FactOrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FactOrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactOrderItemPayload>[]
          }
          delete: {
            args: Prisma.FactOrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactOrderItemPayload>
          }
          update: {
            args: Prisma.FactOrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactOrderItemPayload>
          }
          deleteMany: {
            args: Prisma.FactOrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FactOrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FactOrderItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactOrderItemPayload>[]
          }
          upsert: {
            args: Prisma.FactOrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactOrderItemPayload>
          }
          aggregate: {
            args: Prisma.FactOrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFactOrderItem>
          }
          groupBy: {
            args: Prisma.FactOrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<FactOrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.FactOrderItemCountArgs<ExtArgs>
            result:
              | $Utils.Optional<FactOrderItemCountAggregateOutputType>
              | number
          }
        }
      }
      FactPayment: {
        payload: Prisma.$FactPaymentPayload<ExtArgs>
        fields: Prisma.FactPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FactPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FactPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactPaymentPayload>
          }
          findFirst: {
            args: Prisma.FactPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FactPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactPaymentPayload>
          }
          findMany: {
            args: Prisma.FactPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactPaymentPayload>[]
          }
          create: {
            args: Prisma.FactPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactPaymentPayload>
          }
          createMany: {
            args: Prisma.FactPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FactPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactPaymentPayload>[]
          }
          delete: {
            args: Prisma.FactPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactPaymentPayload>
          }
          update: {
            args: Prisma.FactPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactPaymentPayload>
          }
          deleteMany: {
            args: Prisma.FactPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FactPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FactPaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactPaymentPayload>[]
          }
          upsert: {
            args: Prisma.FactPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactPaymentPayload>
          }
          aggregate: {
            args: Prisma.FactPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFactPayment>
          }
          groupBy: {
            args: Prisma.FactPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<FactPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.FactPaymentCountArgs<ExtArgs>
            result:
              | $Utils.Optional<FactPaymentCountAggregateOutputType>
              | number
          }
        }
      }
      FactShipment: {
        payload: Prisma.$FactShipmentPayload<ExtArgs>
        fields: Prisma.FactShipmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FactShipmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactShipmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FactShipmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactShipmentPayload>
          }
          findFirst: {
            args: Prisma.FactShipmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactShipmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FactShipmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactShipmentPayload>
          }
          findMany: {
            args: Prisma.FactShipmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactShipmentPayload>[]
          }
          create: {
            args: Prisma.FactShipmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactShipmentPayload>
          }
          createMany: {
            args: Prisma.FactShipmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FactShipmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactShipmentPayload>[]
          }
          delete: {
            args: Prisma.FactShipmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactShipmentPayload>
          }
          update: {
            args: Prisma.FactShipmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactShipmentPayload>
          }
          deleteMany: {
            args: Prisma.FactShipmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FactShipmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FactShipmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactShipmentPayload>[]
          }
          upsert: {
            args: Prisma.FactShipmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactShipmentPayload>
          }
          aggregate: {
            args: Prisma.FactShipmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFactShipment>
          }
          groupBy: {
            args: Prisma.FactShipmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<FactShipmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.FactShipmentCountArgs<ExtArgs>
            result:
              | $Utils.Optional<FactShipmentCountAggregateOutputType>
              | number
          }
        }
      }
      FactSession: {
        payload: Prisma.$FactSessionPayload<ExtArgs>
        fields: Prisma.FactSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FactSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FactSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactSessionPayload>
          }
          findFirst: {
            args: Prisma.FactSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FactSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactSessionPayload>
          }
          findMany: {
            args: Prisma.FactSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactSessionPayload>[]
          }
          create: {
            args: Prisma.FactSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactSessionPayload>
          }
          createMany: {
            args: Prisma.FactSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FactSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactSessionPayload>[]
          }
          delete: {
            args: Prisma.FactSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactSessionPayload>
          }
          update: {
            args: Prisma.FactSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactSessionPayload>
          }
          deleteMany: {
            args: Prisma.FactSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FactSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FactSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactSessionPayload>[]
          }
          upsert: {
            args: Prisma.FactSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactSessionPayload>
          }
          aggregate: {
            args: Prisma.FactSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFactSession>
          }
          groupBy: {
            args: Prisma.FactSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<FactSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.FactSessionCountArgs<ExtArgs>
            result:
              | $Utils.Optional<FactSessionCountAggregateOutputType>
              | number
          }
        }
      }
      FactPageview: {
        payload: Prisma.$FactPageviewPayload<ExtArgs>
        fields: Prisma.FactPageviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FactPageviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactPageviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FactPageviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactPageviewPayload>
          }
          findFirst: {
            args: Prisma.FactPageviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactPageviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FactPageviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactPageviewPayload>
          }
          findMany: {
            args: Prisma.FactPageviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactPageviewPayload>[]
          }
          create: {
            args: Prisma.FactPageviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactPageviewPayload>
          }
          createMany: {
            args: Prisma.FactPageviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FactPageviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactPageviewPayload>[]
          }
          delete: {
            args: Prisma.FactPageviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactPageviewPayload>
          }
          update: {
            args: Prisma.FactPageviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactPageviewPayload>
          }
          deleteMany: {
            args: Prisma.FactPageviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FactPageviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FactPageviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactPageviewPayload>[]
          }
          upsert: {
            args: Prisma.FactPageviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactPageviewPayload>
          }
          aggregate: {
            args: Prisma.FactPageviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFactPageview>
          }
          groupBy: {
            args: Prisma.FactPageviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<FactPageviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.FactPageviewCountArgs<ExtArgs>
            result:
              | $Utils.Optional<FactPageviewCountAggregateOutputType>
              | number
          }
        }
      }
      FactSearch: {
        payload: Prisma.$FactSearchPayload<ExtArgs>
        fields: Prisma.FactSearchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FactSearchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactSearchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FactSearchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactSearchPayload>
          }
          findFirst: {
            args: Prisma.FactSearchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactSearchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FactSearchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactSearchPayload>
          }
          findMany: {
            args: Prisma.FactSearchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactSearchPayload>[]
          }
          create: {
            args: Prisma.FactSearchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactSearchPayload>
          }
          createMany: {
            args: Prisma.FactSearchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FactSearchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactSearchPayload>[]
          }
          delete: {
            args: Prisma.FactSearchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactSearchPayload>
          }
          update: {
            args: Prisma.FactSearchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactSearchPayload>
          }
          deleteMany: {
            args: Prisma.FactSearchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FactSearchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FactSearchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactSearchPayload>[]
          }
          upsert: {
            args: Prisma.FactSearchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactSearchPayload>
          }
          aggregate: {
            args: Prisma.FactSearchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFactSearch>
          }
          groupBy: {
            args: Prisma.FactSearchGroupByArgs<ExtArgs>
            result: $Utils.Optional<FactSearchGroupByOutputType>[]
          }
          count: {
            args: Prisma.FactSearchCountArgs<ExtArgs>
            result: $Utils.Optional<FactSearchCountAggregateOutputType> | number
          }
        }
      }
      FactCartActivity: {
        payload: Prisma.$FactCartActivityPayload<ExtArgs>
        fields: Prisma.FactCartActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FactCartActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactCartActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FactCartActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactCartActivityPayload>
          }
          findFirst: {
            args: Prisma.FactCartActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactCartActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FactCartActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactCartActivityPayload>
          }
          findMany: {
            args: Prisma.FactCartActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactCartActivityPayload>[]
          }
          create: {
            args: Prisma.FactCartActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactCartActivityPayload>
          }
          createMany: {
            args: Prisma.FactCartActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FactCartActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactCartActivityPayload>[]
          }
          delete: {
            args: Prisma.FactCartActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactCartActivityPayload>
          }
          update: {
            args: Prisma.FactCartActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactCartActivityPayload>
          }
          deleteMany: {
            args: Prisma.FactCartActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FactCartActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FactCartActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactCartActivityPayload>[]
          }
          upsert: {
            args: Prisma.FactCartActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactCartActivityPayload>
          }
          aggregate: {
            args: Prisma.FactCartActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFactCartActivity>
          }
          groupBy: {
            args: Prisma.FactCartActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<FactCartActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.FactCartActivityCountArgs<ExtArgs>
            result:
              | $Utils.Optional<FactCartActivityCountAggregateOutputType>
              | number
          }
        }
      }
      FactReview: {
        payload: Prisma.$FactReviewPayload<ExtArgs>
        fields: Prisma.FactReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FactReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FactReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactReviewPayload>
          }
          findFirst: {
            args: Prisma.FactReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FactReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactReviewPayload>
          }
          findMany: {
            args: Prisma.FactReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactReviewPayload>[]
          }
          create: {
            args: Prisma.FactReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactReviewPayload>
          }
          createMany: {
            args: Prisma.FactReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FactReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactReviewPayload>[]
          }
          delete: {
            args: Prisma.FactReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactReviewPayload>
          }
          update: {
            args: Prisma.FactReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactReviewPayload>
          }
          deleteMany: {
            args: Prisma.FactReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FactReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FactReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactReviewPayload>[]
          }
          upsert: {
            args: Prisma.FactReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FactReviewPayload>
          }
          aggregate: {
            args: Prisma.FactReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFactReview>
          }
          groupBy: {
            args: Prisma.FactReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<FactReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.FactReviewCountArgs<ExtArgs>
            result: $Utils.Optional<FactReviewCountAggregateOutputType> | number
          }
        }
      }
      DimProduct: {
        payload: Prisma.$DimProductPayload<ExtArgs>
        fields: Prisma.DimProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DimProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DimProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimProductPayload>
          }
          findFirst: {
            args: Prisma.DimProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DimProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimProductPayload>
          }
          findMany: {
            args: Prisma.DimProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimProductPayload>[]
          }
          create: {
            args: Prisma.DimProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimProductPayload>
          }
          createMany: {
            args: Prisma.DimProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DimProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimProductPayload>[]
          }
          delete: {
            args: Prisma.DimProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimProductPayload>
          }
          update: {
            args: Prisma.DimProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimProductPayload>
          }
          deleteMany: {
            args: Prisma.DimProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DimProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DimProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimProductPayload>[]
          }
          upsert: {
            args: Prisma.DimProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimProductPayload>
          }
          aggregate: {
            args: Prisma.DimProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDimProduct>
          }
          groupBy: {
            args: Prisma.DimProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<DimProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.DimProductCountArgs<ExtArgs>
            result: $Utils.Optional<DimProductCountAggregateOutputType> | number
          }
        }
      }
      DimUser: {
        payload: Prisma.$DimUserPayload<ExtArgs>
        fields: Prisma.DimUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DimUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DimUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimUserPayload>
          }
          findFirst: {
            args: Prisma.DimUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DimUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimUserPayload>
          }
          findMany: {
            args: Prisma.DimUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimUserPayload>[]
          }
          create: {
            args: Prisma.DimUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimUserPayload>
          }
          createMany: {
            args: Prisma.DimUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DimUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimUserPayload>[]
          }
          delete: {
            args: Prisma.DimUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimUserPayload>
          }
          update: {
            args: Prisma.DimUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimUserPayload>
          }
          deleteMany: {
            args: Prisma.DimUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DimUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DimUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimUserPayload>[]
          }
          upsert: {
            args: Prisma.DimUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimUserPayload>
          }
          aggregate: {
            args: Prisma.DimUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDimUser>
          }
          groupBy: {
            args: Prisma.DimUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<DimUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.DimUserCountArgs<ExtArgs>
            result: $Utils.Optional<DimUserCountAggregateOutputType> | number
          }
        }
      }
      DimDate: {
        payload: Prisma.$DimDatePayload<ExtArgs>
        fields: Prisma.DimDateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DimDateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimDatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DimDateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimDatePayload>
          }
          findFirst: {
            args: Prisma.DimDateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimDatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DimDateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimDatePayload>
          }
          findMany: {
            args: Prisma.DimDateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimDatePayload>[]
          }
          create: {
            args: Prisma.DimDateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimDatePayload>
          }
          createMany: {
            args: Prisma.DimDateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DimDateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimDatePayload>[]
          }
          delete: {
            args: Prisma.DimDateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimDatePayload>
          }
          update: {
            args: Prisma.DimDateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimDatePayload>
          }
          deleteMany: {
            args: Prisma.DimDateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DimDateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DimDateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimDatePayload>[]
          }
          upsert: {
            args: Prisma.DimDateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimDatePayload>
          }
          aggregate: {
            args: Prisma.DimDateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDimDate>
          }
          groupBy: {
            args: Prisma.DimDateGroupByArgs<ExtArgs>
            result: $Utils.Optional<DimDateGroupByOutputType>[]
          }
          count: {
            args: Prisma.DimDateCountArgs<ExtArgs>
            result: $Utils.Optional<DimDateCountAggregateOutputType> | number
          }
        }
      }
      DimMarketing: {
        payload: Prisma.$DimMarketingPayload<ExtArgs>
        fields: Prisma.DimMarketingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DimMarketingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimMarketingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DimMarketingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimMarketingPayload>
          }
          findFirst: {
            args: Prisma.DimMarketingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimMarketingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DimMarketingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimMarketingPayload>
          }
          findMany: {
            args: Prisma.DimMarketingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimMarketingPayload>[]
          }
          create: {
            args: Prisma.DimMarketingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimMarketingPayload>
          }
          createMany: {
            args: Prisma.DimMarketingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DimMarketingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimMarketingPayload>[]
          }
          delete: {
            args: Prisma.DimMarketingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimMarketingPayload>
          }
          update: {
            args: Prisma.DimMarketingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimMarketingPayload>
          }
          deleteMany: {
            args: Prisma.DimMarketingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DimMarketingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DimMarketingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimMarketingPayload>[]
          }
          upsert: {
            args: Prisma.DimMarketingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimMarketingPayload>
          }
          aggregate: {
            args: Prisma.DimMarketingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDimMarketing>
          }
          groupBy: {
            args: Prisma.DimMarketingGroupByArgs<ExtArgs>
            result: $Utils.Optional<DimMarketingGroupByOutputType>[]
          }
          count: {
            args: Prisma.DimMarketingCountArgs<ExtArgs>
            result:
              | $Utils.Optional<DimMarketingCountAggregateOutputType>
              | number
          }
        }
      }
      DimLocation: {
        payload: Prisma.$DimLocationPayload<ExtArgs>
        fields: Prisma.DimLocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DimLocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimLocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DimLocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimLocationPayload>
          }
          findFirst: {
            args: Prisma.DimLocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimLocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DimLocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimLocationPayload>
          }
          findMany: {
            args: Prisma.DimLocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimLocationPayload>[]
          }
          create: {
            args: Prisma.DimLocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimLocationPayload>
          }
          createMany: {
            args: Prisma.DimLocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DimLocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimLocationPayload>[]
          }
          delete: {
            args: Prisma.DimLocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimLocationPayload>
          }
          update: {
            args: Prisma.DimLocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimLocationPayload>
          }
          deleteMany: {
            args: Prisma.DimLocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DimLocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DimLocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimLocationPayload>[]
          }
          upsert: {
            args: Prisma.DimLocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DimLocationPayload>
          }
          aggregate: {
            args: Prisma.DimLocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDimLocation>
          }
          groupBy: {
            args: Prisma.DimLocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<DimLocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.DimLocationCountArgs<ExtArgs>
            result:
              | $Utils.Optional<DimLocationCountAggregateOutputType>
              | number
          }
        }
      }
      IngestOffset: {
        payload: Prisma.$IngestOffsetPayload<ExtArgs>
        fields: Prisma.IngestOffsetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IngestOffsetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestOffsetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IngestOffsetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestOffsetPayload>
          }
          findFirst: {
            args: Prisma.IngestOffsetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestOffsetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IngestOffsetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestOffsetPayload>
          }
          findMany: {
            args: Prisma.IngestOffsetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestOffsetPayload>[]
          }
          create: {
            args: Prisma.IngestOffsetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestOffsetPayload>
          }
          createMany: {
            args: Prisma.IngestOffsetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IngestOffsetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestOffsetPayload>[]
          }
          delete: {
            args: Prisma.IngestOffsetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestOffsetPayload>
          }
          update: {
            args: Prisma.IngestOffsetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestOffsetPayload>
          }
          deleteMany: {
            args: Prisma.IngestOffsetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IngestOffsetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IngestOffsetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestOffsetPayload>[]
          }
          upsert: {
            args: Prisma.IngestOffsetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestOffsetPayload>
          }
          aggregate: {
            args: Prisma.IngestOffsetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIngestOffset>
          }
          groupBy: {
            args: Prisma.IngestOffsetGroupByArgs<ExtArgs>
            result: $Utils.Optional<IngestOffsetGroupByOutputType>[]
          }
          count: {
            args: Prisma.IngestOffsetCountArgs<ExtArgs>
            result:
              | $Utils.Optional<IngestOffsetCountAggregateOutputType>
              | number
          }
        }
      }
      StagingRawEvent: {
        payload: Prisma.$StagingRawEventPayload<ExtArgs>
        fields: Prisma.StagingRawEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StagingRawEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagingRawEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StagingRawEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagingRawEventPayload>
          }
          findFirst: {
            args: Prisma.StagingRawEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagingRawEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StagingRawEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagingRawEventPayload>
          }
          findMany: {
            args: Prisma.StagingRawEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagingRawEventPayload>[]
          }
          create: {
            args: Prisma.StagingRawEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagingRawEventPayload>
          }
          createMany: {
            args: Prisma.StagingRawEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StagingRawEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagingRawEventPayload>[]
          }
          delete: {
            args: Prisma.StagingRawEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagingRawEventPayload>
          }
          update: {
            args: Prisma.StagingRawEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagingRawEventPayload>
          }
          deleteMany: {
            args: Prisma.StagingRawEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StagingRawEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StagingRawEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagingRawEventPayload>[]
          }
          upsert: {
            args: Prisma.StagingRawEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagingRawEventPayload>
          }
          aggregate: {
            args: Prisma.StagingRawEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStagingRawEvent>
          }
          groupBy: {
            args: Prisma.StagingRawEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<StagingRawEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.StagingRawEventCountArgs<ExtArgs>
            result:
              | $Utils.Optional<StagingRawEventCountAggregateOutputType>
              | number
          }
        }
      }
      AggDailyStats: {
        payload: Prisma.$AggDailyStatsPayload<ExtArgs>
        fields: Prisma.AggDailyStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AggDailyStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AggDailyStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AggDailyStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AggDailyStatsPayload>
          }
          findFirst: {
            args: Prisma.AggDailyStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AggDailyStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AggDailyStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AggDailyStatsPayload>
          }
          findMany: {
            args: Prisma.AggDailyStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AggDailyStatsPayload>[]
          }
          create: {
            args: Prisma.AggDailyStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AggDailyStatsPayload>
          }
          createMany: {
            args: Prisma.AggDailyStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AggDailyStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AggDailyStatsPayload>[]
          }
          delete: {
            args: Prisma.AggDailyStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AggDailyStatsPayload>
          }
          update: {
            args: Prisma.AggDailyStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AggDailyStatsPayload>
          }
          deleteMany: {
            args: Prisma.AggDailyStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AggDailyStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AggDailyStatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AggDailyStatsPayload>[]
          }
          upsert: {
            args: Prisma.AggDailyStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AggDailyStatsPayload>
          }
          aggregate: {
            args: Prisma.AggDailyStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAggDailyStats>
          }
          groupBy: {
            args: Prisma.AggDailyStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AggDailyStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AggDailyStatsCountArgs<ExtArgs>
            result:
              | $Utils.Optional<AggDailyStatsCountAggregateOutputType>
              | number
          }
        }
      }
      AggProductPerformance: {
        payload: Prisma.$AggProductPerformancePayload<ExtArgs>
        fields: Prisma.AggProductPerformanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AggProductPerformanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AggProductPerformancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AggProductPerformanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AggProductPerformancePayload>
          }
          findFirst: {
            args: Prisma.AggProductPerformanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AggProductPerformancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AggProductPerformanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AggProductPerformancePayload>
          }
          findMany: {
            args: Prisma.AggProductPerformanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AggProductPerformancePayload>[]
          }
          create: {
            args: Prisma.AggProductPerformanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AggProductPerformancePayload>
          }
          createMany: {
            args: Prisma.AggProductPerformanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AggProductPerformanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AggProductPerformancePayload>[]
          }
          delete: {
            args: Prisma.AggProductPerformanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AggProductPerformancePayload>
          }
          update: {
            args: Prisma.AggProductPerformanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AggProductPerformancePayload>
          }
          deleteMany: {
            args: Prisma.AggProductPerformanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AggProductPerformanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AggProductPerformanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AggProductPerformancePayload>[]
          }
          upsert: {
            args: Prisma.AggProductPerformanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AggProductPerformancePayload>
          }
          aggregate: {
            args: Prisma.AggProductPerformanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAggProductPerformance>
          }
          groupBy: {
            args: Prisma.AggProductPerformanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AggProductPerformanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AggProductPerformanceCountArgs<ExtArgs>
            result:
              | $Utils.Optional<AggProductPerformanceCountAggregateOutputType>
              | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]]
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]]
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]]
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]]
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<
    'define',
    Prisma.TypeMapCb,
    $Extensions.DefaultArgs
  >
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     *
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     *
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    factOrder?: FactOrderOmit
    factOrderItem?: FactOrderItemOmit
    factPayment?: FactPaymentOmit
    factShipment?: FactShipmentOmit
    factSession?: FactSessionOmit
    factPageview?: FactPageviewOmit
    factSearch?: FactSearchOmit
    factCartActivity?: FactCartActivityOmit
    factReview?: FactReviewOmit
    dimProduct?: DimProductOmit
    dimUser?: DimUserOmit
    dimDate?: DimDateOmit
    dimMarketing?: DimMarketingOmit
    dimLocation?: DimLocationOmit
    ingestOffset?: IngestOffsetOmit
    stagingRawEvent?: StagingRawEventOmit
    aggDailyStats?: AggDailyStatsOmit
    aggProductPerformance?: AggProductPerformanceOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >

  export type GetEvents<T extends any[]> =
    T extends Array<LogLevel | LogDefinition> ? GetLogType<T[number]> : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */

  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(
    log: Array<LogLevel | LogDefinition>
  ): LogLevel | undefined

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<
    Prisma.DefaultPrismaClient,
    runtime.ITXClientDenyList
  >

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */

  /**
   * Models
   */

  /**
   * Model FactOrder
   */

  export type AggregateFactOrder = {
    _count: FactOrderCountAggregateOutputType | null
    _avg: FactOrderAvgAggregateOutputType | null
    _sum: FactOrderSumAggregateOutputType | null
    _min: FactOrderMinAggregateOutputType | null
    _max: FactOrderMaxAggregateOutputType | null
  }

  export type FactOrderAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    userId: number | null
    dateId: number | null
    subtotal: Decimal | null
    taxTotal: Decimal | null
    shippingTotal: Decimal | null
    discountTotal: Decimal | null
    grandTotal: Decimal | null
    marginTotal: Decimal | null
    itemCount: number | null
  }

  export type FactOrderSumAggregateOutputType = {
    id: bigint | null
    orderId: bigint | null
    userId: bigint | null
    dateId: number | null
    subtotal: Decimal | null
    taxTotal: Decimal | null
    shippingTotal: Decimal | null
    discountTotal: Decimal | null
    grandTotal: Decimal | null
    marginTotal: Decimal | null
    itemCount: number | null
  }

  export type FactOrderMinAggregateOutputType = {
    id: bigint | null
    orderId: bigint | null
    userId: bigint | null
    orderTs: Date | null
    dateId: number | null
    subtotal: Decimal | null
    taxTotal: Decimal | null
    shippingTotal: Decimal | null
    discountTotal: Decimal | null
    grandTotal: Decimal | null
    marginTotal: Decimal | null
    itemCount: number | null
    status: string | null
    paymentStatus: string | null
    shippingStatus: string | null
    currency: string | null
    source: string | null
    couponCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
    shippedAt: Date | null
    deliveredAt: Date | null
  }

  export type FactOrderMaxAggregateOutputType = {
    id: bigint | null
    orderId: bigint | null
    userId: bigint | null
    orderTs: Date | null
    dateId: number | null
    subtotal: Decimal | null
    taxTotal: Decimal | null
    shippingTotal: Decimal | null
    discountTotal: Decimal | null
    grandTotal: Decimal | null
    marginTotal: Decimal | null
    itemCount: number | null
    status: string | null
    paymentStatus: string | null
    shippingStatus: string | null
    currency: string | null
    source: string | null
    couponCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
    shippedAt: Date | null
    deliveredAt: Date | null
  }

  export type FactOrderCountAggregateOutputType = {
    id: number
    orderId: number
    userId: number
    orderTs: number
    dateId: number
    subtotal: number
    taxTotal: number
    shippingTotal: number
    discountTotal: number
    grandTotal: number
    marginTotal: number
    itemCount: number
    status: number
    paymentStatus: number
    shippingStatus: number
    currency: number
    source: number
    couponCode: number
    createdAt: number
    updatedAt: number
    shippedAt: number
    deliveredAt: number
    _all: number
  }

  export type FactOrderAvgAggregateInputType = {
    id?: true
    orderId?: true
    userId?: true
    dateId?: true
    subtotal?: true
    taxTotal?: true
    shippingTotal?: true
    discountTotal?: true
    grandTotal?: true
    marginTotal?: true
    itemCount?: true
  }

  export type FactOrderSumAggregateInputType = {
    id?: true
    orderId?: true
    userId?: true
    dateId?: true
    subtotal?: true
    taxTotal?: true
    shippingTotal?: true
    discountTotal?: true
    grandTotal?: true
    marginTotal?: true
    itemCount?: true
  }

  export type FactOrderMinAggregateInputType = {
    id?: true
    orderId?: true
    userId?: true
    orderTs?: true
    dateId?: true
    subtotal?: true
    taxTotal?: true
    shippingTotal?: true
    discountTotal?: true
    grandTotal?: true
    marginTotal?: true
    itemCount?: true
    status?: true
    paymentStatus?: true
    shippingStatus?: true
    currency?: true
    source?: true
    couponCode?: true
    createdAt?: true
    updatedAt?: true
    shippedAt?: true
    deliveredAt?: true
  }

  export type FactOrderMaxAggregateInputType = {
    id?: true
    orderId?: true
    userId?: true
    orderTs?: true
    dateId?: true
    subtotal?: true
    taxTotal?: true
    shippingTotal?: true
    discountTotal?: true
    grandTotal?: true
    marginTotal?: true
    itemCount?: true
    status?: true
    paymentStatus?: true
    shippingStatus?: true
    currency?: true
    source?: true
    couponCode?: true
    createdAt?: true
    updatedAt?: true
    shippedAt?: true
    deliveredAt?: true
  }

  export type FactOrderCountAggregateInputType = {
    id?: true
    orderId?: true
    userId?: true
    orderTs?: true
    dateId?: true
    subtotal?: true
    taxTotal?: true
    shippingTotal?: true
    discountTotal?: true
    grandTotal?: true
    marginTotal?: true
    itemCount?: true
    status?: true
    paymentStatus?: true
    shippingStatus?: true
    currency?: true
    source?: true
    couponCode?: true
    createdAt?: true
    updatedAt?: true
    shippedAt?: true
    deliveredAt?: true
    _all?: true
  }

  export type FactOrderAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FactOrder to aggregate.
     */
    where?: FactOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactOrders to fetch.
     */
    orderBy?:
      | FactOrderOrderByWithRelationInput
      | FactOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: FactOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned FactOrders
     **/
    _count?: true | FactOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: FactOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: FactOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FactOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FactOrderMaxAggregateInputType
  }

  export type GetFactOrderAggregateType<T extends FactOrderAggregateArgs> = {
    [P in keyof T & keyof AggregateFactOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFactOrder[P]>
      : GetScalarType<T[P], AggregateFactOrder[P]>
  }

  export type FactOrderGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FactOrderWhereInput
    orderBy?:
      | FactOrderOrderByWithAggregationInput
      | FactOrderOrderByWithAggregationInput[]
    by: FactOrderScalarFieldEnum[] | FactOrderScalarFieldEnum
    having?: FactOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FactOrderCountAggregateInputType | true
    _avg?: FactOrderAvgAggregateInputType
    _sum?: FactOrderSumAggregateInputType
    _min?: FactOrderMinAggregateInputType
    _max?: FactOrderMaxAggregateInputType
  }

  export type FactOrderGroupByOutputType = {
    id: bigint
    orderId: bigint
    userId: bigint | null
    orderTs: Date
    dateId: number
    subtotal: Decimal
    taxTotal: Decimal
    shippingTotal: Decimal
    discountTotal: Decimal
    grandTotal: Decimal
    marginTotal: Decimal | null
    itemCount: number
    status: string
    paymentStatus: string
    shippingStatus: string
    currency: string
    source: string | null
    couponCode: string | null
    createdAt: Date
    updatedAt: Date
    shippedAt: Date | null
    deliveredAt: Date | null
    _count: FactOrderCountAggregateOutputType | null
    _avg: FactOrderAvgAggregateOutputType | null
    _sum: FactOrderSumAggregateOutputType | null
    _min: FactOrderMinAggregateOutputType | null
    _max: FactOrderMaxAggregateOutputType | null
  }

  type GetFactOrderGroupByPayload<T extends FactOrderGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<FactOrderGroupByOutputType, T['by']> & {
          [P in keyof T & keyof FactOrderGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FactOrderGroupByOutputType[P]>
            : GetScalarType<T[P], FactOrderGroupByOutputType[P]>
        }
      >
    >

  export type FactOrderSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      orderId?: boolean
      userId?: boolean
      orderTs?: boolean
      dateId?: boolean
      subtotal?: boolean
      taxTotal?: boolean
      shippingTotal?: boolean
      discountTotal?: boolean
      grandTotal?: boolean
      marginTotal?: boolean
      itemCount?: boolean
      status?: boolean
      paymentStatus?: boolean
      shippingStatus?: boolean
      currency?: boolean
      source?: boolean
      couponCode?: boolean
      createdAt?: boolean
      updatedAt?: boolean
      shippedAt?: boolean
      deliveredAt?: boolean
    },
    ExtArgs['result']['factOrder']
  >

  export type FactOrderSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      orderId?: boolean
      userId?: boolean
      orderTs?: boolean
      dateId?: boolean
      subtotal?: boolean
      taxTotal?: boolean
      shippingTotal?: boolean
      discountTotal?: boolean
      grandTotal?: boolean
      marginTotal?: boolean
      itemCount?: boolean
      status?: boolean
      paymentStatus?: boolean
      shippingStatus?: boolean
      currency?: boolean
      source?: boolean
      couponCode?: boolean
      createdAt?: boolean
      updatedAt?: boolean
      shippedAt?: boolean
      deliveredAt?: boolean
    },
    ExtArgs['result']['factOrder']
  >

  export type FactOrderSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      orderId?: boolean
      userId?: boolean
      orderTs?: boolean
      dateId?: boolean
      subtotal?: boolean
      taxTotal?: boolean
      shippingTotal?: boolean
      discountTotal?: boolean
      grandTotal?: boolean
      marginTotal?: boolean
      itemCount?: boolean
      status?: boolean
      paymentStatus?: boolean
      shippingStatus?: boolean
      currency?: boolean
      source?: boolean
      couponCode?: boolean
      createdAt?: boolean
      updatedAt?: boolean
      shippedAt?: boolean
      deliveredAt?: boolean
    },
    ExtArgs['result']['factOrder']
  >

  export type FactOrderSelectScalar = {
    id?: boolean
    orderId?: boolean
    userId?: boolean
    orderTs?: boolean
    dateId?: boolean
    subtotal?: boolean
    taxTotal?: boolean
    shippingTotal?: boolean
    discountTotal?: boolean
    grandTotal?: boolean
    marginTotal?: boolean
    itemCount?: boolean
    status?: boolean
    paymentStatus?: boolean
    shippingStatus?: boolean
    currency?: boolean
    source?: boolean
    couponCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shippedAt?: boolean
    deliveredAt?: boolean
  }

  export type FactOrderOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'orderId'
    | 'userId'
    | 'orderTs'
    | 'dateId'
    | 'subtotal'
    | 'taxTotal'
    | 'shippingTotal'
    | 'discountTotal'
    | 'grandTotal'
    | 'marginTotal'
    | 'itemCount'
    | 'status'
    | 'paymentStatus'
    | 'shippingStatus'
    | 'currency'
    | 'source'
    | 'couponCode'
    | 'createdAt'
    | 'updatedAt'
    | 'shippedAt'
    | 'deliveredAt',
    ExtArgs['result']['factOrder']
  >

  export type $FactOrderPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'FactOrder'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        id: bigint
        orderId: bigint
        userId: bigint | null
        orderTs: Date
        dateId: number
        subtotal: Prisma.Decimal
        taxTotal: Prisma.Decimal
        shippingTotal: Prisma.Decimal
        discountTotal: Prisma.Decimal
        grandTotal: Prisma.Decimal
        marginTotal: Prisma.Decimal | null
        itemCount: number
        status: string
        paymentStatus: string
        shippingStatus: string
        currency: string
        source: string | null
        couponCode: string | null
        createdAt: Date
        updatedAt: Date
        shippedAt: Date | null
        deliveredAt: Date | null
      },
      ExtArgs['result']['factOrder']
    >
    composites: {}
  }

  type FactOrderGetPayload<
    S extends boolean | null | undefined | FactOrderDefaultArgs,
  > = $Result.GetResult<Prisma.$FactOrderPayload, S>

  type FactOrderCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    FactOrderFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: FactOrderCountAggregateInputType | true
  }

  export interface FactOrderDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['FactOrder']
      meta: { name: 'FactOrder' }
    }
    /**
     * Find zero or one FactOrder that matches the filter.
     * @param {FactOrderFindUniqueArgs} args - Arguments to find a FactOrder
     * @example
     * // Get one FactOrder
     * const factOrder = await prisma.factOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FactOrderFindUniqueArgs>(
      args: SelectSubset<T, FactOrderFindUniqueArgs<ExtArgs>>
    ): Prisma__FactOrderClient<
      $Result.GetResult<
        Prisma.$FactOrderPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one FactOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FactOrderFindUniqueOrThrowArgs} args - Arguments to find a FactOrder
     * @example
     * // Get one FactOrder
     * const factOrder = await prisma.factOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FactOrderFindUniqueOrThrowArgs>(
      args: SelectSubset<T, FactOrderFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FactOrderClient<
      $Result.GetResult<
        Prisma.$FactOrderPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first FactOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactOrderFindFirstArgs} args - Arguments to find a FactOrder
     * @example
     * // Get one FactOrder
     * const factOrder = await prisma.factOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FactOrderFindFirstArgs>(
      args?: SelectSubset<T, FactOrderFindFirstArgs<ExtArgs>>
    ): Prisma__FactOrderClient<
      $Result.GetResult<
        Prisma.$FactOrderPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first FactOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactOrderFindFirstOrThrowArgs} args - Arguments to find a FactOrder
     * @example
     * // Get one FactOrder
     * const factOrder = await prisma.factOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FactOrderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FactOrderFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FactOrderClient<
      $Result.GetResult<
        Prisma.$FactOrderPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more FactOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FactOrders
     * const factOrders = await prisma.factOrder.findMany()
     *
     * // Get first 10 FactOrders
     * const factOrders = await prisma.factOrder.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const factOrderWithIdOnly = await prisma.factOrder.findMany({ select: { id: true } })
     *
     */
    findMany<T extends FactOrderFindManyArgs>(
      args?: SelectSubset<T, FactOrderFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FactOrderPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a FactOrder.
     * @param {FactOrderCreateArgs} args - Arguments to create a FactOrder.
     * @example
     * // Create one FactOrder
     * const FactOrder = await prisma.factOrder.create({
     *   data: {
     *     // ... data to create a FactOrder
     *   }
     * })
     *
     */
    create<T extends FactOrderCreateArgs>(
      args: SelectSubset<T, FactOrderCreateArgs<ExtArgs>>
    ): Prisma__FactOrderClient<
      $Result.GetResult<
        Prisma.$FactOrderPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many FactOrders.
     * @param {FactOrderCreateManyArgs} args - Arguments to create many FactOrders.
     * @example
     * // Create many FactOrders
     * const factOrder = await prisma.factOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends FactOrderCreateManyArgs>(
      args?: SelectSubset<T, FactOrderCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FactOrders and returns the data saved in the database.
     * @param {FactOrderCreateManyAndReturnArgs} args - Arguments to create many FactOrders.
     * @example
     * // Create many FactOrders
     * const factOrder = await prisma.factOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many FactOrders and only return the `id`
     * const factOrderWithIdOnly = await prisma.factOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends FactOrderCreateManyAndReturnArgs>(
      args?: SelectSubset<T, FactOrderCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FactOrderPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Delete a FactOrder.
     * @param {FactOrderDeleteArgs} args - Arguments to delete one FactOrder.
     * @example
     * // Delete one FactOrder
     * const FactOrder = await prisma.factOrder.delete({
     *   where: {
     *     // ... filter to delete one FactOrder
     *   }
     * })
     *
     */
    delete<T extends FactOrderDeleteArgs>(
      args: SelectSubset<T, FactOrderDeleteArgs<ExtArgs>>
    ): Prisma__FactOrderClient<
      $Result.GetResult<
        Prisma.$FactOrderPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one FactOrder.
     * @param {FactOrderUpdateArgs} args - Arguments to update one FactOrder.
     * @example
     * // Update one FactOrder
     * const factOrder = await prisma.factOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends FactOrderUpdateArgs>(
      args: SelectSubset<T, FactOrderUpdateArgs<ExtArgs>>
    ): Prisma__FactOrderClient<
      $Result.GetResult<
        Prisma.$FactOrderPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more FactOrders.
     * @param {FactOrderDeleteManyArgs} args - Arguments to filter FactOrders to delete.
     * @example
     * // Delete a few FactOrders
     * const { count } = await prisma.factOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends FactOrderDeleteManyArgs>(
      args?: SelectSubset<T, FactOrderDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FactOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FactOrders
     * const factOrder = await prisma.factOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends FactOrderUpdateManyArgs>(
      args: SelectSubset<T, FactOrderUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FactOrders and returns the data updated in the database.
     * @param {FactOrderUpdateManyAndReturnArgs} args - Arguments to update many FactOrders.
     * @example
     * // Update many FactOrders
     * const factOrder = await prisma.factOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more FactOrders and only return the `id`
     * const factOrderWithIdOnly = await prisma.factOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends FactOrderUpdateManyAndReturnArgs>(
      args: SelectSubset<T, FactOrderUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FactOrderPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Create or update one FactOrder.
     * @param {FactOrderUpsertArgs} args - Arguments to update or create a FactOrder.
     * @example
     * // Update or create a FactOrder
     * const factOrder = await prisma.factOrder.upsert({
     *   create: {
     *     // ... data to create a FactOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FactOrder we want to update
     *   }
     * })
     */
    upsert<T extends FactOrderUpsertArgs>(
      args: SelectSubset<T, FactOrderUpsertArgs<ExtArgs>>
    ): Prisma__FactOrderClient<
      $Result.GetResult<
        Prisma.$FactOrderPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of FactOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactOrderCountArgs} args - Arguments to filter FactOrders to count.
     * @example
     * // Count the number of FactOrders
     * const count = await prisma.factOrder.count({
     *   where: {
     *     // ... the filter for the FactOrders we want to count
     *   }
     * })
     **/
    count<T extends FactOrderCountArgs>(
      args?: Subset<T, FactOrderCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FactOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FactOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FactOrderAggregateArgs>(
      args: Subset<T, FactOrderAggregateArgs>
    ): Prisma.PrismaPromise<GetFactOrderAggregateType<T>>

    /**
     * Group by FactOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends FactOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FactOrderGroupByArgs['orderBy'] }
        : { orderBy?: FactOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ]
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, FactOrderGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetFactOrderGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the FactOrder model
     */
    readonly fields: FactOrderFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for FactOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FactOrderClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the FactOrder model
   */
  interface FactOrderFieldRefs {
    readonly id: FieldRef<'FactOrder', 'BigInt'>
    readonly orderId: FieldRef<'FactOrder', 'BigInt'>
    readonly userId: FieldRef<'FactOrder', 'BigInt'>
    readonly orderTs: FieldRef<'FactOrder', 'DateTime'>
    readonly dateId: FieldRef<'FactOrder', 'Int'>
    readonly subtotal: FieldRef<'FactOrder', 'Decimal'>
    readonly taxTotal: FieldRef<'FactOrder', 'Decimal'>
    readonly shippingTotal: FieldRef<'FactOrder', 'Decimal'>
    readonly discountTotal: FieldRef<'FactOrder', 'Decimal'>
    readonly grandTotal: FieldRef<'FactOrder', 'Decimal'>
    readonly marginTotal: FieldRef<'FactOrder', 'Decimal'>
    readonly itemCount: FieldRef<'FactOrder', 'Int'>
    readonly status: FieldRef<'FactOrder', 'String'>
    readonly paymentStatus: FieldRef<'FactOrder', 'String'>
    readonly shippingStatus: FieldRef<'FactOrder', 'String'>
    readonly currency: FieldRef<'FactOrder', 'String'>
    readonly source: FieldRef<'FactOrder', 'String'>
    readonly couponCode: FieldRef<'FactOrder', 'String'>
    readonly createdAt: FieldRef<'FactOrder', 'DateTime'>
    readonly updatedAt: FieldRef<'FactOrder', 'DateTime'>
    readonly shippedAt: FieldRef<'FactOrder', 'DateTime'>
    readonly deliveredAt: FieldRef<'FactOrder', 'DateTime'>
  }

  // Custom InputTypes
  /**
   * FactOrder findUnique
   */
  export type FactOrderFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactOrder
     */
    select?: FactOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactOrder
     */
    omit?: FactOrderOmit<ExtArgs> | null
    /**
     * Filter, which FactOrder to fetch.
     */
    where: FactOrderWhereUniqueInput
  }

  /**
   * FactOrder findUniqueOrThrow
   */
  export type FactOrderFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactOrder
     */
    select?: FactOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactOrder
     */
    omit?: FactOrderOmit<ExtArgs> | null
    /**
     * Filter, which FactOrder to fetch.
     */
    where: FactOrderWhereUniqueInput
  }

  /**
   * FactOrder findFirst
   */
  export type FactOrderFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactOrder
     */
    select?: FactOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactOrder
     */
    omit?: FactOrderOmit<ExtArgs> | null
    /**
     * Filter, which FactOrder to fetch.
     */
    where?: FactOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactOrders to fetch.
     */
    orderBy?:
      | FactOrderOrderByWithRelationInput
      | FactOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FactOrders.
     */
    cursor?: FactOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FactOrders.
     */
    distinct?: FactOrderScalarFieldEnum | FactOrderScalarFieldEnum[]
  }

  /**
   * FactOrder findFirstOrThrow
   */
  export type FactOrderFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactOrder
     */
    select?: FactOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactOrder
     */
    omit?: FactOrderOmit<ExtArgs> | null
    /**
     * Filter, which FactOrder to fetch.
     */
    where?: FactOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactOrders to fetch.
     */
    orderBy?:
      | FactOrderOrderByWithRelationInput
      | FactOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FactOrders.
     */
    cursor?: FactOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FactOrders.
     */
    distinct?: FactOrderScalarFieldEnum | FactOrderScalarFieldEnum[]
  }

  /**
   * FactOrder findMany
   */
  export type FactOrderFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactOrder
     */
    select?: FactOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactOrder
     */
    omit?: FactOrderOmit<ExtArgs> | null
    /**
     * Filter, which FactOrders to fetch.
     */
    where?: FactOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactOrders to fetch.
     */
    orderBy?:
      | FactOrderOrderByWithRelationInput
      | FactOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing FactOrders.
     */
    cursor?: FactOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactOrders.
     */
    skip?: number
    distinct?: FactOrderScalarFieldEnum | FactOrderScalarFieldEnum[]
  }

  /**
   * FactOrder create
   */
  export type FactOrderCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactOrder
     */
    select?: FactOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactOrder
     */
    omit?: FactOrderOmit<ExtArgs> | null
    /**
     * The data needed to create a FactOrder.
     */
    data: XOR<FactOrderCreateInput, FactOrderUncheckedCreateInput>
  }

  /**
   * FactOrder createMany
   */
  export type FactOrderCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many FactOrders.
     */
    data: FactOrderCreateManyInput | FactOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FactOrder createManyAndReturn
   */
  export type FactOrderCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactOrder
     */
    select?: FactOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FactOrder
     */
    omit?: FactOrderOmit<ExtArgs> | null
    /**
     * The data used to create many FactOrders.
     */
    data: FactOrderCreateManyInput | FactOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FactOrder update
   */
  export type FactOrderUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactOrder
     */
    select?: FactOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactOrder
     */
    omit?: FactOrderOmit<ExtArgs> | null
    /**
     * The data needed to update a FactOrder.
     */
    data: XOR<FactOrderUpdateInput, FactOrderUncheckedUpdateInput>
    /**
     * Choose, which FactOrder to update.
     */
    where: FactOrderWhereUniqueInput
  }

  /**
   * FactOrder updateMany
   */
  export type FactOrderUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update FactOrders.
     */
    data: XOR<
      FactOrderUpdateManyMutationInput,
      FactOrderUncheckedUpdateManyInput
    >
    /**
     * Filter which FactOrders to update
     */
    where?: FactOrderWhereInput
    /**
     * Limit how many FactOrders to update.
     */
    limit?: number
  }

  /**
   * FactOrder updateManyAndReturn
   */
  export type FactOrderUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactOrder
     */
    select?: FactOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FactOrder
     */
    omit?: FactOrderOmit<ExtArgs> | null
    /**
     * The data used to update FactOrders.
     */
    data: XOR<
      FactOrderUpdateManyMutationInput,
      FactOrderUncheckedUpdateManyInput
    >
    /**
     * Filter which FactOrders to update
     */
    where?: FactOrderWhereInput
    /**
     * Limit how many FactOrders to update.
     */
    limit?: number
  }

  /**
   * FactOrder upsert
   */
  export type FactOrderUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactOrder
     */
    select?: FactOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactOrder
     */
    omit?: FactOrderOmit<ExtArgs> | null
    /**
     * The filter to search for the FactOrder to update in case it exists.
     */
    where: FactOrderWhereUniqueInput
    /**
     * In case the FactOrder found by the `where` argument doesn't exist, create a new FactOrder with this data.
     */
    create: XOR<FactOrderCreateInput, FactOrderUncheckedCreateInput>
    /**
     * In case the FactOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FactOrderUpdateInput, FactOrderUncheckedUpdateInput>
  }

  /**
   * FactOrder delete
   */
  export type FactOrderDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactOrder
     */
    select?: FactOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactOrder
     */
    omit?: FactOrderOmit<ExtArgs> | null
    /**
     * Filter which FactOrder to delete.
     */
    where: FactOrderWhereUniqueInput
  }

  /**
   * FactOrder deleteMany
   */
  export type FactOrderDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FactOrders to delete
     */
    where?: FactOrderWhereInput
    /**
     * Limit how many FactOrders to delete.
     */
    limit?: number
  }

  /**
   * FactOrder without action
   */
  export type FactOrderDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactOrder
     */
    select?: FactOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactOrder
     */
    omit?: FactOrderOmit<ExtArgs> | null
  }

  /**
   * Model FactOrderItem
   */

  export type AggregateFactOrderItem = {
    _count: FactOrderItemCountAggregateOutputType | null
    _avg: FactOrderItemAvgAggregateOutputType | null
    _sum: FactOrderItemSumAggregateOutputType | null
    _min: FactOrderItemMinAggregateOutputType | null
    _max: FactOrderItemMaxAggregateOutputType | null
  }

  export type FactOrderItemAvgAggregateOutputType = {
    id: number | null
    orderItemId: number | null
    orderId: number | null
    productId: number | null
    productScId: number | null
    dateId: number | null
    qty: number | null
    unitPrice: Decimal | null
    unitCost: Decimal | null
    taxAmount: Decimal | null
    discountAmount: Decimal | null
    extendedPrice: Decimal | null
    margin: Decimal | null
  }

  export type FactOrderItemSumAggregateOutputType = {
    id: bigint | null
    orderItemId: bigint | null
    orderId: bigint | null
    productId: bigint | null
    productScId: bigint | null
    dateId: number | null
    qty: number | null
    unitPrice: Decimal | null
    unitCost: Decimal | null
    taxAmount: Decimal | null
    discountAmount: Decimal | null
    extendedPrice: Decimal | null
    margin: Decimal | null
  }

  export type FactOrderItemMinAggregateOutputType = {
    id: bigint | null
    orderItemId: bigint | null
    orderId: bigint | null
    productId: bigint | null
    productScId: bigint | null
    dateId: number | null
    orderTs: Date | null
    qty: number | null
    unitPrice: Decimal | null
    unitCost: Decimal | null
    taxAmount: Decimal | null
    discountAmount: Decimal | null
    extendedPrice: Decimal | null
    margin: Decimal | null
    variantSku: string | null
    productName: string | null
    categoryName: string | null
    brandName: string | null
    isReturned: boolean | null
    createdAt: Date | null
  }

  export type FactOrderItemMaxAggregateOutputType = {
    id: bigint | null
    orderItemId: bigint | null
    orderId: bigint | null
    productId: bigint | null
    productScId: bigint | null
    dateId: number | null
    orderTs: Date | null
    qty: number | null
    unitPrice: Decimal | null
    unitCost: Decimal | null
    taxAmount: Decimal | null
    discountAmount: Decimal | null
    extendedPrice: Decimal | null
    margin: Decimal | null
    variantSku: string | null
    productName: string | null
    categoryName: string | null
    brandName: string | null
    isReturned: boolean | null
    createdAt: Date | null
  }

  export type FactOrderItemCountAggregateOutputType = {
    id: number
    orderItemId: number
    orderId: number
    productId: number
    productScId: number
    dateId: number
    orderTs: number
    qty: number
    unitPrice: number
    unitCost: number
    taxAmount: number
    discountAmount: number
    extendedPrice: number
    margin: number
    variantSku: number
    productName: number
    categoryName: number
    brandName: number
    isReturned: number
    createdAt: number
    _all: number
  }

  export type FactOrderItemAvgAggregateInputType = {
    id?: true
    orderItemId?: true
    orderId?: true
    productId?: true
    productScId?: true
    dateId?: true
    qty?: true
    unitPrice?: true
    unitCost?: true
    taxAmount?: true
    discountAmount?: true
    extendedPrice?: true
    margin?: true
  }

  export type FactOrderItemSumAggregateInputType = {
    id?: true
    orderItemId?: true
    orderId?: true
    productId?: true
    productScId?: true
    dateId?: true
    qty?: true
    unitPrice?: true
    unitCost?: true
    taxAmount?: true
    discountAmount?: true
    extendedPrice?: true
    margin?: true
  }

  export type FactOrderItemMinAggregateInputType = {
    id?: true
    orderItemId?: true
    orderId?: true
    productId?: true
    productScId?: true
    dateId?: true
    orderTs?: true
    qty?: true
    unitPrice?: true
    unitCost?: true
    taxAmount?: true
    discountAmount?: true
    extendedPrice?: true
    margin?: true
    variantSku?: true
    productName?: true
    categoryName?: true
    brandName?: true
    isReturned?: true
    createdAt?: true
  }

  export type FactOrderItemMaxAggregateInputType = {
    id?: true
    orderItemId?: true
    orderId?: true
    productId?: true
    productScId?: true
    dateId?: true
    orderTs?: true
    qty?: true
    unitPrice?: true
    unitCost?: true
    taxAmount?: true
    discountAmount?: true
    extendedPrice?: true
    margin?: true
    variantSku?: true
    productName?: true
    categoryName?: true
    brandName?: true
    isReturned?: true
    createdAt?: true
  }

  export type FactOrderItemCountAggregateInputType = {
    id?: true
    orderItemId?: true
    orderId?: true
    productId?: true
    productScId?: true
    dateId?: true
    orderTs?: true
    qty?: true
    unitPrice?: true
    unitCost?: true
    taxAmount?: true
    discountAmount?: true
    extendedPrice?: true
    margin?: true
    variantSku?: true
    productName?: true
    categoryName?: true
    brandName?: true
    isReturned?: true
    createdAt?: true
    _all?: true
  }

  export type FactOrderItemAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FactOrderItem to aggregate.
     */
    where?: FactOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactOrderItems to fetch.
     */
    orderBy?:
      | FactOrderItemOrderByWithRelationInput
      | FactOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: FactOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned FactOrderItems
     **/
    _count?: true | FactOrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: FactOrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: FactOrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FactOrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FactOrderItemMaxAggregateInputType
  }

  export type GetFactOrderItemAggregateType<
    T extends FactOrderItemAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateFactOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFactOrderItem[P]>
      : GetScalarType<T[P], AggregateFactOrderItem[P]>
  }

  export type FactOrderItemGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FactOrderItemWhereInput
    orderBy?:
      | FactOrderItemOrderByWithAggregationInput
      | FactOrderItemOrderByWithAggregationInput[]
    by: FactOrderItemScalarFieldEnum[] | FactOrderItemScalarFieldEnum
    having?: FactOrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FactOrderItemCountAggregateInputType | true
    _avg?: FactOrderItemAvgAggregateInputType
    _sum?: FactOrderItemSumAggregateInputType
    _min?: FactOrderItemMinAggregateInputType
    _max?: FactOrderItemMaxAggregateInputType
  }

  export type FactOrderItemGroupByOutputType = {
    id: bigint
    orderItemId: bigint
    orderId: bigint
    productId: bigint
    productScId: bigint | null
    dateId: number
    orderTs: Date
    qty: number
    unitPrice: Decimal
    unitCost: Decimal | null
    taxAmount: Decimal
    discountAmount: Decimal
    extendedPrice: Decimal
    margin: Decimal | null
    variantSku: string | null
    productName: string
    categoryName: string | null
    brandName: string | null
    isReturned: boolean
    createdAt: Date
    _count: FactOrderItemCountAggregateOutputType | null
    _avg: FactOrderItemAvgAggregateOutputType | null
    _sum: FactOrderItemSumAggregateOutputType | null
    _min: FactOrderItemMinAggregateOutputType | null
    _max: FactOrderItemMaxAggregateOutputType | null
  }

  type GetFactOrderItemGroupByPayload<T extends FactOrderItemGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<FactOrderItemGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof FactOrderItemGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FactOrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], FactOrderItemGroupByOutputType[P]>
        }
      >
    >

  export type FactOrderItemSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      orderItemId?: boolean
      orderId?: boolean
      productId?: boolean
      productScId?: boolean
      dateId?: boolean
      orderTs?: boolean
      qty?: boolean
      unitPrice?: boolean
      unitCost?: boolean
      taxAmount?: boolean
      discountAmount?: boolean
      extendedPrice?: boolean
      margin?: boolean
      variantSku?: boolean
      productName?: boolean
      categoryName?: boolean
      brandName?: boolean
      isReturned?: boolean
      createdAt?: boolean
    },
    ExtArgs['result']['factOrderItem']
  >

  export type FactOrderItemSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      orderItemId?: boolean
      orderId?: boolean
      productId?: boolean
      productScId?: boolean
      dateId?: boolean
      orderTs?: boolean
      qty?: boolean
      unitPrice?: boolean
      unitCost?: boolean
      taxAmount?: boolean
      discountAmount?: boolean
      extendedPrice?: boolean
      margin?: boolean
      variantSku?: boolean
      productName?: boolean
      categoryName?: boolean
      brandName?: boolean
      isReturned?: boolean
      createdAt?: boolean
    },
    ExtArgs['result']['factOrderItem']
  >

  export type FactOrderItemSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      orderItemId?: boolean
      orderId?: boolean
      productId?: boolean
      productScId?: boolean
      dateId?: boolean
      orderTs?: boolean
      qty?: boolean
      unitPrice?: boolean
      unitCost?: boolean
      taxAmount?: boolean
      discountAmount?: boolean
      extendedPrice?: boolean
      margin?: boolean
      variantSku?: boolean
      productName?: boolean
      categoryName?: boolean
      brandName?: boolean
      isReturned?: boolean
      createdAt?: boolean
    },
    ExtArgs['result']['factOrderItem']
  >

  export type FactOrderItemSelectScalar = {
    id?: boolean
    orderItemId?: boolean
    orderId?: boolean
    productId?: boolean
    productScId?: boolean
    dateId?: boolean
    orderTs?: boolean
    qty?: boolean
    unitPrice?: boolean
    unitCost?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    extendedPrice?: boolean
    margin?: boolean
    variantSku?: boolean
    productName?: boolean
    categoryName?: boolean
    brandName?: boolean
    isReturned?: boolean
    createdAt?: boolean
  }

  export type FactOrderItemOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'orderItemId'
    | 'orderId'
    | 'productId'
    | 'productScId'
    | 'dateId'
    | 'orderTs'
    | 'qty'
    | 'unitPrice'
    | 'unitCost'
    | 'taxAmount'
    | 'discountAmount'
    | 'extendedPrice'
    | 'margin'
    | 'variantSku'
    | 'productName'
    | 'categoryName'
    | 'brandName'
    | 'isReturned'
    | 'createdAt',
    ExtArgs['result']['factOrderItem']
  >

  export type $FactOrderItemPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'FactOrderItem'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        id: bigint
        orderItemId: bigint
        orderId: bigint
        productId: bigint
        productScId: bigint | null
        dateId: number
        orderTs: Date
        qty: number
        unitPrice: Prisma.Decimal
        unitCost: Prisma.Decimal | null
        taxAmount: Prisma.Decimal
        discountAmount: Prisma.Decimal
        extendedPrice: Prisma.Decimal
        margin: Prisma.Decimal | null
        variantSku: string | null
        productName: string
        categoryName: string | null
        brandName: string | null
        isReturned: boolean
        createdAt: Date
      },
      ExtArgs['result']['factOrderItem']
    >
    composites: {}
  }

  type FactOrderItemGetPayload<
    S extends boolean | null | undefined | FactOrderItemDefaultArgs,
  > = $Result.GetResult<Prisma.$FactOrderItemPayload, S>

  type FactOrderItemCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    FactOrderItemFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: FactOrderItemCountAggregateInputType | true
  }

  export interface FactOrderItemDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['FactOrderItem']
      meta: { name: 'FactOrderItem' }
    }
    /**
     * Find zero or one FactOrderItem that matches the filter.
     * @param {FactOrderItemFindUniqueArgs} args - Arguments to find a FactOrderItem
     * @example
     * // Get one FactOrderItem
     * const factOrderItem = await prisma.factOrderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FactOrderItemFindUniqueArgs>(
      args: SelectSubset<T, FactOrderItemFindUniqueArgs<ExtArgs>>
    ): Prisma__FactOrderItemClient<
      $Result.GetResult<
        Prisma.$FactOrderItemPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one FactOrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FactOrderItemFindUniqueOrThrowArgs} args - Arguments to find a FactOrderItem
     * @example
     * // Get one FactOrderItem
     * const factOrderItem = await prisma.factOrderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FactOrderItemFindUniqueOrThrowArgs>(
      args: SelectSubset<T, FactOrderItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FactOrderItemClient<
      $Result.GetResult<
        Prisma.$FactOrderItemPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first FactOrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactOrderItemFindFirstArgs} args - Arguments to find a FactOrderItem
     * @example
     * // Get one FactOrderItem
     * const factOrderItem = await prisma.factOrderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FactOrderItemFindFirstArgs>(
      args?: SelectSubset<T, FactOrderItemFindFirstArgs<ExtArgs>>
    ): Prisma__FactOrderItemClient<
      $Result.GetResult<
        Prisma.$FactOrderItemPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first FactOrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactOrderItemFindFirstOrThrowArgs} args - Arguments to find a FactOrderItem
     * @example
     * // Get one FactOrderItem
     * const factOrderItem = await prisma.factOrderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FactOrderItemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FactOrderItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FactOrderItemClient<
      $Result.GetResult<
        Prisma.$FactOrderItemPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more FactOrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactOrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FactOrderItems
     * const factOrderItems = await prisma.factOrderItem.findMany()
     *
     * // Get first 10 FactOrderItems
     * const factOrderItems = await prisma.factOrderItem.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const factOrderItemWithIdOnly = await prisma.factOrderItem.findMany({ select: { id: true } })
     *
     */
    findMany<T extends FactOrderItemFindManyArgs>(
      args?: SelectSubset<T, FactOrderItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FactOrderItemPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a FactOrderItem.
     * @param {FactOrderItemCreateArgs} args - Arguments to create a FactOrderItem.
     * @example
     * // Create one FactOrderItem
     * const FactOrderItem = await prisma.factOrderItem.create({
     *   data: {
     *     // ... data to create a FactOrderItem
     *   }
     * })
     *
     */
    create<T extends FactOrderItemCreateArgs>(
      args: SelectSubset<T, FactOrderItemCreateArgs<ExtArgs>>
    ): Prisma__FactOrderItemClient<
      $Result.GetResult<
        Prisma.$FactOrderItemPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many FactOrderItems.
     * @param {FactOrderItemCreateManyArgs} args - Arguments to create many FactOrderItems.
     * @example
     * // Create many FactOrderItems
     * const factOrderItem = await prisma.factOrderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends FactOrderItemCreateManyArgs>(
      args?: SelectSubset<T, FactOrderItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FactOrderItems and returns the data saved in the database.
     * @param {FactOrderItemCreateManyAndReturnArgs} args - Arguments to create many FactOrderItems.
     * @example
     * // Create many FactOrderItems
     * const factOrderItem = await prisma.factOrderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many FactOrderItems and only return the `id`
     * const factOrderItemWithIdOnly = await prisma.factOrderItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends FactOrderItemCreateManyAndReturnArgs>(
      args?: SelectSubset<T, FactOrderItemCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FactOrderItemPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Delete a FactOrderItem.
     * @param {FactOrderItemDeleteArgs} args - Arguments to delete one FactOrderItem.
     * @example
     * // Delete one FactOrderItem
     * const FactOrderItem = await prisma.factOrderItem.delete({
     *   where: {
     *     // ... filter to delete one FactOrderItem
     *   }
     * })
     *
     */
    delete<T extends FactOrderItemDeleteArgs>(
      args: SelectSubset<T, FactOrderItemDeleteArgs<ExtArgs>>
    ): Prisma__FactOrderItemClient<
      $Result.GetResult<
        Prisma.$FactOrderItemPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one FactOrderItem.
     * @param {FactOrderItemUpdateArgs} args - Arguments to update one FactOrderItem.
     * @example
     * // Update one FactOrderItem
     * const factOrderItem = await prisma.factOrderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends FactOrderItemUpdateArgs>(
      args: SelectSubset<T, FactOrderItemUpdateArgs<ExtArgs>>
    ): Prisma__FactOrderItemClient<
      $Result.GetResult<
        Prisma.$FactOrderItemPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more FactOrderItems.
     * @param {FactOrderItemDeleteManyArgs} args - Arguments to filter FactOrderItems to delete.
     * @example
     * // Delete a few FactOrderItems
     * const { count } = await prisma.factOrderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends FactOrderItemDeleteManyArgs>(
      args?: SelectSubset<T, FactOrderItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FactOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactOrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FactOrderItems
     * const factOrderItem = await prisma.factOrderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends FactOrderItemUpdateManyArgs>(
      args: SelectSubset<T, FactOrderItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FactOrderItems and returns the data updated in the database.
     * @param {FactOrderItemUpdateManyAndReturnArgs} args - Arguments to update many FactOrderItems.
     * @example
     * // Update many FactOrderItems
     * const factOrderItem = await prisma.factOrderItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more FactOrderItems and only return the `id`
     * const factOrderItemWithIdOnly = await prisma.factOrderItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends FactOrderItemUpdateManyAndReturnArgs>(
      args: SelectSubset<T, FactOrderItemUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FactOrderItemPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Create or update one FactOrderItem.
     * @param {FactOrderItemUpsertArgs} args - Arguments to update or create a FactOrderItem.
     * @example
     * // Update or create a FactOrderItem
     * const factOrderItem = await prisma.factOrderItem.upsert({
     *   create: {
     *     // ... data to create a FactOrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FactOrderItem we want to update
     *   }
     * })
     */
    upsert<T extends FactOrderItemUpsertArgs>(
      args: SelectSubset<T, FactOrderItemUpsertArgs<ExtArgs>>
    ): Prisma__FactOrderItemClient<
      $Result.GetResult<
        Prisma.$FactOrderItemPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of FactOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactOrderItemCountArgs} args - Arguments to filter FactOrderItems to count.
     * @example
     * // Count the number of FactOrderItems
     * const count = await prisma.factOrderItem.count({
     *   where: {
     *     // ... the filter for the FactOrderItems we want to count
     *   }
     * })
     **/
    count<T extends FactOrderItemCountArgs>(
      args?: Subset<T, FactOrderItemCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FactOrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FactOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactOrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FactOrderItemAggregateArgs>(
      args: Subset<T, FactOrderItemAggregateArgs>
    ): Prisma.PrismaPromise<GetFactOrderItemAggregateType<T>>

    /**
     * Group by FactOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactOrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends FactOrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FactOrderItemGroupByArgs['orderBy'] }
        : { orderBy?: FactOrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ]
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, FactOrderItemGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetFactOrderItemGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the FactOrderItem model
     */
    readonly fields: FactOrderItemFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for FactOrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FactOrderItemClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the FactOrderItem model
   */
  interface FactOrderItemFieldRefs {
    readonly id: FieldRef<'FactOrderItem', 'BigInt'>
    readonly orderItemId: FieldRef<'FactOrderItem', 'BigInt'>
    readonly orderId: FieldRef<'FactOrderItem', 'BigInt'>
    readonly productId: FieldRef<'FactOrderItem', 'BigInt'>
    readonly productScId: FieldRef<'FactOrderItem', 'BigInt'>
    readonly dateId: FieldRef<'FactOrderItem', 'Int'>
    readonly orderTs: FieldRef<'FactOrderItem', 'DateTime'>
    readonly qty: FieldRef<'FactOrderItem', 'Int'>
    readonly unitPrice: FieldRef<'FactOrderItem', 'Decimal'>
    readonly unitCost: FieldRef<'FactOrderItem', 'Decimal'>
    readonly taxAmount: FieldRef<'FactOrderItem', 'Decimal'>
    readonly discountAmount: FieldRef<'FactOrderItem', 'Decimal'>
    readonly extendedPrice: FieldRef<'FactOrderItem', 'Decimal'>
    readonly margin: FieldRef<'FactOrderItem', 'Decimal'>
    readonly variantSku: FieldRef<'FactOrderItem', 'String'>
    readonly productName: FieldRef<'FactOrderItem', 'String'>
    readonly categoryName: FieldRef<'FactOrderItem', 'String'>
    readonly brandName: FieldRef<'FactOrderItem', 'String'>
    readonly isReturned: FieldRef<'FactOrderItem', 'Boolean'>
    readonly createdAt: FieldRef<'FactOrderItem', 'DateTime'>
  }

  // Custom InputTypes
  /**
   * FactOrderItem findUnique
   */
  export type FactOrderItemFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactOrderItem
     */
    select?: FactOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactOrderItem
     */
    omit?: FactOrderItemOmit<ExtArgs> | null
    /**
     * Filter, which FactOrderItem to fetch.
     */
    where: FactOrderItemWhereUniqueInput
  }

  /**
   * FactOrderItem findUniqueOrThrow
   */
  export type FactOrderItemFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactOrderItem
     */
    select?: FactOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactOrderItem
     */
    omit?: FactOrderItemOmit<ExtArgs> | null
    /**
     * Filter, which FactOrderItem to fetch.
     */
    where: FactOrderItemWhereUniqueInput
  }

  /**
   * FactOrderItem findFirst
   */
  export type FactOrderItemFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactOrderItem
     */
    select?: FactOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactOrderItem
     */
    omit?: FactOrderItemOmit<ExtArgs> | null
    /**
     * Filter, which FactOrderItem to fetch.
     */
    where?: FactOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactOrderItems to fetch.
     */
    orderBy?:
      | FactOrderItemOrderByWithRelationInput
      | FactOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FactOrderItems.
     */
    cursor?: FactOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FactOrderItems.
     */
    distinct?: FactOrderItemScalarFieldEnum | FactOrderItemScalarFieldEnum[]
  }

  /**
   * FactOrderItem findFirstOrThrow
   */
  export type FactOrderItemFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactOrderItem
     */
    select?: FactOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactOrderItem
     */
    omit?: FactOrderItemOmit<ExtArgs> | null
    /**
     * Filter, which FactOrderItem to fetch.
     */
    where?: FactOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactOrderItems to fetch.
     */
    orderBy?:
      | FactOrderItemOrderByWithRelationInput
      | FactOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FactOrderItems.
     */
    cursor?: FactOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FactOrderItems.
     */
    distinct?: FactOrderItemScalarFieldEnum | FactOrderItemScalarFieldEnum[]
  }

  /**
   * FactOrderItem findMany
   */
  export type FactOrderItemFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactOrderItem
     */
    select?: FactOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactOrderItem
     */
    omit?: FactOrderItemOmit<ExtArgs> | null
    /**
     * Filter, which FactOrderItems to fetch.
     */
    where?: FactOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactOrderItems to fetch.
     */
    orderBy?:
      | FactOrderItemOrderByWithRelationInput
      | FactOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing FactOrderItems.
     */
    cursor?: FactOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactOrderItems.
     */
    skip?: number
    distinct?: FactOrderItemScalarFieldEnum | FactOrderItemScalarFieldEnum[]
  }

  /**
   * FactOrderItem create
   */
  export type FactOrderItemCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactOrderItem
     */
    select?: FactOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactOrderItem
     */
    omit?: FactOrderItemOmit<ExtArgs> | null
    /**
     * The data needed to create a FactOrderItem.
     */
    data: XOR<FactOrderItemCreateInput, FactOrderItemUncheckedCreateInput>
  }

  /**
   * FactOrderItem createMany
   */
  export type FactOrderItemCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many FactOrderItems.
     */
    data: FactOrderItemCreateManyInput | FactOrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FactOrderItem createManyAndReturn
   */
  export type FactOrderItemCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactOrderItem
     */
    select?: FactOrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FactOrderItem
     */
    omit?: FactOrderItemOmit<ExtArgs> | null
    /**
     * The data used to create many FactOrderItems.
     */
    data: FactOrderItemCreateManyInput | FactOrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FactOrderItem update
   */
  export type FactOrderItemUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactOrderItem
     */
    select?: FactOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactOrderItem
     */
    omit?: FactOrderItemOmit<ExtArgs> | null
    /**
     * The data needed to update a FactOrderItem.
     */
    data: XOR<FactOrderItemUpdateInput, FactOrderItemUncheckedUpdateInput>
    /**
     * Choose, which FactOrderItem to update.
     */
    where: FactOrderItemWhereUniqueInput
  }

  /**
   * FactOrderItem updateMany
   */
  export type FactOrderItemUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update FactOrderItems.
     */
    data: XOR<
      FactOrderItemUpdateManyMutationInput,
      FactOrderItemUncheckedUpdateManyInput
    >
    /**
     * Filter which FactOrderItems to update
     */
    where?: FactOrderItemWhereInput
    /**
     * Limit how many FactOrderItems to update.
     */
    limit?: number
  }

  /**
   * FactOrderItem updateManyAndReturn
   */
  export type FactOrderItemUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactOrderItem
     */
    select?: FactOrderItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FactOrderItem
     */
    omit?: FactOrderItemOmit<ExtArgs> | null
    /**
     * The data used to update FactOrderItems.
     */
    data: XOR<
      FactOrderItemUpdateManyMutationInput,
      FactOrderItemUncheckedUpdateManyInput
    >
    /**
     * Filter which FactOrderItems to update
     */
    where?: FactOrderItemWhereInput
    /**
     * Limit how many FactOrderItems to update.
     */
    limit?: number
  }

  /**
   * FactOrderItem upsert
   */
  export type FactOrderItemUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactOrderItem
     */
    select?: FactOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactOrderItem
     */
    omit?: FactOrderItemOmit<ExtArgs> | null
    /**
     * The filter to search for the FactOrderItem to update in case it exists.
     */
    where: FactOrderItemWhereUniqueInput
    /**
     * In case the FactOrderItem found by the `where` argument doesn't exist, create a new FactOrderItem with this data.
     */
    create: XOR<FactOrderItemCreateInput, FactOrderItemUncheckedCreateInput>
    /**
     * In case the FactOrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FactOrderItemUpdateInput, FactOrderItemUncheckedUpdateInput>
  }

  /**
   * FactOrderItem delete
   */
  export type FactOrderItemDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactOrderItem
     */
    select?: FactOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactOrderItem
     */
    omit?: FactOrderItemOmit<ExtArgs> | null
    /**
     * Filter which FactOrderItem to delete.
     */
    where: FactOrderItemWhereUniqueInput
  }

  /**
   * FactOrderItem deleteMany
   */
  export type FactOrderItemDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FactOrderItems to delete
     */
    where?: FactOrderItemWhereInput
    /**
     * Limit how many FactOrderItems to delete.
     */
    limit?: number
  }

  /**
   * FactOrderItem without action
   */
  export type FactOrderItemDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactOrderItem
     */
    select?: FactOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactOrderItem
     */
    omit?: FactOrderItemOmit<ExtArgs> | null
  }

  /**
   * Model FactPayment
   */

  export type AggregateFactPayment = {
    _count: FactPaymentCountAggregateOutputType | null
    _avg: FactPaymentAvgAggregateOutputType | null
    _sum: FactPaymentSumAggregateOutputType | null
    _min: FactPaymentMinAggregateOutputType | null
    _max: FactPaymentMaxAggregateOutputType | null
  }

  export type FactPaymentAvgAggregateOutputType = {
    id: number | null
    paymentId: number | null
    orderId: number | null
    dateId: number | null
    amount: Decimal | null
  }

  export type FactPaymentSumAggregateOutputType = {
    id: bigint | null
    paymentId: bigint | null
    orderId: bigint | null
    dateId: number | null
    amount: Decimal | null
  }

  export type FactPaymentMinAggregateOutputType = {
    id: bigint | null
    paymentId: bigint | null
    orderId: bigint | null
    dateId: number | null
    timestamp: Date | null
    amount: Decimal | null
    currency: string | null
    provider: string | null
    method: string | null
    status: string | null
    errorCode: string | null
    isSuccess: boolean | null
    createdAt: Date | null
  }

  export type FactPaymentMaxAggregateOutputType = {
    id: bigint | null
    paymentId: bigint | null
    orderId: bigint | null
    dateId: number | null
    timestamp: Date | null
    amount: Decimal | null
    currency: string | null
    provider: string | null
    method: string | null
    status: string | null
    errorCode: string | null
    isSuccess: boolean | null
    createdAt: Date | null
  }

  export type FactPaymentCountAggregateOutputType = {
    id: number
    paymentId: number
    orderId: number
    dateId: number
    timestamp: number
    amount: number
    currency: number
    provider: number
    method: number
    status: number
    errorCode: number
    isSuccess: number
    createdAt: number
    _all: number
  }

  export type FactPaymentAvgAggregateInputType = {
    id?: true
    paymentId?: true
    orderId?: true
    dateId?: true
    amount?: true
  }

  export type FactPaymentSumAggregateInputType = {
    id?: true
    paymentId?: true
    orderId?: true
    dateId?: true
    amount?: true
  }

  export type FactPaymentMinAggregateInputType = {
    id?: true
    paymentId?: true
    orderId?: true
    dateId?: true
    timestamp?: true
    amount?: true
    currency?: true
    provider?: true
    method?: true
    status?: true
    errorCode?: true
    isSuccess?: true
    createdAt?: true
  }

  export type FactPaymentMaxAggregateInputType = {
    id?: true
    paymentId?: true
    orderId?: true
    dateId?: true
    timestamp?: true
    amount?: true
    currency?: true
    provider?: true
    method?: true
    status?: true
    errorCode?: true
    isSuccess?: true
    createdAt?: true
  }

  export type FactPaymentCountAggregateInputType = {
    id?: true
    paymentId?: true
    orderId?: true
    dateId?: true
    timestamp?: true
    amount?: true
    currency?: true
    provider?: true
    method?: true
    status?: true
    errorCode?: true
    isSuccess?: true
    createdAt?: true
    _all?: true
  }

  export type FactPaymentAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FactPayment to aggregate.
     */
    where?: FactPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactPayments to fetch.
     */
    orderBy?:
      | FactPaymentOrderByWithRelationInput
      | FactPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: FactPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned FactPayments
     **/
    _count?: true | FactPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: FactPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: FactPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FactPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FactPaymentMaxAggregateInputType
  }

  export type GetFactPaymentAggregateType<T extends FactPaymentAggregateArgs> =
    {
      [P in keyof T & keyof AggregateFactPayment]: P extends '_count' | 'count'
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregateFactPayment[P]>
        : GetScalarType<T[P], AggregateFactPayment[P]>
    }

  export type FactPaymentGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FactPaymentWhereInput
    orderBy?:
      | FactPaymentOrderByWithAggregationInput
      | FactPaymentOrderByWithAggregationInput[]
    by: FactPaymentScalarFieldEnum[] | FactPaymentScalarFieldEnum
    having?: FactPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FactPaymentCountAggregateInputType | true
    _avg?: FactPaymentAvgAggregateInputType
    _sum?: FactPaymentSumAggregateInputType
    _min?: FactPaymentMinAggregateInputType
    _max?: FactPaymentMaxAggregateInputType
  }

  export type FactPaymentGroupByOutputType = {
    id: bigint
    paymentId: bigint
    orderId: bigint | null
    dateId: number
    timestamp: Date
    amount: Decimal
    currency: string
    provider: string
    method: string | null
    status: string
    errorCode: string | null
    isSuccess: boolean
    createdAt: Date
    _count: FactPaymentCountAggregateOutputType | null
    _avg: FactPaymentAvgAggregateOutputType | null
    _sum: FactPaymentSumAggregateOutputType | null
    _min: FactPaymentMinAggregateOutputType | null
    _max: FactPaymentMaxAggregateOutputType | null
  }

  type GetFactPaymentGroupByPayload<T extends FactPaymentGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<FactPaymentGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof FactPaymentGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FactPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], FactPaymentGroupByOutputType[P]>
        }
      >
    >

  export type FactPaymentSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      paymentId?: boolean
      orderId?: boolean
      dateId?: boolean
      timestamp?: boolean
      amount?: boolean
      currency?: boolean
      provider?: boolean
      method?: boolean
      status?: boolean
      errorCode?: boolean
      isSuccess?: boolean
      createdAt?: boolean
    },
    ExtArgs['result']['factPayment']
  >

  export type FactPaymentSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      paymentId?: boolean
      orderId?: boolean
      dateId?: boolean
      timestamp?: boolean
      amount?: boolean
      currency?: boolean
      provider?: boolean
      method?: boolean
      status?: boolean
      errorCode?: boolean
      isSuccess?: boolean
      createdAt?: boolean
    },
    ExtArgs['result']['factPayment']
  >

  export type FactPaymentSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      paymentId?: boolean
      orderId?: boolean
      dateId?: boolean
      timestamp?: boolean
      amount?: boolean
      currency?: boolean
      provider?: boolean
      method?: boolean
      status?: boolean
      errorCode?: boolean
      isSuccess?: boolean
      createdAt?: boolean
    },
    ExtArgs['result']['factPayment']
  >

  export type FactPaymentSelectScalar = {
    id?: boolean
    paymentId?: boolean
    orderId?: boolean
    dateId?: boolean
    timestamp?: boolean
    amount?: boolean
    currency?: boolean
    provider?: boolean
    method?: boolean
    status?: boolean
    errorCode?: boolean
    isSuccess?: boolean
    createdAt?: boolean
  }

  export type FactPaymentOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'paymentId'
    | 'orderId'
    | 'dateId'
    | 'timestamp'
    | 'amount'
    | 'currency'
    | 'provider'
    | 'method'
    | 'status'
    | 'errorCode'
    | 'isSuccess'
    | 'createdAt',
    ExtArgs['result']['factPayment']
  >

  export type $FactPaymentPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'FactPayment'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        id: bigint
        paymentId: bigint
        orderId: bigint | null
        dateId: number
        timestamp: Date
        amount: Prisma.Decimal
        currency: string
        provider: string
        method: string | null
        status: string
        errorCode: string | null
        isSuccess: boolean
        createdAt: Date
      },
      ExtArgs['result']['factPayment']
    >
    composites: {}
  }

  type FactPaymentGetPayload<
    S extends boolean | null | undefined | FactPaymentDefaultArgs,
  > = $Result.GetResult<Prisma.$FactPaymentPayload, S>

  type FactPaymentCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    FactPaymentFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: FactPaymentCountAggregateInputType | true
  }

  export interface FactPaymentDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['FactPayment']
      meta: { name: 'FactPayment' }
    }
    /**
     * Find zero or one FactPayment that matches the filter.
     * @param {FactPaymentFindUniqueArgs} args - Arguments to find a FactPayment
     * @example
     * // Get one FactPayment
     * const factPayment = await prisma.factPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FactPaymentFindUniqueArgs>(
      args: SelectSubset<T, FactPaymentFindUniqueArgs<ExtArgs>>
    ): Prisma__FactPaymentClient<
      $Result.GetResult<
        Prisma.$FactPaymentPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one FactPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FactPaymentFindUniqueOrThrowArgs} args - Arguments to find a FactPayment
     * @example
     * // Get one FactPayment
     * const factPayment = await prisma.factPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FactPaymentFindUniqueOrThrowArgs>(
      args: SelectSubset<T, FactPaymentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FactPaymentClient<
      $Result.GetResult<
        Prisma.$FactPaymentPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first FactPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactPaymentFindFirstArgs} args - Arguments to find a FactPayment
     * @example
     * // Get one FactPayment
     * const factPayment = await prisma.factPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FactPaymentFindFirstArgs>(
      args?: SelectSubset<T, FactPaymentFindFirstArgs<ExtArgs>>
    ): Prisma__FactPaymentClient<
      $Result.GetResult<
        Prisma.$FactPaymentPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first FactPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactPaymentFindFirstOrThrowArgs} args - Arguments to find a FactPayment
     * @example
     * // Get one FactPayment
     * const factPayment = await prisma.factPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FactPaymentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FactPaymentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FactPaymentClient<
      $Result.GetResult<
        Prisma.$FactPaymentPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more FactPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FactPayments
     * const factPayments = await prisma.factPayment.findMany()
     *
     * // Get first 10 FactPayments
     * const factPayments = await prisma.factPayment.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const factPaymentWithIdOnly = await prisma.factPayment.findMany({ select: { id: true } })
     *
     */
    findMany<T extends FactPaymentFindManyArgs>(
      args?: SelectSubset<T, FactPaymentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FactPaymentPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a FactPayment.
     * @param {FactPaymentCreateArgs} args - Arguments to create a FactPayment.
     * @example
     * // Create one FactPayment
     * const FactPayment = await prisma.factPayment.create({
     *   data: {
     *     // ... data to create a FactPayment
     *   }
     * })
     *
     */
    create<T extends FactPaymentCreateArgs>(
      args: SelectSubset<T, FactPaymentCreateArgs<ExtArgs>>
    ): Prisma__FactPaymentClient<
      $Result.GetResult<
        Prisma.$FactPaymentPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many FactPayments.
     * @param {FactPaymentCreateManyArgs} args - Arguments to create many FactPayments.
     * @example
     * // Create many FactPayments
     * const factPayment = await prisma.factPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends FactPaymentCreateManyArgs>(
      args?: SelectSubset<T, FactPaymentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FactPayments and returns the data saved in the database.
     * @param {FactPaymentCreateManyAndReturnArgs} args - Arguments to create many FactPayments.
     * @example
     * // Create many FactPayments
     * const factPayment = await prisma.factPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many FactPayments and only return the `id`
     * const factPaymentWithIdOnly = await prisma.factPayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends FactPaymentCreateManyAndReturnArgs>(
      args?: SelectSubset<T, FactPaymentCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FactPaymentPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Delete a FactPayment.
     * @param {FactPaymentDeleteArgs} args - Arguments to delete one FactPayment.
     * @example
     * // Delete one FactPayment
     * const FactPayment = await prisma.factPayment.delete({
     *   where: {
     *     // ... filter to delete one FactPayment
     *   }
     * })
     *
     */
    delete<T extends FactPaymentDeleteArgs>(
      args: SelectSubset<T, FactPaymentDeleteArgs<ExtArgs>>
    ): Prisma__FactPaymentClient<
      $Result.GetResult<
        Prisma.$FactPaymentPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one FactPayment.
     * @param {FactPaymentUpdateArgs} args - Arguments to update one FactPayment.
     * @example
     * // Update one FactPayment
     * const factPayment = await prisma.factPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends FactPaymentUpdateArgs>(
      args: SelectSubset<T, FactPaymentUpdateArgs<ExtArgs>>
    ): Prisma__FactPaymentClient<
      $Result.GetResult<
        Prisma.$FactPaymentPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more FactPayments.
     * @param {FactPaymentDeleteManyArgs} args - Arguments to filter FactPayments to delete.
     * @example
     * // Delete a few FactPayments
     * const { count } = await prisma.factPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends FactPaymentDeleteManyArgs>(
      args?: SelectSubset<T, FactPaymentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FactPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FactPayments
     * const factPayment = await prisma.factPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends FactPaymentUpdateManyArgs>(
      args: SelectSubset<T, FactPaymentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FactPayments and returns the data updated in the database.
     * @param {FactPaymentUpdateManyAndReturnArgs} args - Arguments to update many FactPayments.
     * @example
     * // Update many FactPayments
     * const factPayment = await prisma.factPayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more FactPayments and only return the `id`
     * const factPaymentWithIdOnly = await prisma.factPayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends FactPaymentUpdateManyAndReturnArgs>(
      args: SelectSubset<T, FactPaymentUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FactPaymentPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Create or update one FactPayment.
     * @param {FactPaymentUpsertArgs} args - Arguments to update or create a FactPayment.
     * @example
     * // Update or create a FactPayment
     * const factPayment = await prisma.factPayment.upsert({
     *   create: {
     *     // ... data to create a FactPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FactPayment we want to update
     *   }
     * })
     */
    upsert<T extends FactPaymentUpsertArgs>(
      args: SelectSubset<T, FactPaymentUpsertArgs<ExtArgs>>
    ): Prisma__FactPaymentClient<
      $Result.GetResult<
        Prisma.$FactPaymentPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of FactPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactPaymentCountArgs} args - Arguments to filter FactPayments to count.
     * @example
     * // Count the number of FactPayments
     * const count = await prisma.factPayment.count({
     *   where: {
     *     // ... the filter for the FactPayments we want to count
     *   }
     * })
     **/
    count<T extends FactPaymentCountArgs>(
      args?: Subset<T, FactPaymentCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FactPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FactPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FactPaymentAggregateArgs>(
      args: Subset<T, FactPaymentAggregateArgs>
    ): Prisma.PrismaPromise<GetFactPaymentAggregateType<T>>

    /**
     * Group by FactPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends FactPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FactPaymentGroupByArgs['orderBy'] }
        : { orderBy?: FactPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ]
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, FactPaymentGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetFactPaymentGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the FactPayment model
     */
    readonly fields: FactPaymentFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for FactPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FactPaymentClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the FactPayment model
   */
  interface FactPaymentFieldRefs {
    readonly id: FieldRef<'FactPayment', 'BigInt'>
    readonly paymentId: FieldRef<'FactPayment', 'BigInt'>
    readonly orderId: FieldRef<'FactPayment', 'BigInt'>
    readonly dateId: FieldRef<'FactPayment', 'Int'>
    readonly timestamp: FieldRef<'FactPayment', 'DateTime'>
    readonly amount: FieldRef<'FactPayment', 'Decimal'>
    readonly currency: FieldRef<'FactPayment', 'String'>
    readonly provider: FieldRef<'FactPayment', 'String'>
    readonly method: FieldRef<'FactPayment', 'String'>
    readonly status: FieldRef<'FactPayment', 'String'>
    readonly errorCode: FieldRef<'FactPayment', 'String'>
    readonly isSuccess: FieldRef<'FactPayment', 'Boolean'>
    readonly createdAt: FieldRef<'FactPayment', 'DateTime'>
  }

  // Custom InputTypes
  /**
   * FactPayment findUnique
   */
  export type FactPaymentFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactPayment
     */
    select?: FactPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactPayment
     */
    omit?: FactPaymentOmit<ExtArgs> | null
    /**
     * Filter, which FactPayment to fetch.
     */
    where: FactPaymentWhereUniqueInput
  }

  /**
   * FactPayment findUniqueOrThrow
   */
  export type FactPaymentFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactPayment
     */
    select?: FactPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactPayment
     */
    omit?: FactPaymentOmit<ExtArgs> | null
    /**
     * Filter, which FactPayment to fetch.
     */
    where: FactPaymentWhereUniqueInput
  }

  /**
   * FactPayment findFirst
   */
  export type FactPaymentFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactPayment
     */
    select?: FactPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactPayment
     */
    omit?: FactPaymentOmit<ExtArgs> | null
    /**
     * Filter, which FactPayment to fetch.
     */
    where?: FactPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactPayments to fetch.
     */
    orderBy?:
      | FactPaymentOrderByWithRelationInput
      | FactPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FactPayments.
     */
    cursor?: FactPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FactPayments.
     */
    distinct?: FactPaymentScalarFieldEnum | FactPaymentScalarFieldEnum[]
  }

  /**
   * FactPayment findFirstOrThrow
   */
  export type FactPaymentFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactPayment
     */
    select?: FactPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactPayment
     */
    omit?: FactPaymentOmit<ExtArgs> | null
    /**
     * Filter, which FactPayment to fetch.
     */
    where?: FactPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactPayments to fetch.
     */
    orderBy?:
      | FactPaymentOrderByWithRelationInput
      | FactPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FactPayments.
     */
    cursor?: FactPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FactPayments.
     */
    distinct?: FactPaymentScalarFieldEnum | FactPaymentScalarFieldEnum[]
  }

  /**
   * FactPayment findMany
   */
  export type FactPaymentFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactPayment
     */
    select?: FactPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactPayment
     */
    omit?: FactPaymentOmit<ExtArgs> | null
    /**
     * Filter, which FactPayments to fetch.
     */
    where?: FactPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactPayments to fetch.
     */
    orderBy?:
      | FactPaymentOrderByWithRelationInput
      | FactPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing FactPayments.
     */
    cursor?: FactPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactPayments.
     */
    skip?: number
    distinct?: FactPaymentScalarFieldEnum | FactPaymentScalarFieldEnum[]
  }

  /**
   * FactPayment create
   */
  export type FactPaymentCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactPayment
     */
    select?: FactPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactPayment
     */
    omit?: FactPaymentOmit<ExtArgs> | null
    /**
     * The data needed to create a FactPayment.
     */
    data: XOR<FactPaymentCreateInput, FactPaymentUncheckedCreateInput>
  }

  /**
   * FactPayment createMany
   */
  export type FactPaymentCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many FactPayments.
     */
    data: FactPaymentCreateManyInput | FactPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FactPayment createManyAndReturn
   */
  export type FactPaymentCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactPayment
     */
    select?: FactPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FactPayment
     */
    omit?: FactPaymentOmit<ExtArgs> | null
    /**
     * The data used to create many FactPayments.
     */
    data: FactPaymentCreateManyInput | FactPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FactPayment update
   */
  export type FactPaymentUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactPayment
     */
    select?: FactPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactPayment
     */
    omit?: FactPaymentOmit<ExtArgs> | null
    /**
     * The data needed to update a FactPayment.
     */
    data: XOR<FactPaymentUpdateInput, FactPaymentUncheckedUpdateInput>
    /**
     * Choose, which FactPayment to update.
     */
    where: FactPaymentWhereUniqueInput
  }

  /**
   * FactPayment updateMany
   */
  export type FactPaymentUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update FactPayments.
     */
    data: XOR<
      FactPaymentUpdateManyMutationInput,
      FactPaymentUncheckedUpdateManyInput
    >
    /**
     * Filter which FactPayments to update
     */
    where?: FactPaymentWhereInput
    /**
     * Limit how many FactPayments to update.
     */
    limit?: number
  }

  /**
   * FactPayment updateManyAndReturn
   */
  export type FactPaymentUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactPayment
     */
    select?: FactPaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FactPayment
     */
    omit?: FactPaymentOmit<ExtArgs> | null
    /**
     * The data used to update FactPayments.
     */
    data: XOR<
      FactPaymentUpdateManyMutationInput,
      FactPaymentUncheckedUpdateManyInput
    >
    /**
     * Filter which FactPayments to update
     */
    where?: FactPaymentWhereInput
    /**
     * Limit how many FactPayments to update.
     */
    limit?: number
  }

  /**
   * FactPayment upsert
   */
  export type FactPaymentUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactPayment
     */
    select?: FactPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactPayment
     */
    omit?: FactPaymentOmit<ExtArgs> | null
    /**
     * The filter to search for the FactPayment to update in case it exists.
     */
    where: FactPaymentWhereUniqueInput
    /**
     * In case the FactPayment found by the `where` argument doesn't exist, create a new FactPayment with this data.
     */
    create: XOR<FactPaymentCreateInput, FactPaymentUncheckedCreateInput>
    /**
     * In case the FactPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FactPaymentUpdateInput, FactPaymentUncheckedUpdateInput>
  }

  /**
   * FactPayment delete
   */
  export type FactPaymentDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactPayment
     */
    select?: FactPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactPayment
     */
    omit?: FactPaymentOmit<ExtArgs> | null
    /**
     * Filter which FactPayment to delete.
     */
    where: FactPaymentWhereUniqueInput
  }

  /**
   * FactPayment deleteMany
   */
  export type FactPaymentDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FactPayments to delete
     */
    where?: FactPaymentWhereInput
    /**
     * Limit how many FactPayments to delete.
     */
    limit?: number
  }

  /**
   * FactPayment without action
   */
  export type FactPaymentDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactPayment
     */
    select?: FactPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactPayment
     */
    omit?: FactPaymentOmit<ExtArgs> | null
  }

  /**
   * Model FactShipment
   */

  export type AggregateFactShipment = {
    _count: FactShipmentCountAggregateOutputType | null
    _avg: FactShipmentAvgAggregateOutputType | null
    _sum: FactShipmentSumAggregateOutputType | null
    _min: FactShipmentMinAggregateOutputType | null
    _max: FactShipmentMaxAggregateOutputType | null
  }

  export type FactShipmentAvgAggregateOutputType = {
    id: number | null
    shipmentId: number | null
    orderId: number | null
    dateId: number | null
    weight: number | null
    cost: Decimal | null
    deliveryDays: number | null
  }

  export type FactShipmentSumAggregateOutputType = {
    id: bigint | null
    shipmentId: bigint | null
    orderId: bigint | null
    dateId: number | null
    weight: number | null
    cost: Decimal | null
    deliveryDays: number | null
  }

  export type FactShipmentMinAggregateOutputType = {
    id: bigint | null
    shipmentId: bigint | null
    orderId: bigint | null
    dateId: number | null
    weight: number | null
    cost: Decimal | null
    carrier: string | null
    serviceLevel: string | null
    shippedTs: Date | null
    deliveredTs: Date | null
    deliveryDays: number | null
    isOnTime: boolean | null
    createdAt: Date | null
  }

  export type FactShipmentMaxAggregateOutputType = {
    id: bigint | null
    shipmentId: bigint | null
    orderId: bigint | null
    dateId: number | null
    weight: number | null
    cost: Decimal | null
    carrier: string | null
    serviceLevel: string | null
    shippedTs: Date | null
    deliveredTs: Date | null
    deliveryDays: number | null
    isOnTime: boolean | null
    createdAt: Date | null
  }

  export type FactShipmentCountAggregateOutputType = {
    id: number
    shipmentId: number
    orderId: number
    dateId: number
    weight: number
    cost: number
    carrier: number
    serviceLevel: number
    shippedTs: number
    deliveredTs: number
    deliveryDays: number
    isOnTime: number
    createdAt: number
    _all: number
  }

  export type FactShipmentAvgAggregateInputType = {
    id?: true
    shipmentId?: true
    orderId?: true
    dateId?: true
    weight?: true
    cost?: true
    deliveryDays?: true
  }

  export type FactShipmentSumAggregateInputType = {
    id?: true
    shipmentId?: true
    orderId?: true
    dateId?: true
    weight?: true
    cost?: true
    deliveryDays?: true
  }

  export type FactShipmentMinAggregateInputType = {
    id?: true
    shipmentId?: true
    orderId?: true
    dateId?: true
    weight?: true
    cost?: true
    carrier?: true
    serviceLevel?: true
    shippedTs?: true
    deliveredTs?: true
    deliveryDays?: true
    isOnTime?: true
    createdAt?: true
  }

  export type FactShipmentMaxAggregateInputType = {
    id?: true
    shipmentId?: true
    orderId?: true
    dateId?: true
    weight?: true
    cost?: true
    carrier?: true
    serviceLevel?: true
    shippedTs?: true
    deliveredTs?: true
    deliveryDays?: true
    isOnTime?: true
    createdAt?: true
  }

  export type FactShipmentCountAggregateInputType = {
    id?: true
    shipmentId?: true
    orderId?: true
    dateId?: true
    weight?: true
    cost?: true
    carrier?: true
    serviceLevel?: true
    shippedTs?: true
    deliveredTs?: true
    deliveryDays?: true
    isOnTime?: true
    createdAt?: true
    _all?: true
  }

  export type FactShipmentAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FactShipment to aggregate.
     */
    where?: FactShipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactShipments to fetch.
     */
    orderBy?:
      | FactShipmentOrderByWithRelationInput
      | FactShipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: FactShipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactShipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactShipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned FactShipments
     **/
    _count?: true | FactShipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: FactShipmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: FactShipmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FactShipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FactShipmentMaxAggregateInputType
  }

  export type GetFactShipmentAggregateType<
    T extends FactShipmentAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateFactShipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFactShipment[P]>
      : GetScalarType<T[P], AggregateFactShipment[P]>
  }

  export type FactShipmentGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FactShipmentWhereInput
    orderBy?:
      | FactShipmentOrderByWithAggregationInput
      | FactShipmentOrderByWithAggregationInput[]
    by: FactShipmentScalarFieldEnum[] | FactShipmentScalarFieldEnum
    having?: FactShipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FactShipmentCountAggregateInputType | true
    _avg?: FactShipmentAvgAggregateInputType
    _sum?: FactShipmentSumAggregateInputType
    _min?: FactShipmentMinAggregateInputType
    _max?: FactShipmentMaxAggregateInputType
  }

  export type FactShipmentGroupByOutputType = {
    id: bigint
    shipmentId: bigint
    orderId: bigint
    dateId: number
    weight: number | null
    cost: Decimal | null
    carrier: string
    serviceLevel: string | null
    shippedTs: Date | null
    deliveredTs: Date | null
    deliveryDays: number | null
    isOnTime: boolean | null
    createdAt: Date
    _count: FactShipmentCountAggregateOutputType | null
    _avg: FactShipmentAvgAggregateOutputType | null
    _sum: FactShipmentSumAggregateOutputType | null
    _min: FactShipmentMinAggregateOutputType | null
    _max: FactShipmentMaxAggregateOutputType | null
  }

  type GetFactShipmentGroupByPayload<T extends FactShipmentGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<FactShipmentGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof FactShipmentGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FactShipmentGroupByOutputType[P]>
            : GetScalarType<T[P], FactShipmentGroupByOutputType[P]>
        }
      >
    >

  export type FactShipmentSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      shipmentId?: boolean
      orderId?: boolean
      dateId?: boolean
      weight?: boolean
      cost?: boolean
      carrier?: boolean
      serviceLevel?: boolean
      shippedTs?: boolean
      deliveredTs?: boolean
      deliveryDays?: boolean
      isOnTime?: boolean
      createdAt?: boolean
    },
    ExtArgs['result']['factShipment']
  >

  export type FactShipmentSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      shipmentId?: boolean
      orderId?: boolean
      dateId?: boolean
      weight?: boolean
      cost?: boolean
      carrier?: boolean
      serviceLevel?: boolean
      shippedTs?: boolean
      deliveredTs?: boolean
      deliveryDays?: boolean
      isOnTime?: boolean
      createdAt?: boolean
    },
    ExtArgs['result']['factShipment']
  >

  export type FactShipmentSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      shipmentId?: boolean
      orderId?: boolean
      dateId?: boolean
      weight?: boolean
      cost?: boolean
      carrier?: boolean
      serviceLevel?: boolean
      shippedTs?: boolean
      deliveredTs?: boolean
      deliveryDays?: boolean
      isOnTime?: boolean
      createdAt?: boolean
    },
    ExtArgs['result']['factShipment']
  >

  export type FactShipmentSelectScalar = {
    id?: boolean
    shipmentId?: boolean
    orderId?: boolean
    dateId?: boolean
    weight?: boolean
    cost?: boolean
    carrier?: boolean
    serviceLevel?: boolean
    shippedTs?: boolean
    deliveredTs?: boolean
    deliveryDays?: boolean
    isOnTime?: boolean
    createdAt?: boolean
  }

  export type FactShipmentOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'shipmentId'
    | 'orderId'
    | 'dateId'
    | 'weight'
    | 'cost'
    | 'carrier'
    | 'serviceLevel'
    | 'shippedTs'
    | 'deliveredTs'
    | 'deliveryDays'
    | 'isOnTime'
    | 'createdAt',
    ExtArgs['result']['factShipment']
  >

  export type $FactShipmentPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'FactShipment'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        id: bigint
        shipmentId: bigint
        orderId: bigint
        dateId: number
        weight: number | null
        cost: Prisma.Decimal | null
        carrier: string
        serviceLevel: string | null
        shippedTs: Date | null
        deliveredTs: Date | null
        deliveryDays: number | null
        isOnTime: boolean | null
        createdAt: Date
      },
      ExtArgs['result']['factShipment']
    >
    composites: {}
  }

  type FactShipmentGetPayload<
    S extends boolean | null | undefined | FactShipmentDefaultArgs,
  > = $Result.GetResult<Prisma.$FactShipmentPayload, S>

  type FactShipmentCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    FactShipmentFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: FactShipmentCountAggregateInputType | true
  }

  export interface FactShipmentDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['FactShipment']
      meta: { name: 'FactShipment' }
    }
    /**
     * Find zero or one FactShipment that matches the filter.
     * @param {FactShipmentFindUniqueArgs} args - Arguments to find a FactShipment
     * @example
     * // Get one FactShipment
     * const factShipment = await prisma.factShipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FactShipmentFindUniqueArgs>(
      args: SelectSubset<T, FactShipmentFindUniqueArgs<ExtArgs>>
    ): Prisma__FactShipmentClient<
      $Result.GetResult<
        Prisma.$FactShipmentPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one FactShipment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FactShipmentFindUniqueOrThrowArgs} args - Arguments to find a FactShipment
     * @example
     * // Get one FactShipment
     * const factShipment = await prisma.factShipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FactShipmentFindUniqueOrThrowArgs>(
      args: SelectSubset<T, FactShipmentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FactShipmentClient<
      $Result.GetResult<
        Prisma.$FactShipmentPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first FactShipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactShipmentFindFirstArgs} args - Arguments to find a FactShipment
     * @example
     * // Get one FactShipment
     * const factShipment = await prisma.factShipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FactShipmentFindFirstArgs>(
      args?: SelectSubset<T, FactShipmentFindFirstArgs<ExtArgs>>
    ): Prisma__FactShipmentClient<
      $Result.GetResult<
        Prisma.$FactShipmentPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first FactShipment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactShipmentFindFirstOrThrowArgs} args - Arguments to find a FactShipment
     * @example
     * // Get one FactShipment
     * const factShipment = await prisma.factShipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FactShipmentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FactShipmentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FactShipmentClient<
      $Result.GetResult<
        Prisma.$FactShipmentPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more FactShipments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactShipmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FactShipments
     * const factShipments = await prisma.factShipment.findMany()
     *
     * // Get first 10 FactShipments
     * const factShipments = await prisma.factShipment.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const factShipmentWithIdOnly = await prisma.factShipment.findMany({ select: { id: true } })
     *
     */
    findMany<T extends FactShipmentFindManyArgs>(
      args?: SelectSubset<T, FactShipmentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FactShipmentPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a FactShipment.
     * @param {FactShipmentCreateArgs} args - Arguments to create a FactShipment.
     * @example
     * // Create one FactShipment
     * const FactShipment = await prisma.factShipment.create({
     *   data: {
     *     // ... data to create a FactShipment
     *   }
     * })
     *
     */
    create<T extends FactShipmentCreateArgs>(
      args: SelectSubset<T, FactShipmentCreateArgs<ExtArgs>>
    ): Prisma__FactShipmentClient<
      $Result.GetResult<
        Prisma.$FactShipmentPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many FactShipments.
     * @param {FactShipmentCreateManyArgs} args - Arguments to create many FactShipments.
     * @example
     * // Create many FactShipments
     * const factShipment = await prisma.factShipment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends FactShipmentCreateManyArgs>(
      args?: SelectSubset<T, FactShipmentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FactShipments and returns the data saved in the database.
     * @param {FactShipmentCreateManyAndReturnArgs} args - Arguments to create many FactShipments.
     * @example
     * // Create many FactShipments
     * const factShipment = await prisma.factShipment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many FactShipments and only return the `id`
     * const factShipmentWithIdOnly = await prisma.factShipment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends FactShipmentCreateManyAndReturnArgs>(
      args?: SelectSubset<T, FactShipmentCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FactShipmentPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Delete a FactShipment.
     * @param {FactShipmentDeleteArgs} args - Arguments to delete one FactShipment.
     * @example
     * // Delete one FactShipment
     * const FactShipment = await prisma.factShipment.delete({
     *   where: {
     *     // ... filter to delete one FactShipment
     *   }
     * })
     *
     */
    delete<T extends FactShipmentDeleteArgs>(
      args: SelectSubset<T, FactShipmentDeleteArgs<ExtArgs>>
    ): Prisma__FactShipmentClient<
      $Result.GetResult<
        Prisma.$FactShipmentPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one FactShipment.
     * @param {FactShipmentUpdateArgs} args - Arguments to update one FactShipment.
     * @example
     * // Update one FactShipment
     * const factShipment = await prisma.factShipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends FactShipmentUpdateArgs>(
      args: SelectSubset<T, FactShipmentUpdateArgs<ExtArgs>>
    ): Prisma__FactShipmentClient<
      $Result.GetResult<
        Prisma.$FactShipmentPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more FactShipments.
     * @param {FactShipmentDeleteManyArgs} args - Arguments to filter FactShipments to delete.
     * @example
     * // Delete a few FactShipments
     * const { count } = await prisma.factShipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends FactShipmentDeleteManyArgs>(
      args?: SelectSubset<T, FactShipmentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FactShipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactShipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FactShipments
     * const factShipment = await prisma.factShipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends FactShipmentUpdateManyArgs>(
      args: SelectSubset<T, FactShipmentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FactShipments and returns the data updated in the database.
     * @param {FactShipmentUpdateManyAndReturnArgs} args - Arguments to update many FactShipments.
     * @example
     * // Update many FactShipments
     * const factShipment = await prisma.factShipment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more FactShipments and only return the `id`
     * const factShipmentWithIdOnly = await prisma.factShipment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends FactShipmentUpdateManyAndReturnArgs>(
      args: SelectSubset<T, FactShipmentUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FactShipmentPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Create or update one FactShipment.
     * @param {FactShipmentUpsertArgs} args - Arguments to update or create a FactShipment.
     * @example
     * // Update or create a FactShipment
     * const factShipment = await prisma.factShipment.upsert({
     *   create: {
     *     // ... data to create a FactShipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FactShipment we want to update
     *   }
     * })
     */
    upsert<T extends FactShipmentUpsertArgs>(
      args: SelectSubset<T, FactShipmentUpsertArgs<ExtArgs>>
    ): Prisma__FactShipmentClient<
      $Result.GetResult<
        Prisma.$FactShipmentPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of FactShipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactShipmentCountArgs} args - Arguments to filter FactShipments to count.
     * @example
     * // Count the number of FactShipments
     * const count = await prisma.factShipment.count({
     *   where: {
     *     // ... the filter for the FactShipments we want to count
     *   }
     * })
     **/
    count<T extends FactShipmentCountArgs>(
      args?: Subset<T, FactShipmentCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FactShipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FactShipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactShipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FactShipmentAggregateArgs>(
      args: Subset<T, FactShipmentAggregateArgs>
    ): Prisma.PrismaPromise<GetFactShipmentAggregateType<T>>

    /**
     * Group by FactShipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactShipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends FactShipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FactShipmentGroupByArgs['orderBy'] }
        : { orderBy?: FactShipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ]
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, FactShipmentGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetFactShipmentGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the FactShipment model
     */
    readonly fields: FactShipmentFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for FactShipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FactShipmentClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the FactShipment model
   */
  interface FactShipmentFieldRefs {
    readonly id: FieldRef<'FactShipment', 'BigInt'>
    readonly shipmentId: FieldRef<'FactShipment', 'BigInt'>
    readonly orderId: FieldRef<'FactShipment', 'BigInt'>
    readonly dateId: FieldRef<'FactShipment', 'Int'>
    readonly weight: FieldRef<'FactShipment', 'Float'>
    readonly cost: FieldRef<'FactShipment', 'Decimal'>
    readonly carrier: FieldRef<'FactShipment', 'String'>
    readonly serviceLevel: FieldRef<'FactShipment', 'String'>
    readonly shippedTs: FieldRef<'FactShipment', 'DateTime'>
    readonly deliveredTs: FieldRef<'FactShipment', 'DateTime'>
    readonly deliveryDays: FieldRef<'FactShipment', 'Float'>
    readonly isOnTime: FieldRef<'FactShipment', 'Boolean'>
    readonly createdAt: FieldRef<'FactShipment', 'DateTime'>
  }

  // Custom InputTypes
  /**
   * FactShipment findUnique
   */
  export type FactShipmentFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactShipment
     */
    select?: FactShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactShipment
     */
    omit?: FactShipmentOmit<ExtArgs> | null
    /**
     * Filter, which FactShipment to fetch.
     */
    where: FactShipmentWhereUniqueInput
  }

  /**
   * FactShipment findUniqueOrThrow
   */
  export type FactShipmentFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactShipment
     */
    select?: FactShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactShipment
     */
    omit?: FactShipmentOmit<ExtArgs> | null
    /**
     * Filter, which FactShipment to fetch.
     */
    where: FactShipmentWhereUniqueInput
  }

  /**
   * FactShipment findFirst
   */
  export type FactShipmentFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactShipment
     */
    select?: FactShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactShipment
     */
    omit?: FactShipmentOmit<ExtArgs> | null
    /**
     * Filter, which FactShipment to fetch.
     */
    where?: FactShipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactShipments to fetch.
     */
    orderBy?:
      | FactShipmentOrderByWithRelationInput
      | FactShipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FactShipments.
     */
    cursor?: FactShipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactShipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactShipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FactShipments.
     */
    distinct?: FactShipmentScalarFieldEnum | FactShipmentScalarFieldEnum[]
  }

  /**
   * FactShipment findFirstOrThrow
   */
  export type FactShipmentFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactShipment
     */
    select?: FactShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactShipment
     */
    omit?: FactShipmentOmit<ExtArgs> | null
    /**
     * Filter, which FactShipment to fetch.
     */
    where?: FactShipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactShipments to fetch.
     */
    orderBy?:
      | FactShipmentOrderByWithRelationInput
      | FactShipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FactShipments.
     */
    cursor?: FactShipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactShipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactShipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FactShipments.
     */
    distinct?: FactShipmentScalarFieldEnum | FactShipmentScalarFieldEnum[]
  }

  /**
   * FactShipment findMany
   */
  export type FactShipmentFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactShipment
     */
    select?: FactShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactShipment
     */
    omit?: FactShipmentOmit<ExtArgs> | null
    /**
     * Filter, which FactShipments to fetch.
     */
    where?: FactShipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactShipments to fetch.
     */
    orderBy?:
      | FactShipmentOrderByWithRelationInput
      | FactShipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing FactShipments.
     */
    cursor?: FactShipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactShipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactShipments.
     */
    skip?: number
    distinct?: FactShipmentScalarFieldEnum | FactShipmentScalarFieldEnum[]
  }

  /**
   * FactShipment create
   */
  export type FactShipmentCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactShipment
     */
    select?: FactShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactShipment
     */
    omit?: FactShipmentOmit<ExtArgs> | null
    /**
     * The data needed to create a FactShipment.
     */
    data: XOR<FactShipmentCreateInput, FactShipmentUncheckedCreateInput>
  }

  /**
   * FactShipment createMany
   */
  export type FactShipmentCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many FactShipments.
     */
    data: FactShipmentCreateManyInput | FactShipmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FactShipment createManyAndReturn
   */
  export type FactShipmentCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactShipment
     */
    select?: FactShipmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FactShipment
     */
    omit?: FactShipmentOmit<ExtArgs> | null
    /**
     * The data used to create many FactShipments.
     */
    data: FactShipmentCreateManyInput | FactShipmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FactShipment update
   */
  export type FactShipmentUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactShipment
     */
    select?: FactShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactShipment
     */
    omit?: FactShipmentOmit<ExtArgs> | null
    /**
     * The data needed to update a FactShipment.
     */
    data: XOR<FactShipmentUpdateInput, FactShipmentUncheckedUpdateInput>
    /**
     * Choose, which FactShipment to update.
     */
    where: FactShipmentWhereUniqueInput
  }

  /**
   * FactShipment updateMany
   */
  export type FactShipmentUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update FactShipments.
     */
    data: XOR<
      FactShipmentUpdateManyMutationInput,
      FactShipmentUncheckedUpdateManyInput
    >
    /**
     * Filter which FactShipments to update
     */
    where?: FactShipmentWhereInput
    /**
     * Limit how many FactShipments to update.
     */
    limit?: number
  }

  /**
   * FactShipment updateManyAndReturn
   */
  export type FactShipmentUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactShipment
     */
    select?: FactShipmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FactShipment
     */
    omit?: FactShipmentOmit<ExtArgs> | null
    /**
     * The data used to update FactShipments.
     */
    data: XOR<
      FactShipmentUpdateManyMutationInput,
      FactShipmentUncheckedUpdateManyInput
    >
    /**
     * Filter which FactShipments to update
     */
    where?: FactShipmentWhereInput
    /**
     * Limit how many FactShipments to update.
     */
    limit?: number
  }

  /**
   * FactShipment upsert
   */
  export type FactShipmentUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactShipment
     */
    select?: FactShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactShipment
     */
    omit?: FactShipmentOmit<ExtArgs> | null
    /**
     * The filter to search for the FactShipment to update in case it exists.
     */
    where: FactShipmentWhereUniqueInput
    /**
     * In case the FactShipment found by the `where` argument doesn't exist, create a new FactShipment with this data.
     */
    create: XOR<FactShipmentCreateInput, FactShipmentUncheckedCreateInput>
    /**
     * In case the FactShipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FactShipmentUpdateInput, FactShipmentUncheckedUpdateInput>
  }

  /**
   * FactShipment delete
   */
  export type FactShipmentDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactShipment
     */
    select?: FactShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactShipment
     */
    omit?: FactShipmentOmit<ExtArgs> | null
    /**
     * Filter which FactShipment to delete.
     */
    where: FactShipmentWhereUniqueInput
  }

  /**
   * FactShipment deleteMany
   */
  export type FactShipmentDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FactShipments to delete
     */
    where?: FactShipmentWhereInput
    /**
     * Limit how many FactShipments to delete.
     */
    limit?: number
  }

  /**
   * FactShipment without action
   */
  export type FactShipmentDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactShipment
     */
    select?: FactShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactShipment
     */
    omit?: FactShipmentOmit<ExtArgs> | null
  }

  /**
   * Model FactSession
   */

  export type AggregateFactSession = {
    _count: FactSessionCountAggregateOutputType | null
    _avg: FactSessionAvgAggregateOutputType | null
    _sum: FactSessionSumAggregateOutputType | null
    _min: FactSessionMinAggregateOutputType | null
    _max: FactSessionMaxAggregateOutputType | null
  }

  export type FactSessionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    dateId: number | null
    durationSec: number | null
    pageViews: number | null
    eventsCount: number | null
    cartAddCount: number | null
    orderCount: number | null
  }

  export type FactSessionSumAggregateOutputType = {
    id: bigint | null
    userId: bigint | null
    dateId: number | null
    durationSec: number | null
    pageViews: number | null
    eventsCount: number | null
    cartAddCount: number | null
    orderCount: number | null
  }

  export type FactSessionMinAggregateOutputType = {
    id: bigint | null
    sessionId: string | null
    userId: bigint | null
    visitorId: string | null
    dateId: number | null
    startTime: Date | null
    endTime: Date | null
    durationSec: number | null
    pageViews: number | null
    eventsCount: number | null
    cartAddCount: number | null
    orderCount: number | null
    bounce: boolean | null
    source: string | null
    medium: string | null
    campaign: string | null
    deviceType: string | null
    browser: string | null
    os: string | null
    country: string | null
    city: string | null
  }

  export type FactSessionMaxAggregateOutputType = {
    id: bigint | null
    sessionId: string | null
    userId: bigint | null
    visitorId: string | null
    dateId: number | null
    startTime: Date | null
    endTime: Date | null
    durationSec: number | null
    pageViews: number | null
    eventsCount: number | null
    cartAddCount: number | null
    orderCount: number | null
    bounce: boolean | null
    source: string | null
    medium: string | null
    campaign: string | null
    deviceType: string | null
    browser: string | null
    os: string | null
    country: string | null
    city: string | null
  }

  export type FactSessionCountAggregateOutputType = {
    id: number
    sessionId: number
    userId: number
    visitorId: number
    dateId: number
    startTime: number
    endTime: number
    durationSec: number
    pageViews: number
    eventsCount: number
    cartAddCount: number
    orderCount: number
    bounce: number
    source: number
    medium: number
    campaign: number
    deviceType: number
    browser: number
    os: number
    country: number
    city: number
    _all: number
  }

  export type FactSessionAvgAggregateInputType = {
    id?: true
    userId?: true
    dateId?: true
    durationSec?: true
    pageViews?: true
    eventsCount?: true
    cartAddCount?: true
    orderCount?: true
  }

  export type FactSessionSumAggregateInputType = {
    id?: true
    userId?: true
    dateId?: true
    durationSec?: true
    pageViews?: true
    eventsCount?: true
    cartAddCount?: true
    orderCount?: true
  }

  export type FactSessionMinAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    visitorId?: true
    dateId?: true
    startTime?: true
    endTime?: true
    durationSec?: true
    pageViews?: true
    eventsCount?: true
    cartAddCount?: true
    orderCount?: true
    bounce?: true
    source?: true
    medium?: true
    campaign?: true
    deviceType?: true
    browser?: true
    os?: true
    country?: true
    city?: true
  }

  export type FactSessionMaxAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    visitorId?: true
    dateId?: true
    startTime?: true
    endTime?: true
    durationSec?: true
    pageViews?: true
    eventsCount?: true
    cartAddCount?: true
    orderCount?: true
    bounce?: true
    source?: true
    medium?: true
    campaign?: true
    deviceType?: true
    browser?: true
    os?: true
    country?: true
    city?: true
  }

  export type FactSessionCountAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    visitorId?: true
    dateId?: true
    startTime?: true
    endTime?: true
    durationSec?: true
    pageViews?: true
    eventsCount?: true
    cartAddCount?: true
    orderCount?: true
    bounce?: true
    source?: true
    medium?: true
    campaign?: true
    deviceType?: true
    browser?: true
    os?: true
    country?: true
    city?: true
    _all?: true
  }

  export type FactSessionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FactSession to aggregate.
     */
    where?: FactSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactSessions to fetch.
     */
    orderBy?:
      | FactSessionOrderByWithRelationInput
      | FactSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: FactSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned FactSessions
     **/
    _count?: true | FactSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: FactSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: FactSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FactSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FactSessionMaxAggregateInputType
  }

  export type GetFactSessionAggregateType<T extends FactSessionAggregateArgs> =
    {
      [P in keyof T & keyof AggregateFactSession]: P extends '_count' | 'count'
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregateFactSession[P]>
        : GetScalarType<T[P], AggregateFactSession[P]>
    }

  export type FactSessionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FactSessionWhereInput
    orderBy?:
      | FactSessionOrderByWithAggregationInput
      | FactSessionOrderByWithAggregationInput[]
    by: FactSessionScalarFieldEnum[] | FactSessionScalarFieldEnum
    having?: FactSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FactSessionCountAggregateInputType | true
    _avg?: FactSessionAvgAggregateInputType
    _sum?: FactSessionSumAggregateInputType
    _min?: FactSessionMinAggregateInputType
    _max?: FactSessionMaxAggregateInputType
  }

  export type FactSessionGroupByOutputType = {
    id: bigint
    sessionId: string
    userId: bigint | null
    visitorId: string | null
    dateId: number
    startTime: Date
    endTime: Date | null
    durationSec: number | null
    pageViews: number
    eventsCount: number
    cartAddCount: number
    orderCount: number
    bounce: boolean
    source: string | null
    medium: string | null
    campaign: string | null
    deviceType: string | null
    browser: string | null
    os: string | null
    country: string | null
    city: string | null
    _count: FactSessionCountAggregateOutputType | null
    _avg: FactSessionAvgAggregateOutputType | null
    _sum: FactSessionSumAggregateOutputType | null
    _min: FactSessionMinAggregateOutputType | null
    _max: FactSessionMaxAggregateOutputType | null
  }

  type GetFactSessionGroupByPayload<T extends FactSessionGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<FactSessionGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof FactSessionGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FactSessionGroupByOutputType[P]>
            : GetScalarType<T[P], FactSessionGroupByOutputType[P]>
        }
      >
    >

  export type FactSessionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      sessionId?: boolean
      userId?: boolean
      visitorId?: boolean
      dateId?: boolean
      startTime?: boolean
      endTime?: boolean
      durationSec?: boolean
      pageViews?: boolean
      eventsCount?: boolean
      cartAddCount?: boolean
      orderCount?: boolean
      bounce?: boolean
      source?: boolean
      medium?: boolean
      campaign?: boolean
      deviceType?: boolean
      browser?: boolean
      os?: boolean
      country?: boolean
      city?: boolean
    },
    ExtArgs['result']['factSession']
  >

  export type FactSessionSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      sessionId?: boolean
      userId?: boolean
      visitorId?: boolean
      dateId?: boolean
      startTime?: boolean
      endTime?: boolean
      durationSec?: boolean
      pageViews?: boolean
      eventsCount?: boolean
      cartAddCount?: boolean
      orderCount?: boolean
      bounce?: boolean
      source?: boolean
      medium?: boolean
      campaign?: boolean
      deviceType?: boolean
      browser?: boolean
      os?: boolean
      country?: boolean
      city?: boolean
    },
    ExtArgs['result']['factSession']
  >

  export type FactSessionSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      sessionId?: boolean
      userId?: boolean
      visitorId?: boolean
      dateId?: boolean
      startTime?: boolean
      endTime?: boolean
      durationSec?: boolean
      pageViews?: boolean
      eventsCount?: boolean
      cartAddCount?: boolean
      orderCount?: boolean
      bounce?: boolean
      source?: boolean
      medium?: boolean
      campaign?: boolean
      deviceType?: boolean
      browser?: boolean
      os?: boolean
      country?: boolean
      city?: boolean
    },
    ExtArgs['result']['factSession']
  >

  export type FactSessionSelectScalar = {
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    visitorId?: boolean
    dateId?: boolean
    startTime?: boolean
    endTime?: boolean
    durationSec?: boolean
    pageViews?: boolean
    eventsCount?: boolean
    cartAddCount?: boolean
    orderCount?: boolean
    bounce?: boolean
    source?: boolean
    medium?: boolean
    campaign?: boolean
    deviceType?: boolean
    browser?: boolean
    os?: boolean
    country?: boolean
    city?: boolean
  }

  export type FactSessionOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'sessionId'
    | 'userId'
    | 'visitorId'
    | 'dateId'
    | 'startTime'
    | 'endTime'
    | 'durationSec'
    | 'pageViews'
    | 'eventsCount'
    | 'cartAddCount'
    | 'orderCount'
    | 'bounce'
    | 'source'
    | 'medium'
    | 'campaign'
    | 'deviceType'
    | 'browser'
    | 'os'
    | 'country'
    | 'city',
    ExtArgs['result']['factSession']
  >

  export type $FactSessionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'FactSession'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        id: bigint
        sessionId: string
        userId: bigint | null
        visitorId: string | null
        dateId: number
        startTime: Date
        endTime: Date | null
        durationSec: number | null
        pageViews: number
        eventsCount: number
        cartAddCount: number
        orderCount: number
        bounce: boolean
        source: string | null
        medium: string | null
        campaign: string | null
        deviceType: string | null
        browser: string | null
        os: string | null
        country: string | null
        city: string | null
      },
      ExtArgs['result']['factSession']
    >
    composites: {}
  }

  type FactSessionGetPayload<
    S extends boolean | null | undefined | FactSessionDefaultArgs,
  > = $Result.GetResult<Prisma.$FactSessionPayload, S>

  type FactSessionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    FactSessionFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: FactSessionCountAggregateInputType | true
  }

  export interface FactSessionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['FactSession']
      meta: { name: 'FactSession' }
    }
    /**
     * Find zero or one FactSession that matches the filter.
     * @param {FactSessionFindUniqueArgs} args - Arguments to find a FactSession
     * @example
     * // Get one FactSession
     * const factSession = await prisma.factSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FactSessionFindUniqueArgs>(
      args: SelectSubset<T, FactSessionFindUniqueArgs<ExtArgs>>
    ): Prisma__FactSessionClient<
      $Result.GetResult<
        Prisma.$FactSessionPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one FactSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FactSessionFindUniqueOrThrowArgs} args - Arguments to find a FactSession
     * @example
     * // Get one FactSession
     * const factSession = await prisma.factSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FactSessionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, FactSessionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FactSessionClient<
      $Result.GetResult<
        Prisma.$FactSessionPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first FactSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactSessionFindFirstArgs} args - Arguments to find a FactSession
     * @example
     * // Get one FactSession
     * const factSession = await prisma.factSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FactSessionFindFirstArgs>(
      args?: SelectSubset<T, FactSessionFindFirstArgs<ExtArgs>>
    ): Prisma__FactSessionClient<
      $Result.GetResult<
        Prisma.$FactSessionPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first FactSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactSessionFindFirstOrThrowArgs} args - Arguments to find a FactSession
     * @example
     * // Get one FactSession
     * const factSession = await prisma.factSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FactSessionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FactSessionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FactSessionClient<
      $Result.GetResult<
        Prisma.$FactSessionPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more FactSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FactSessions
     * const factSessions = await prisma.factSession.findMany()
     *
     * // Get first 10 FactSessions
     * const factSessions = await prisma.factSession.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const factSessionWithIdOnly = await prisma.factSession.findMany({ select: { id: true } })
     *
     */
    findMany<T extends FactSessionFindManyArgs>(
      args?: SelectSubset<T, FactSessionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FactSessionPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a FactSession.
     * @param {FactSessionCreateArgs} args - Arguments to create a FactSession.
     * @example
     * // Create one FactSession
     * const FactSession = await prisma.factSession.create({
     *   data: {
     *     // ... data to create a FactSession
     *   }
     * })
     *
     */
    create<T extends FactSessionCreateArgs>(
      args: SelectSubset<T, FactSessionCreateArgs<ExtArgs>>
    ): Prisma__FactSessionClient<
      $Result.GetResult<
        Prisma.$FactSessionPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many FactSessions.
     * @param {FactSessionCreateManyArgs} args - Arguments to create many FactSessions.
     * @example
     * // Create many FactSessions
     * const factSession = await prisma.factSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends FactSessionCreateManyArgs>(
      args?: SelectSubset<T, FactSessionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FactSessions and returns the data saved in the database.
     * @param {FactSessionCreateManyAndReturnArgs} args - Arguments to create many FactSessions.
     * @example
     * // Create many FactSessions
     * const factSession = await prisma.factSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many FactSessions and only return the `id`
     * const factSessionWithIdOnly = await prisma.factSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends FactSessionCreateManyAndReturnArgs>(
      args?: SelectSubset<T, FactSessionCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FactSessionPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Delete a FactSession.
     * @param {FactSessionDeleteArgs} args - Arguments to delete one FactSession.
     * @example
     * // Delete one FactSession
     * const FactSession = await prisma.factSession.delete({
     *   where: {
     *     // ... filter to delete one FactSession
     *   }
     * })
     *
     */
    delete<T extends FactSessionDeleteArgs>(
      args: SelectSubset<T, FactSessionDeleteArgs<ExtArgs>>
    ): Prisma__FactSessionClient<
      $Result.GetResult<
        Prisma.$FactSessionPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one FactSession.
     * @param {FactSessionUpdateArgs} args - Arguments to update one FactSession.
     * @example
     * // Update one FactSession
     * const factSession = await prisma.factSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends FactSessionUpdateArgs>(
      args: SelectSubset<T, FactSessionUpdateArgs<ExtArgs>>
    ): Prisma__FactSessionClient<
      $Result.GetResult<
        Prisma.$FactSessionPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more FactSessions.
     * @param {FactSessionDeleteManyArgs} args - Arguments to filter FactSessions to delete.
     * @example
     * // Delete a few FactSessions
     * const { count } = await prisma.factSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends FactSessionDeleteManyArgs>(
      args?: SelectSubset<T, FactSessionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FactSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FactSessions
     * const factSession = await prisma.factSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends FactSessionUpdateManyArgs>(
      args: SelectSubset<T, FactSessionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FactSessions and returns the data updated in the database.
     * @param {FactSessionUpdateManyAndReturnArgs} args - Arguments to update many FactSessions.
     * @example
     * // Update many FactSessions
     * const factSession = await prisma.factSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more FactSessions and only return the `id`
     * const factSessionWithIdOnly = await prisma.factSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends FactSessionUpdateManyAndReturnArgs>(
      args: SelectSubset<T, FactSessionUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FactSessionPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Create or update one FactSession.
     * @param {FactSessionUpsertArgs} args - Arguments to update or create a FactSession.
     * @example
     * // Update or create a FactSession
     * const factSession = await prisma.factSession.upsert({
     *   create: {
     *     // ... data to create a FactSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FactSession we want to update
     *   }
     * })
     */
    upsert<T extends FactSessionUpsertArgs>(
      args: SelectSubset<T, FactSessionUpsertArgs<ExtArgs>>
    ): Prisma__FactSessionClient<
      $Result.GetResult<
        Prisma.$FactSessionPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of FactSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactSessionCountArgs} args - Arguments to filter FactSessions to count.
     * @example
     * // Count the number of FactSessions
     * const count = await prisma.factSession.count({
     *   where: {
     *     // ... the filter for the FactSessions we want to count
     *   }
     * })
     **/
    count<T extends FactSessionCountArgs>(
      args?: Subset<T, FactSessionCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FactSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FactSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FactSessionAggregateArgs>(
      args: Subset<T, FactSessionAggregateArgs>
    ): Prisma.PrismaPromise<GetFactSessionAggregateType<T>>

    /**
     * Group by FactSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends FactSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FactSessionGroupByArgs['orderBy'] }
        : { orderBy?: FactSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ]
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, FactSessionGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetFactSessionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the FactSession model
     */
    readonly fields: FactSessionFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for FactSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FactSessionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the FactSession model
   */
  interface FactSessionFieldRefs {
    readonly id: FieldRef<'FactSession', 'BigInt'>
    readonly sessionId: FieldRef<'FactSession', 'String'>
    readonly userId: FieldRef<'FactSession', 'BigInt'>
    readonly visitorId: FieldRef<'FactSession', 'String'>
    readonly dateId: FieldRef<'FactSession', 'Int'>
    readonly startTime: FieldRef<'FactSession', 'DateTime'>
    readonly endTime: FieldRef<'FactSession', 'DateTime'>
    readonly durationSec: FieldRef<'FactSession', 'Int'>
    readonly pageViews: FieldRef<'FactSession', 'Int'>
    readonly eventsCount: FieldRef<'FactSession', 'Int'>
    readonly cartAddCount: FieldRef<'FactSession', 'Int'>
    readonly orderCount: FieldRef<'FactSession', 'Int'>
    readonly bounce: FieldRef<'FactSession', 'Boolean'>
    readonly source: FieldRef<'FactSession', 'String'>
    readonly medium: FieldRef<'FactSession', 'String'>
    readonly campaign: FieldRef<'FactSession', 'String'>
    readonly deviceType: FieldRef<'FactSession', 'String'>
    readonly browser: FieldRef<'FactSession', 'String'>
    readonly os: FieldRef<'FactSession', 'String'>
    readonly country: FieldRef<'FactSession', 'String'>
    readonly city: FieldRef<'FactSession', 'String'>
  }

  // Custom InputTypes
  /**
   * FactSession findUnique
   */
  export type FactSessionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactSession
     */
    select?: FactSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactSession
     */
    omit?: FactSessionOmit<ExtArgs> | null
    /**
     * Filter, which FactSession to fetch.
     */
    where: FactSessionWhereUniqueInput
  }

  /**
   * FactSession findUniqueOrThrow
   */
  export type FactSessionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactSession
     */
    select?: FactSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactSession
     */
    omit?: FactSessionOmit<ExtArgs> | null
    /**
     * Filter, which FactSession to fetch.
     */
    where: FactSessionWhereUniqueInput
  }

  /**
   * FactSession findFirst
   */
  export type FactSessionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactSession
     */
    select?: FactSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactSession
     */
    omit?: FactSessionOmit<ExtArgs> | null
    /**
     * Filter, which FactSession to fetch.
     */
    where?: FactSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactSessions to fetch.
     */
    orderBy?:
      | FactSessionOrderByWithRelationInput
      | FactSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FactSessions.
     */
    cursor?: FactSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FactSessions.
     */
    distinct?: FactSessionScalarFieldEnum | FactSessionScalarFieldEnum[]
  }

  /**
   * FactSession findFirstOrThrow
   */
  export type FactSessionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactSession
     */
    select?: FactSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactSession
     */
    omit?: FactSessionOmit<ExtArgs> | null
    /**
     * Filter, which FactSession to fetch.
     */
    where?: FactSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactSessions to fetch.
     */
    orderBy?:
      | FactSessionOrderByWithRelationInput
      | FactSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FactSessions.
     */
    cursor?: FactSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FactSessions.
     */
    distinct?: FactSessionScalarFieldEnum | FactSessionScalarFieldEnum[]
  }

  /**
   * FactSession findMany
   */
  export type FactSessionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactSession
     */
    select?: FactSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactSession
     */
    omit?: FactSessionOmit<ExtArgs> | null
    /**
     * Filter, which FactSessions to fetch.
     */
    where?: FactSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactSessions to fetch.
     */
    orderBy?:
      | FactSessionOrderByWithRelationInput
      | FactSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing FactSessions.
     */
    cursor?: FactSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactSessions.
     */
    skip?: number
    distinct?: FactSessionScalarFieldEnum | FactSessionScalarFieldEnum[]
  }

  /**
   * FactSession create
   */
  export type FactSessionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactSession
     */
    select?: FactSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactSession
     */
    omit?: FactSessionOmit<ExtArgs> | null
    /**
     * The data needed to create a FactSession.
     */
    data: XOR<FactSessionCreateInput, FactSessionUncheckedCreateInput>
  }

  /**
   * FactSession createMany
   */
  export type FactSessionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many FactSessions.
     */
    data: FactSessionCreateManyInput | FactSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FactSession createManyAndReturn
   */
  export type FactSessionCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactSession
     */
    select?: FactSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FactSession
     */
    omit?: FactSessionOmit<ExtArgs> | null
    /**
     * The data used to create many FactSessions.
     */
    data: FactSessionCreateManyInput | FactSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FactSession update
   */
  export type FactSessionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactSession
     */
    select?: FactSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactSession
     */
    omit?: FactSessionOmit<ExtArgs> | null
    /**
     * The data needed to update a FactSession.
     */
    data: XOR<FactSessionUpdateInput, FactSessionUncheckedUpdateInput>
    /**
     * Choose, which FactSession to update.
     */
    where: FactSessionWhereUniqueInput
  }

  /**
   * FactSession updateMany
   */
  export type FactSessionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update FactSessions.
     */
    data: XOR<
      FactSessionUpdateManyMutationInput,
      FactSessionUncheckedUpdateManyInput
    >
    /**
     * Filter which FactSessions to update
     */
    where?: FactSessionWhereInput
    /**
     * Limit how many FactSessions to update.
     */
    limit?: number
  }

  /**
   * FactSession updateManyAndReturn
   */
  export type FactSessionUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactSession
     */
    select?: FactSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FactSession
     */
    omit?: FactSessionOmit<ExtArgs> | null
    /**
     * The data used to update FactSessions.
     */
    data: XOR<
      FactSessionUpdateManyMutationInput,
      FactSessionUncheckedUpdateManyInput
    >
    /**
     * Filter which FactSessions to update
     */
    where?: FactSessionWhereInput
    /**
     * Limit how many FactSessions to update.
     */
    limit?: number
  }

  /**
   * FactSession upsert
   */
  export type FactSessionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactSession
     */
    select?: FactSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactSession
     */
    omit?: FactSessionOmit<ExtArgs> | null
    /**
     * The filter to search for the FactSession to update in case it exists.
     */
    where: FactSessionWhereUniqueInput
    /**
     * In case the FactSession found by the `where` argument doesn't exist, create a new FactSession with this data.
     */
    create: XOR<FactSessionCreateInput, FactSessionUncheckedCreateInput>
    /**
     * In case the FactSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FactSessionUpdateInput, FactSessionUncheckedUpdateInput>
  }

  /**
   * FactSession delete
   */
  export type FactSessionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactSession
     */
    select?: FactSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactSession
     */
    omit?: FactSessionOmit<ExtArgs> | null
    /**
     * Filter which FactSession to delete.
     */
    where: FactSessionWhereUniqueInput
  }

  /**
   * FactSession deleteMany
   */
  export type FactSessionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FactSessions to delete
     */
    where?: FactSessionWhereInput
    /**
     * Limit how many FactSessions to delete.
     */
    limit?: number
  }

  /**
   * FactSession without action
   */
  export type FactSessionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactSession
     */
    select?: FactSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactSession
     */
    omit?: FactSessionOmit<ExtArgs> | null
  }

  /**
   * Model FactPageview
   */

  export type AggregateFactPageview = {
    _count: FactPageviewCountAggregateOutputType | null
    _avg: FactPageviewAvgAggregateOutputType | null
    _sum: FactPageviewSumAggregateOutputType | null
    _min: FactPageviewMinAggregateOutputType | null
    _max: FactPageviewMaxAggregateOutputType | null
  }

  export type FactPageviewAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    timeOnPageSec: number | null
    scrollDepth: number | null
    loadTimeMs: number | null
    productId: number | null
    categoryId: number | null
  }

  export type FactPageviewSumAggregateOutputType = {
    id: bigint | null
    userId: bigint | null
    timeOnPageSec: number | null
    scrollDepth: number | null
    loadTimeMs: number | null
    productId: bigint | null
    categoryId: number | null
  }

  export type FactPageviewMinAggregateOutputType = {
    id: bigint | null
    sessionId: string | null
    userId: bigint | null
    url: string | null
    path: string | null
    referrer: string | null
    timestamp: Date | null
    timeOnPageSec: number | null
    scrollDepth: number | null
    loadTimeMs: number | null
    productId: bigint | null
    categoryId: number | null
  }

  export type FactPageviewMaxAggregateOutputType = {
    id: bigint | null
    sessionId: string | null
    userId: bigint | null
    url: string | null
    path: string | null
    referrer: string | null
    timestamp: Date | null
    timeOnPageSec: number | null
    scrollDepth: number | null
    loadTimeMs: number | null
    productId: bigint | null
    categoryId: number | null
  }

  export type FactPageviewCountAggregateOutputType = {
    id: number
    sessionId: number
    userId: number
    url: number
    path: number
    referrer: number
    timestamp: number
    timeOnPageSec: number
    scrollDepth: number
    loadTimeMs: number
    productId: number
    categoryId: number
    _all: number
  }

  export type FactPageviewAvgAggregateInputType = {
    id?: true
    userId?: true
    timeOnPageSec?: true
    scrollDepth?: true
    loadTimeMs?: true
    productId?: true
    categoryId?: true
  }

  export type FactPageviewSumAggregateInputType = {
    id?: true
    userId?: true
    timeOnPageSec?: true
    scrollDepth?: true
    loadTimeMs?: true
    productId?: true
    categoryId?: true
  }

  export type FactPageviewMinAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    url?: true
    path?: true
    referrer?: true
    timestamp?: true
    timeOnPageSec?: true
    scrollDepth?: true
    loadTimeMs?: true
    productId?: true
    categoryId?: true
  }

  export type FactPageviewMaxAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    url?: true
    path?: true
    referrer?: true
    timestamp?: true
    timeOnPageSec?: true
    scrollDepth?: true
    loadTimeMs?: true
    productId?: true
    categoryId?: true
  }

  export type FactPageviewCountAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    url?: true
    path?: true
    referrer?: true
    timestamp?: true
    timeOnPageSec?: true
    scrollDepth?: true
    loadTimeMs?: true
    productId?: true
    categoryId?: true
    _all?: true
  }

  export type FactPageviewAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FactPageview to aggregate.
     */
    where?: FactPageviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactPageviews to fetch.
     */
    orderBy?:
      | FactPageviewOrderByWithRelationInput
      | FactPageviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: FactPageviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactPageviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactPageviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned FactPageviews
     **/
    _count?: true | FactPageviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: FactPageviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: FactPageviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FactPageviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FactPageviewMaxAggregateInputType
  }

  export type GetFactPageviewAggregateType<
    T extends FactPageviewAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateFactPageview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFactPageview[P]>
      : GetScalarType<T[P], AggregateFactPageview[P]>
  }

  export type FactPageviewGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FactPageviewWhereInput
    orderBy?:
      | FactPageviewOrderByWithAggregationInput
      | FactPageviewOrderByWithAggregationInput[]
    by: FactPageviewScalarFieldEnum[] | FactPageviewScalarFieldEnum
    having?: FactPageviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FactPageviewCountAggregateInputType | true
    _avg?: FactPageviewAvgAggregateInputType
    _sum?: FactPageviewSumAggregateInputType
    _min?: FactPageviewMinAggregateInputType
    _max?: FactPageviewMaxAggregateInputType
  }

  export type FactPageviewGroupByOutputType = {
    id: bigint
    sessionId: string
    userId: bigint | null
    url: string
    path: string
    referrer: string | null
    timestamp: Date
    timeOnPageSec: number | null
    scrollDepth: number | null
    loadTimeMs: number | null
    productId: bigint | null
    categoryId: number | null
    _count: FactPageviewCountAggregateOutputType | null
    _avg: FactPageviewAvgAggregateOutputType | null
    _sum: FactPageviewSumAggregateOutputType | null
    _min: FactPageviewMinAggregateOutputType | null
    _max: FactPageviewMaxAggregateOutputType | null
  }

  type GetFactPageviewGroupByPayload<T extends FactPageviewGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<FactPageviewGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof FactPageviewGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FactPageviewGroupByOutputType[P]>
            : GetScalarType<T[P], FactPageviewGroupByOutputType[P]>
        }
      >
    >

  export type FactPageviewSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      sessionId?: boolean
      userId?: boolean
      url?: boolean
      path?: boolean
      referrer?: boolean
      timestamp?: boolean
      timeOnPageSec?: boolean
      scrollDepth?: boolean
      loadTimeMs?: boolean
      productId?: boolean
      categoryId?: boolean
    },
    ExtArgs['result']['factPageview']
  >

  export type FactPageviewSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      sessionId?: boolean
      userId?: boolean
      url?: boolean
      path?: boolean
      referrer?: boolean
      timestamp?: boolean
      timeOnPageSec?: boolean
      scrollDepth?: boolean
      loadTimeMs?: boolean
      productId?: boolean
      categoryId?: boolean
    },
    ExtArgs['result']['factPageview']
  >

  export type FactPageviewSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      sessionId?: boolean
      userId?: boolean
      url?: boolean
      path?: boolean
      referrer?: boolean
      timestamp?: boolean
      timeOnPageSec?: boolean
      scrollDepth?: boolean
      loadTimeMs?: boolean
      productId?: boolean
      categoryId?: boolean
    },
    ExtArgs['result']['factPageview']
  >

  export type FactPageviewSelectScalar = {
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    url?: boolean
    path?: boolean
    referrer?: boolean
    timestamp?: boolean
    timeOnPageSec?: boolean
    scrollDepth?: boolean
    loadTimeMs?: boolean
    productId?: boolean
    categoryId?: boolean
  }

  export type FactPageviewOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'sessionId'
    | 'userId'
    | 'url'
    | 'path'
    | 'referrer'
    | 'timestamp'
    | 'timeOnPageSec'
    | 'scrollDepth'
    | 'loadTimeMs'
    | 'productId'
    | 'categoryId',
    ExtArgs['result']['factPageview']
  >

  export type $FactPageviewPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'FactPageview'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        id: bigint
        sessionId: string
        userId: bigint | null
        url: string
        path: string
        referrer: string | null
        timestamp: Date
        timeOnPageSec: number | null
        scrollDepth: number | null
        loadTimeMs: number | null
        productId: bigint | null
        categoryId: number | null
      },
      ExtArgs['result']['factPageview']
    >
    composites: {}
  }

  type FactPageviewGetPayload<
    S extends boolean | null | undefined | FactPageviewDefaultArgs,
  > = $Result.GetResult<Prisma.$FactPageviewPayload, S>

  type FactPageviewCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    FactPageviewFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: FactPageviewCountAggregateInputType | true
  }

  export interface FactPageviewDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['FactPageview']
      meta: { name: 'FactPageview' }
    }
    /**
     * Find zero or one FactPageview that matches the filter.
     * @param {FactPageviewFindUniqueArgs} args - Arguments to find a FactPageview
     * @example
     * // Get one FactPageview
     * const factPageview = await prisma.factPageview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FactPageviewFindUniqueArgs>(
      args: SelectSubset<T, FactPageviewFindUniqueArgs<ExtArgs>>
    ): Prisma__FactPageviewClient<
      $Result.GetResult<
        Prisma.$FactPageviewPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one FactPageview that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FactPageviewFindUniqueOrThrowArgs} args - Arguments to find a FactPageview
     * @example
     * // Get one FactPageview
     * const factPageview = await prisma.factPageview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FactPageviewFindUniqueOrThrowArgs>(
      args: SelectSubset<T, FactPageviewFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FactPageviewClient<
      $Result.GetResult<
        Prisma.$FactPageviewPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first FactPageview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactPageviewFindFirstArgs} args - Arguments to find a FactPageview
     * @example
     * // Get one FactPageview
     * const factPageview = await prisma.factPageview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FactPageviewFindFirstArgs>(
      args?: SelectSubset<T, FactPageviewFindFirstArgs<ExtArgs>>
    ): Prisma__FactPageviewClient<
      $Result.GetResult<
        Prisma.$FactPageviewPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first FactPageview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactPageviewFindFirstOrThrowArgs} args - Arguments to find a FactPageview
     * @example
     * // Get one FactPageview
     * const factPageview = await prisma.factPageview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FactPageviewFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FactPageviewFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FactPageviewClient<
      $Result.GetResult<
        Prisma.$FactPageviewPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more FactPageviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactPageviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FactPageviews
     * const factPageviews = await prisma.factPageview.findMany()
     *
     * // Get first 10 FactPageviews
     * const factPageviews = await prisma.factPageview.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const factPageviewWithIdOnly = await prisma.factPageview.findMany({ select: { id: true } })
     *
     */
    findMany<T extends FactPageviewFindManyArgs>(
      args?: SelectSubset<T, FactPageviewFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FactPageviewPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a FactPageview.
     * @param {FactPageviewCreateArgs} args - Arguments to create a FactPageview.
     * @example
     * // Create one FactPageview
     * const FactPageview = await prisma.factPageview.create({
     *   data: {
     *     // ... data to create a FactPageview
     *   }
     * })
     *
     */
    create<T extends FactPageviewCreateArgs>(
      args: SelectSubset<T, FactPageviewCreateArgs<ExtArgs>>
    ): Prisma__FactPageviewClient<
      $Result.GetResult<
        Prisma.$FactPageviewPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many FactPageviews.
     * @param {FactPageviewCreateManyArgs} args - Arguments to create many FactPageviews.
     * @example
     * // Create many FactPageviews
     * const factPageview = await prisma.factPageview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends FactPageviewCreateManyArgs>(
      args?: SelectSubset<T, FactPageviewCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FactPageviews and returns the data saved in the database.
     * @param {FactPageviewCreateManyAndReturnArgs} args - Arguments to create many FactPageviews.
     * @example
     * // Create many FactPageviews
     * const factPageview = await prisma.factPageview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many FactPageviews and only return the `id`
     * const factPageviewWithIdOnly = await prisma.factPageview.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends FactPageviewCreateManyAndReturnArgs>(
      args?: SelectSubset<T, FactPageviewCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FactPageviewPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Delete a FactPageview.
     * @param {FactPageviewDeleteArgs} args - Arguments to delete one FactPageview.
     * @example
     * // Delete one FactPageview
     * const FactPageview = await prisma.factPageview.delete({
     *   where: {
     *     // ... filter to delete one FactPageview
     *   }
     * })
     *
     */
    delete<T extends FactPageviewDeleteArgs>(
      args: SelectSubset<T, FactPageviewDeleteArgs<ExtArgs>>
    ): Prisma__FactPageviewClient<
      $Result.GetResult<
        Prisma.$FactPageviewPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one FactPageview.
     * @param {FactPageviewUpdateArgs} args - Arguments to update one FactPageview.
     * @example
     * // Update one FactPageview
     * const factPageview = await prisma.factPageview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends FactPageviewUpdateArgs>(
      args: SelectSubset<T, FactPageviewUpdateArgs<ExtArgs>>
    ): Prisma__FactPageviewClient<
      $Result.GetResult<
        Prisma.$FactPageviewPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more FactPageviews.
     * @param {FactPageviewDeleteManyArgs} args - Arguments to filter FactPageviews to delete.
     * @example
     * // Delete a few FactPageviews
     * const { count } = await prisma.factPageview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends FactPageviewDeleteManyArgs>(
      args?: SelectSubset<T, FactPageviewDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FactPageviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactPageviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FactPageviews
     * const factPageview = await prisma.factPageview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends FactPageviewUpdateManyArgs>(
      args: SelectSubset<T, FactPageviewUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FactPageviews and returns the data updated in the database.
     * @param {FactPageviewUpdateManyAndReturnArgs} args - Arguments to update many FactPageviews.
     * @example
     * // Update many FactPageviews
     * const factPageview = await prisma.factPageview.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more FactPageviews and only return the `id`
     * const factPageviewWithIdOnly = await prisma.factPageview.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends FactPageviewUpdateManyAndReturnArgs>(
      args: SelectSubset<T, FactPageviewUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FactPageviewPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Create or update one FactPageview.
     * @param {FactPageviewUpsertArgs} args - Arguments to update or create a FactPageview.
     * @example
     * // Update or create a FactPageview
     * const factPageview = await prisma.factPageview.upsert({
     *   create: {
     *     // ... data to create a FactPageview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FactPageview we want to update
     *   }
     * })
     */
    upsert<T extends FactPageviewUpsertArgs>(
      args: SelectSubset<T, FactPageviewUpsertArgs<ExtArgs>>
    ): Prisma__FactPageviewClient<
      $Result.GetResult<
        Prisma.$FactPageviewPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of FactPageviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactPageviewCountArgs} args - Arguments to filter FactPageviews to count.
     * @example
     * // Count the number of FactPageviews
     * const count = await prisma.factPageview.count({
     *   where: {
     *     // ... the filter for the FactPageviews we want to count
     *   }
     * })
     **/
    count<T extends FactPageviewCountArgs>(
      args?: Subset<T, FactPageviewCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FactPageviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FactPageview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactPageviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FactPageviewAggregateArgs>(
      args: Subset<T, FactPageviewAggregateArgs>
    ): Prisma.PrismaPromise<GetFactPageviewAggregateType<T>>

    /**
     * Group by FactPageview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactPageviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends FactPageviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FactPageviewGroupByArgs['orderBy'] }
        : { orderBy?: FactPageviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ]
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, FactPageviewGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetFactPageviewGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the FactPageview model
     */
    readonly fields: FactPageviewFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for FactPageview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FactPageviewClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the FactPageview model
   */
  interface FactPageviewFieldRefs {
    readonly id: FieldRef<'FactPageview', 'BigInt'>
    readonly sessionId: FieldRef<'FactPageview', 'String'>
    readonly userId: FieldRef<'FactPageview', 'BigInt'>
    readonly url: FieldRef<'FactPageview', 'String'>
    readonly path: FieldRef<'FactPageview', 'String'>
    readonly referrer: FieldRef<'FactPageview', 'String'>
    readonly timestamp: FieldRef<'FactPageview', 'DateTime'>
    readonly timeOnPageSec: FieldRef<'FactPageview', 'Int'>
    readonly scrollDepth: FieldRef<'FactPageview', 'Int'>
    readonly loadTimeMs: FieldRef<'FactPageview', 'Int'>
    readonly productId: FieldRef<'FactPageview', 'BigInt'>
    readonly categoryId: FieldRef<'FactPageview', 'Int'>
  }

  // Custom InputTypes
  /**
   * FactPageview findUnique
   */
  export type FactPageviewFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactPageview
     */
    select?: FactPageviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactPageview
     */
    omit?: FactPageviewOmit<ExtArgs> | null
    /**
     * Filter, which FactPageview to fetch.
     */
    where: FactPageviewWhereUniqueInput
  }

  /**
   * FactPageview findUniqueOrThrow
   */
  export type FactPageviewFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactPageview
     */
    select?: FactPageviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactPageview
     */
    omit?: FactPageviewOmit<ExtArgs> | null
    /**
     * Filter, which FactPageview to fetch.
     */
    where: FactPageviewWhereUniqueInput
  }

  /**
   * FactPageview findFirst
   */
  export type FactPageviewFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactPageview
     */
    select?: FactPageviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactPageview
     */
    omit?: FactPageviewOmit<ExtArgs> | null
    /**
     * Filter, which FactPageview to fetch.
     */
    where?: FactPageviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactPageviews to fetch.
     */
    orderBy?:
      | FactPageviewOrderByWithRelationInput
      | FactPageviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FactPageviews.
     */
    cursor?: FactPageviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactPageviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactPageviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FactPageviews.
     */
    distinct?: FactPageviewScalarFieldEnum | FactPageviewScalarFieldEnum[]
  }

  /**
   * FactPageview findFirstOrThrow
   */
  export type FactPageviewFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactPageview
     */
    select?: FactPageviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactPageview
     */
    omit?: FactPageviewOmit<ExtArgs> | null
    /**
     * Filter, which FactPageview to fetch.
     */
    where?: FactPageviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactPageviews to fetch.
     */
    orderBy?:
      | FactPageviewOrderByWithRelationInput
      | FactPageviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FactPageviews.
     */
    cursor?: FactPageviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactPageviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactPageviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FactPageviews.
     */
    distinct?: FactPageviewScalarFieldEnum | FactPageviewScalarFieldEnum[]
  }

  /**
   * FactPageview findMany
   */
  export type FactPageviewFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactPageview
     */
    select?: FactPageviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactPageview
     */
    omit?: FactPageviewOmit<ExtArgs> | null
    /**
     * Filter, which FactPageviews to fetch.
     */
    where?: FactPageviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactPageviews to fetch.
     */
    orderBy?:
      | FactPageviewOrderByWithRelationInput
      | FactPageviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing FactPageviews.
     */
    cursor?: FactPageviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactPageviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactPageviews.
     */
    skip?: number
    distinct?: FactPageviewScalarFieldEnum | FactPageviewScalarFieldEnum[]
  }

  /**
   * FactPageview create
   */
  export type FactPageviewCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactPageview
     */
    select?: FactPageviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactPageview
     */
    omit?: FactPageviewOmit<ExtArgs> | null
    /**
     * The data needed to create a FactPageview.
     */
    data: XOR<FactPageviewCreateInput, FactPageviewUncheckedCreateInput>
  }

  /**
   * FactPageview createMany
   */
  export type FactPageviewCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many FactPageviews.
     */
    data: FactPageviewCreateManyInput | FactPageviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FactPageview createManyAndReturn
   */
  export type FactPageviewCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactPageview
     */
    select?: FactPageviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FactPageview
     */
    omit?: FactPageviewOmit<ExtArgs> | null
    /**
     * The data used to create many FactPageviews.
     */
    data: FactPageviewCreateManyInput | FactPageviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FactPageview update
   */
  export type FactPageviewUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactPageview
     */
    select?: FactPageviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactPageview
     */
    omit?: FactPageviewOmit<ExtArgs> | null
    /**
     * The data needed to update a FactPageview.
     */
    data: XOR<FactPageviewUpdateInput, FactPageviewUncheckedUpdateInput>
    /**
     * Choose, which FactPageview to update.
     */
    where: FactPageviewWhereUniqueInput
  }

  /**
   * FactPageview updateMany
   */
  export type FactPageviewUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update FactPageviews.
     */
    data: XOR<
      FactPageviewUpdateManyMutationInput,
      FactPageviewUncheckedUpdateManyInput
    >
    /**
     * Filter which FactPageviews to update
     */
    where?: FactPageviewWhereInput
    /**
     * Limit how many FactPageviews to update.
     */
    limit?: number
  }

  /**
   * FactPageview updateManyAndReturn
   */
  export type FactPageviewUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactPageview
     */
    select?: FactPageviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FactPageview
     */
    omit?: FactPageviewOmit<ExtArgs> | null
    /**
     * The data used to update FactPageviews.
     */
    data: XOR<
      FactPageviewUpdateManyMutationInput,
      FactPageviewUncheckedUpdateManyInput
    >
    /**
     * Filter which FactPageviews to update
     */
    where?: FactPageviewWhereInput
    /**
     * Limit how many FactPageviews to update.
     */
    limit?: number
  }

  /**
   * FactPageview upsert
   */
  export type FactPageviewUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactPageview
     */
    select?: FactPageviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactPageview
     */
    omit?: FactPageviewOmit<ExtArgs> | null
    /**
     * The filter to search for the FactPageview to update in case it exists.
     */
    where: FactPageviewWhereUniqueInput
    /**
     * In case the FactPageview found by the `where` argument doesn't exist, create a new FactPageview with this data.
     */
    create: XOR<FactPageviewCreateInput, FactPageviewUncheckedCreateInput>
    /**
     * In case the FactPageview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FactPageviewUpdateInput, FactPageviewUncheckedUpdateInput>
  }

  /**
   * FactPageview delete
   */
  export type FactPageviewDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactPageview
     */
    select?: FactPageviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactPageview
     */
    omit?: FactPageviewOmit<ExtArgs> | null
    /**
     * Filter which FactPageview to delete.
     */
    where: FactPageviewWhereUniqueInput
  }

  /**
   * FactPageview deleteMany
   */
  export type FactPageviewDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FactPageviews to delete
     */
    where?: FactPageviewWhereInput
    /**
     * Limit how many FactPageviews to delete.
     */
    limit?: number
  }

  /**
   * FactPageview without action
   */
  export type FactPageviewDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactPageview
     */
    select?: FactPageviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactPageview
     */
    omit?: FactPageviewOmit<ExtArgs> | null
  }

  /**
   * Model FactSearch
   */

  export type AggregateFactSearch = {
    _count: FactSearchCountAggregateOutputType | null
    _avg: FactSearchAvgAggregateOutputType | null
    _sum: FactSearchSumAggregateOutputType | null
    _min: FactSearchMinAggregateOutputType | null
    _max: FactSearchMaxAggregateOutputType | null
  }

  export type FactSearchAvgAggregateOutputType = {
    id: number | null
    resultCount: number | null
    clickedResultPos: number | null
  }

  export type FactSearchSumAggregateOutputType = {
    id: bigint | null
    resultCount: number | null
    clickedResultPos: number | null
  }

  export type FactSearchMinAggregateOutputType = {
    id: bigint | null
    sessionId: string | null
    timestamp: Date | null
    query: string | null
    resultCount: number | null
    clickedResultPos: number | null
    converted: boolean | null
  }

  export type FactSearchMaxAggregateOutputType = {
    id: bigint | null
    sessionId: string | null
    timestamp: Date | null
    query: string | null
    resultCount: number | null
    clickedResultPos: number | null
    converted: boolean | null
  }

  export type FactSearchCountAggregateOutputType = {
    id: number
    sessionId: number
    timestamp: number
    query: number
    resultCount: number
    clickedResultPos: number
    converted: number
    _all: number
  }

  export type FactSearchAvgAggregateInputType = {
    id?: true
    resultCount?: true
    clickedResultPos?: true
  }

  export type FactSearchSumAggregateInputType = {
    id?: true
    resultCount?: true
    clickedResultPos?: true
  }

  export type FactSearchMinAggregateInputType = {
    id?: true
    sessionId?: true
    timestamp?: true
    query?: true
    resultCount?: true
    clickedResultPos?: true
    converted?: true
  }

  export type FactSearchMaxAggregateInputType = {
    id?: true
    sessionId?: true
    timestamp?: true
    query?: true
    resultCount?: true
    clickedResultPos?: true
    converted?: true
  }

  export type FactSearchCountAggregateInputType = {
    id?: true
    sessionId?: true
    timestamp?: true
    query?: true
    resultCount?: true
    clickedResultPos?: true
    converted?: true
    _all?: true
  }

  export type FactSearchAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FactSearch to aggregate.
     */
    where?: FactSearchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactSearches to fetch.
     */
    orderBy?:
      | FactSearchOrderByWithRelationInput
      | FactSearchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: FactSearchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactSearches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactSearches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned FactSearches
     **/
    _count?: true | FactSearchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: FactSearchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: FactSearchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FactSearchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FactSearchMaxAggregateInputType
  }

  export type GetFactSearchAggregateType<T extends FactSearchAggregateArgs> = {
    [P in keyof T & keyof AggregateFactSearch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFactSearch[P]>
      : GetScalarType<T[P], AggregateFactSearch[P]>
  }

  export type FactSearchGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FactSearchWhereInput
    orderBy?:
      | FactSearchOrderByWithAggregationInput
      | FactSearchOrderByWithAggregationInput[]
    by: FactSearchScalarFieldEnum[] | FactSearchScalarFieldEnum
    having?: FactSearchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FactSearchCountAggregateInputType | true
    _avg?: FactSearchAvgAggregateInputType
    _sum?: FactSearchSumAggregateInputType
    _min?: FactSearchMinAggregateInputType
    _max?: FactSearchMaxAggregateInputType
  }

  export type FactSearchGroupByOutputType = {
    id: bigint
    sessionId: string
    timestamp: Date
    query: string
    resultCount: number
    clickedResultPos: number | null
    converted: boolean
    _count: FactSearchCountAggregateOutputType | null
    _avg: FactSearchAvgAggregateOutputType | null
    _sum: FactSearchSumAggregateOutputType | null
    _min: FactSearchMinAggregateOutputType | null
    _max: FactSearchMaxAggregateOutputType | null
  }

  type GetFactSearchGroupByPayload<T extends FactSearchGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<FactSearchGroupByOutputType, T['by']> & {
          [P in keyof T & keyof FactSearchGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FactSearchGroupByOutputType[P]>
            : GetScalarType<T[P], FactSearchGroupByOutputType[P]>
        }
      >
    >

  export type FactSearchSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      sessionId?: boolean
      timestamp?: boolean
      query?: boolean
      resultCount?: boolean
      clickedResultPos?: boolean
      converted?: boolean
    },
    ExtArgs['result']['factSearch']
  >

  export type FactSearchSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      sessionId?: boolean
      timestamp?: boolean
      query?: boolean
      resultCount?: boolean
      clickedResultPos?: boolean
      converted?: boolean
    },
    ExtArgs['result']['factSearch']
  >

  export type FactSearchSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      sessionId?: boolean
      timestamp?: boolean
      query?: boolean
      resultCount?: boolean
      clickedResultPos?: boolean
      converted?: boolean
    },
    ExtArgs['result']['factSearch']
  >

  export type FactSearchSelectScalar = {
    id?: boolean
    sessionId?: boolean
    timestamp?: boolean
    query?: boolean
    resultCount?: boolean
    clickedResultPos?: boolean
    converted?: boolean
  }

  export type FactSearchOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'sessionId'
    | 'timestamp'
    | 'query'
    | 'resultCount'
    | 'clickedResultPos'
    | 'converted',
    ExtArgs['result']['factSearch']
  >

  export type $FactSearchPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'FactSearch'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        id: bigint
        sessionId: string
        timestamp: Date
        query: string
        resultCount: number
        clickedResultPos: number | null
        converted: boolean
      },
      ExtArgs['result']['factSearch']
    >
    composites: {}
  }

  type FactSearchGetPayload<
    S extends boolean | null | undefined | FactSearchDefaultArgs,
  > = $Result.GetResult<Prisma.$FactSearchPayload, S>

  type FactSearchCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    FactSearchFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: FactSearchCountAggregateInputType | true
  }

  export interface FactSearchDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['FactSearch']
      meta: { name: 'FactSearch' }
    }
    /**
     * Find zero or one FactSearch that matches the filter.
     * @param {FactSearchFindUniqueArgs} args - Arguments to find a FactSearch
     * @example
     * // Get one FactSearch
     * const factSearch = await prisma.factSearch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FactSearchFindUniqueArgs>(
      args: SelectSubset<T, FactSearchFindUniqueArgs<ExtArgs>>
    ): Prisma__FactSearchClient<
      $Result.GetResult<
        Prisma.$FactSearchPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one FactSearch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FactSearchFindUniqueOrThrowArgs} args - Arguments to find a FactSearch
     * @example
     * // Get one FactSearch
     * const factSearch = await prisma.factSearch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FactSearchFindUniqueOrThrowArgs>(
      args: SelectSubset<T, FactSearchFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FactSearchClient<
      $Result.GetResult<
        Prisma.$FactSearchPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first FactSearch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactSearchFindFirstArgs} args - Arguments to find a FactSearch
     * @example
     * // Get one FactSearch
     * const factSearch = await prisma.factSearch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FactSearchFindFirstArgs>(
      args?: SelectSubset<T, FactSearchFindFirstArgs<ExtArgs>>
    ): Prisma__FactSearchClient<
      $Result.GetResult<
        Prisma.$FactSearchPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first FactSearch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactSearchFindFirstOrThrowArgs} args - Arguments to find a FactSearch
     * @example
     * // Get one FactSearch
     * const factSearch = await prisma.factSearch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FactSearchFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FactSearchFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FactSearchClient<
      $Result.GetResult<
        Prisma.$FactSearchPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more FactSearches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactSearchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FactSearches
     * const factSearches = await prisma.factSearch.findMany()
     *
     * // Get first 10 FactSearches
     * const factSearches = await prisma.factSearch.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const factSearchWithIdOnly = await prisma.factSearch.findMany({ select: { id: true } })
     *
     */
    findMany<T extends FactSearchFindManyArgs>(
      args?: SelectSubset<T, FactSearchFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FactSearchPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a FactSearch.
     * @param {FactSearchCreateArgs} args - Arguments to create a FactSearch.
     * @example
     * // Create one FactSearch
     * const FactSearch = await prisma.factSearch.create({
     *   data: {
     *     // ... data to create a FactSearch
     *   }
     * })
     *
     */
    create<T extends FactSearchCreateArgs>(
      args: SelectSubset<T, FactSearchCreateArgs<ExtArgs>>
    ): Prisma__FactSearchClient<
      $Result.GetResult<
        Prisma.$FactSearchPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many FactSearches.
     * @param {FactSearchCreateManyArgs} args - Arguments to create many FactSearches.
     * @example
     * // Create many FactSearches
     * const factSearch = await prisma.factSearch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends FactSearchCreateManyArgs>(
      args?: SelectSubset<T, FactSearchCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FactSearches and returns the data saved in the database.
     * @param {FactSearchCreateManyAndReturnArgs} args - Arguments to create many FactSearches.
     * @example
     * // Create many FactSearches
     * const factSearch = await prisma.factSearch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many FactSearches and only return the `id`
     * const factSearchWithIdOnly = await prisma.factSearch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends FactSearchCreateManyAndReturnArgs>(
      args?: SelectSubset<T, FactSearchCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FactSearchPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Delete a FactSearch.
     * @param {FactSearchDeleteArgs} args - Arguments to delete one FactSearch.
     * @example
     * // Delete one FactSearch
     * const FactSearch = await prisma.factSearch.delete({
     *   where: {
     *     // ... filter to delete one FactSearch
     *   }
     * })
     *
     */
    delete<T extends FactSearchDeleteArgs>(
      args: SelectSubset<T, FactSearchDeleteArgs<ExtArgs>>
    ): Prisma__FactSearchClient<
      $Result.GetResult<
        Prisma.$FactSearchPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one FactSearch.
     * @param {FactSearchUpdateArgs} args - Arguments to update one FactSearch.
     * @example
     * // Update one FactSearch
     * const factSearch = await prisma.factSearch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends FactSearchUpdateArgs>(
      args: SelectSubset<T, FactSearchUpdateArgs<ExtArgs>>
    ): Prisma__FactSearchClient<
      $Result.GetResult<
        Prisma.$FactSearchPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more FactSearches.
     * @param {FactSearchDeleteManyArgs} args - Arguments to filter FactSearches to delete.
     * @example
     * // Delete a few FactSearches
     * const { count } = await prisma.factSearch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends FactSearchDeleteManyArgs>(
      args?: SelectSubset<T, FactSearchDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FactSearches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactSearchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FactSearches
     * const factSearch = await prisma.factSearch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends FactSearchUpdateManyArgs>(
      args: SelectSubset<T, FactSearchUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FactSearches and returns the data updated in the database.
     * @param {FactSearchUpdateManyAndReturnArgs} args - Arguments to update many FactSearches.
     * @example
     * // Update many FactSearches
     * const factSearch = await prisma.factSearch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more FactSearches and only return the `id`
     * const factSearchWithIdOnly = await prisma.factSearch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends FactSearchUpdateManyAndReturnArgs>(
      args: SelectSubset<T, FactSearchUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FactSearchPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Create or update one FactSearch.
     * @param {FactSearchUpsertArgs} args - Arguments to update or create a FactSearch.
     * @example
     * // Update or create a FactSearch
     * const factSearch = await prisma.factSearch.upsert({
     *   create: {
     *     // ... data to create a FactSearch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FactSearch we want to update
     *   }
     * })
     */
    upsert<T extends FactSearchUpsertArgs>(
      args: SelectSubset<T, FactSearchUpsertArgs<ExtArgs>>
    ): Prisma__FactSearchClient<
      $Result.GetResult<
        Prisma.$FactSearchPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of FactSearches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactSearchCountArgs} args - Arguments to filter FactSearches to count.
     * @example
     * // Count the number of FactSearches
     * const count = await prisma.factSearch.count({
     *   where: {
     *     // ... the filter for the FactSearches we want to count
     *   }
     * })
     **/
    count<T extends FactSearchCountArgs>(
      args?: Subset<T, FactSearchCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FactSearchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FactSearch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactSearchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FactSearchAggregateArgs>(
      args: Subset<T, FactSearchAggregateArgs>
    ): Prisma.PrismaPromise<GetFactSearchAggregateType<T>>

    /**
     * Group by FactSearch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactSearchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends FactSearchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FactSearchGroupByArgs['orderBy'] }
        : { orderBy?: FactSearchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ]
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, FactSearchGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetFactSearchGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the FactSearch model
     */
    readonly fields: FactSearchFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for FactSearch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FactSearchClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the FactSearch model
   */
  interface FactSearchFieldRefs {
    readonly id: FieldRef<'FactSearch', 'BigInt'>
    readonly sessionId: FieldRef<'FactSearch', 'String'>
    readonly timestamp: FieldRef<'FactSearch', 'DateTime'>
    readonly query: FieldRef<'FactSearch', 'String'>
    readonly resultCount: FieldRef<'FactSearch', 'Int'>
    readonly clickedResultPos: FieldRef<'FactSearch', 'Int'>
    readonly converted: FieldRef<'FactSearch', 'Boolean'>
  }

  // Custom InputTypes
  /**
   * FactSearch findUnique
   */
  export type FactSearchFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactSearch
     */
    select?: FactSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactSearch
     */
    omit?: FactSearchOmit<ExtArgs> | null
    /**
     * Filter, which FactSearch to fetch.
     */
    where: FactSearchWhereUniqueInput
  }

  /**
   * FactSearch findUniqueOrThrow
   */
  export type FactSearchFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactSearch
     */
    select?: FactSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactSearch
     */
    omit?: FactSearchOmit<ExtArgs> | null
    /**
     * Filter, which FactSearch to fetch.
     */
    where: FactSearchWhereUniqueInput
  }

  /**
   * FactSearch findFirst
   */
  export type FactSearchFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactSearch
     */
    select?: FactSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactSearch
     */
    omit?: FactSearchOmit<ExtArgs> | null
    /**
     * Filter, which FactSearch to fetch.
     */
    where?: FactSearchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactSearches to fetch.
     */
    orderBy?:
      | FactSearchOrderByWithRelationInput
      | FactSearchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FactSearches.
     */
    cursor?: FactSearchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactSearches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactSearches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FactSearches.
     */
    distinct?: FactSearchScalarFieldEnum | FactSearchScalarFieldEnum[]
  }

  /**
   * FactSearch findFirstOrThrow
   */
  export type FactSearchFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactSearch
     */
    select?: FactSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactSearch
     */
    omit?: FactSearchOmit<ExtArgs> | null
    /**
     * Filter, which FactSearch to fetch.
     */
    where?: FactSearchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactSearches to fetch.
     */
    orderBy?:
      | FactSearchOrderByWithRelationInput
      | FactSearchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FactSearches.
     */
    cursor?: FactSearchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactSearches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactSearches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FactSearches.
     */
    distinct?: FactSearchScalarFieldEnum | FactSearchScalarFieldEnum[]
  }

  /**
   * FactSearch findMany
   */
  export type FactSearchFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactSearch
     */
    select?: FactSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactSearch
     */
    omit?: FactSearchOmit<ExtArgs> | null
    /**
     * Filter, which FactSearches to fetch.
     */
    where?: FactSearchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactSearches to fetch.
     */
    orderBy?:
      | FactSearchOrderByWithRelationInput
      | FactSearchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing FactSearches.
     */
    cursor?: FactSearchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactSearches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactSearches.
     */
    skip?: number
    distinct?: FactSearchScalarFieldEnum | FactSearchScalarFieldEnum[]
  }

  /**
   * FactSearch create
   */
  export type FactSearchCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactSearch
     */
    select?: FactSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactSearch
     */
    omit?: FactSearchOmit<ExtArgs> | null
    /**
     * The data needed to create a FactSearch.
     */
    data: XOR<FactSearchCreateInput, FactSearchUncheckedCreateInput>
  }

  /**
   * FactSearch createMany
   */
  export type FactSearchCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many FactSearches.
     */
    data: FactSearchCreateManyInput | FactSearchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FactSearch createManyAndReturn
   */
  export type FactSearchCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactSearch
     */
    select?: FactSearchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FactSearch
     */
    omit?: FactSearchOmit<ExtArgs> | null
    /**
     * The data used to create many FactSearches.
     */
    data: FactSearchCreateManyInput | FactSearchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FactSearch update
   */
  export type FactSearchUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactSearch
     */
    select?: FactSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactSearch
     */
    omit?: FactSearchOmit<ExtArgs> | null
    /**
     * The data needed to update a FactSearch.
     */
    data: XOR<FactSearchUpdateInput, FactSearchUncheckedUpdateInput>
    /**
     * Choose, which FactSearch to update.
     */
    where: FactSearchWhereUniqueInput
  }

  /**
   * FactSearch updateMany
   */
  export type FactSearchUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update FactSearches.
     */
    data: XOR<
      FactSearchUpdateManyMutationInput,
      FactSearchUncheckedUpdateManyInput
    >
    /**
     * Filter which FactSearches to update
     */
    where?: FactSearchWhereInput
    /**
     * Limit how many FactSearches to update.
     */
    limit?: number
  }

  /**
   * FactSearch updateManyAndReturn
   */
  export type FactSearchUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactSearch
     */
    select?: FactSearchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FactSearch
     */
    omit?: FactSearchOmit<ExtArgs> | null
    /**
     * The data used to update FactSearches.
     */
    data: XOR<
      FactSearchUpdateManyMutationInput,
      FactSearchUncheckedUpdateManyInput
    >
    /**
     * Filter which FactSearches to update
     */
    where?: FactSearchWhereInput
    /**
     * Limit how many FactSearches to update.
     */
    limit?: number
  }

  /**
   * FactSearch upsert
   */
  export type FactSearchUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactSearch
     */
    select?: FactSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactSearch
     */
    omit?: FactSearchOmit<ExtArgs> | null
    /**
     * The filter to search for the FactSearch to update in case it exists.
     */
    where: FactSearchWhereUniqueInput
    /**
     * In case the FactSearch found by the `where` argument doesn't exist, create a new FactSearch with this data.
     */
    create: XOR<FactSearchCreateInput, FactSearchUncheckedCreateInput>
    /**
     * In case the FactSearch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FactSearchUpdateInput, FactSearchUncheckedUpdateInput>
  }

  /**
   * FactSearch delete
   */
  export type FactSearchDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactSearch
     */
    select?: FactSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactSearch
     */
    omit?: FactSearchOmit<ExtArgs> | null
    /**
     * Filter which FactSearch to delete.
     */
    where: FactSearchWhereUniqueInput
  }

  /**
   * FactSearch deleteMany
   */
  export type FactSearchDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FactSearches to delete
     */
    where?: FactSearchWhereInput
    /**
     * Limit how many FactSearches to delete.
     */
    limit?: number
  }

  /**
   * FactSearch without action
   */
  export type FactSearchDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactSearch
     */
    select?: FactSearchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactSearch
     */
    omit?: FactSearchOmit<ExtArgs> | null
  }

  /**
   * Model FactCartActivity
   */

  export type AggregateFactCartActivity = {
    _count: FactCartActivityCountAggregateOutputType | null
    _avg: FactCartActivityAvgAggregateOutputType | null
    _sum: FactCartActivitySumAggregateOutputType | null
    _min: FactCartActivityMinAggregateOutputType | null
    _max: FactCartActivityMaxAggregateOutputType | null
  }

  export type FactCartActivityAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    productId: number | null
    quantityDelta: number | null
    priceSnapshot: Decimal | null
  }

  export type FactCartActivitySumAggregateOutputType = {
    id: bigint | null
    userId: bigint | null
    productId: bigint | null
    quantityDelta: number | null
    priceSnapshot: Decimal | null
  }

  export type FactCartActivityMinAggregateOutputType = {
    id: bigint | null
    sessionId: string | null
    userId: bigint | null
    timestamp: Date | null
    action: string | null
    productId: bigint | null
    sku: string | null
    quantityDelta: number | null
    priceSnapshot: Decimal | null
  }

  export type FactCartActivityMaxAggregateOutputType = {
    id: bigint | null
    sessionId: string | null
    userId: bigint | null
    timestamp: Date | null
    action: string | null
    productId: bigint | null
    sku: string | null
    quantityDelta: number | null
    priceSnapshot: Decimal | null
  }

  export type FactCartActivityCountAggregateOutputType = {
    id: number
    sessionId: number
    userId: number
    timestamp: number
    action: number
    productId: number
    sku: number
    quantityDelta: number
    priceSnapshot: number
    _all: number
  }

  export type FactCartActivityAvgAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    quantityDelta?: true
    priceSnapshot?: true
  }

  export type FactCartActivitySumAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    quantityDelta?: true
    priceSnapshot?: true
  }

  export type FactCartActivityMinAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    timestamp?: true
    action?: true
    productId?: true
    sku?: true
    quantityDelta?: true
    priceSnapshot?: true
  }

  export type FactCartActivityMaxAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    timestamp?: true
    action?: true
    productId?: true
    sku?: true
    quantityDelta?: true
    priceSnapshot?: true
  }

  export type FactCartActivityCountAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    timestamp?: true
    action?: true
    productId?: true
    sku?: true
    quantityDelta?: true
    priceSnapshot?: true
    _all?: true
  }

  export type FactCartActivityAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FactCartActivity to aggregate.
     */
    where?: FactCartActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactCartActivities to fetch.
     */
    orderBy?:
      | FactCartActivityOrderByWithRelationInput
      | FactCartActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: FactCartActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactCartActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactCartActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned FactCartActivities
     **/
    _count?: true | FactCartActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: FactCartActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: FactCartActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FactCartActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FactCartActivityMaxAggregateInputType
  }

  export type GetFactCartActivityAggregateType<
    T extends FactCartActivityAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateFactCartActivity]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFactCartActivity[P]>
      : GetScalarType<T[P], AggregateFactCartActivity[P]>
  }

  export type FactCartActivityGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FactCartActivityWhereInput
    orderBy?:
      | FactCartActivityOrderByWithAggregationInput
      | FactCartActivityOrderByWithAggregationInput[]
    by: FactCartActivityScalarFieldEnum[] | FactCartActivityScalarFieldEnum
    having?: FactCartActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FactCartActivityCountAggregateInputType | true
    _avg?: FactCartActivityAvgAggregateInputType
    _sum?: FactCartActivitySumAggregateInputType
    _min?: FactCartActivityMinAggregateInputType
    _max?: FactCartActivityMaxAggregateInputType
  }

  export type FactCartActivityGroupByOutputType = {
    id: bigint
    sessionId: string
    userId: bigint | null
    timestamp: Date
    action: string
    productId: bigint
    sku: string
    quantityDelta: number
    priceSnapshot: Decimal
    _count: FactCartActivityCountAggregateOutputType | null
    _avg: FactCartActivityAvgAggregateOutputType | null
    _sum: FactCartActivitySumAggregateOutputType | null
    _min: FactCartActivityMinAggregateOutputType | null
    _max: FactCartActivityMaxAggregateOutputType | null
  }

  type GetFactCartActivityGroupByPayload<
    T extends FactCartActivityGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FactCartActivityGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof FactCartActivityGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], FactCartActivityGroupByOutputType[P]>
          : GetScalarType<T[P], FactCartActivityGroupByOutputType[P]>
      }
    >
  >

  export type FactCartActivitySelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      sessionId?: boolean
      userId?: boolean
      timestamp?: boolean
      action?: boolean
      productId?: boolean
      sku?: boolean
      quantityDelta?: boolean
      priceSnapshot?: boolean
    },
    ExtArgs['result']['factCartActivity']
  >

  export type FactCartActivitySelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      sessionId?: boolean
      userId?: boolean
      timestamp?: boolean
      action?: boolean
      productId?: boolean
      sku?: boolean
      quantityDelta?: boolean
      priceSnapshot?: boolean
    },
    ExtArgs['result']['factCartActivity']
  >

  export type FactCartActivitySelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      sessionId?: boolean
      userId?: boolean
      timestamp?: boolean
      action?: boolean
      productId?: boolean
      sku?: boolean
      quantityDelta?: boolean
      priceSnapshot?: boolean
    },
    ExtArgs['result']['factCartActivity']
  >

  export type FactCartActivitySelectScalar = {
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    timestamp?: boolean
    action?: boolean
    productId?: boolean
    sku?: boolean
    quantityDelta?: boolean
    priceSnapshot?: boolean
  }

  export type FactCartActivityOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'sessionId'
    | 'userId'
    | 'timestamp'
    | 'action'
    | 'productId'
    | 'sku'
    | 'quantityDelta'
    | 'priceSnapshot',
    ExtArgs['result']['factCartActivity']
  >

  export type $FactCartActivityPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'FactCartActivity'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        id: bigint
        sessionId: string
        userId: bigint | null
        timestamp: Date
        action: string
        productId: bigint
        sku: string
        quantityDelta: number
        priceSnapshot: Prisma.Decimal
      },
      ExtArgs['result']['factCartActivity']
    >
    composites: {}
  }

  type FactCartActivityGetPayload<
    S extends boolean | null | undefined | FactCartActivityDefaultArgs,
  > = $Result.GetResult<Prisma.$FactCartActivityPayload, S>

  type FactCartActivityCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    FactCartActivityFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: FactCartActivityCountAggregateInputType | true
  }

  export interface FactCartActivityDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['FactCartActivity']
      meta: { name: 'FactCartActivity' }
    }
    /**
     * Find zero or one FactCartActivity that matches the filter.
     * @param {FactCartActivityFindUniqueArgs} args - Arguments to find a FactCartActivity
     * @example
     * // Get one FactCartActivity
     * const factCartActivity = await prisma.factCartActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FactCartActivityFindUniqueArgs>(
      args: SelectSubset<T, FactCartActivityFindUniqueArgs<ExtArgs>>
    ): Prisma__FactCartActivityClient<
      $Result.GetResult<
        Prisma.$FactCartActivityPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one FactCartActivity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FactCartActivityFindUniqueOrThrowArgs} args - Arguments to find a FactCartActivity
     * @example
     * // Get one FactCartActivity
     * const factCartActivity = await prisma.factCartActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FactCartActivityFindUniqueOrThrowArgs>(
      args: SelectSubset<T, FactCartActivityFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FactCartActivityClient<
      $Result.GetResult<
        Prisma.$FactCartActivityPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first FactCartActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactCartActivityFindFirstArgs} args - Arguments to find a FactCartActivity
     * @example
     * // Get one FactCartActivity
     * const factCartActivity = await prisma.factCartActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FactCartActivityFindFirstArgs>(
      args?: SelectSubset<T, FactCartActivityFindFirstArgs<ExtArgs>>
    ): Prisma__FactCartActivityClient<
      $Result.GetResult<
        Prisma.$FactCartActivityPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first FactCartActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactCartActivityFindFirstOrThrowArgs} args - Arguments to find a FactCartActivity
     * @example
     * // Get one FactCartActivity
     * const factCartActivity = await prisma.factCartActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FactCartActivityFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FactCartActivityFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FactCartActivityClient<
      $Result.GetResult<
        Prisma.$FactCartActivityPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more FactCartActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactCartActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FactCartActivities
     * const factCartActivities = await prisma.factCartActivity.findMany()
     *
     * // Get first 10 FactCartActivities
     * const factCartActivities = await prisma.factCartActivity.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const factCartActivityWithIdOnly = await prisma.factCartActivity.findMany({ select: { id: true } })
     *
     */
    findMany<T extends FactCartActivityFindManyArgs>(
      args?: SelectSubset<T, FactCartActivityFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FactCartActivityPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a FactCartActivity.
     * @param {FactCartActivityCreateArgs} args - Arguments to create a FactCartActivity.
     * @example
     * // Create one FactCartActivity
     * const FactCartActivity = await prisma.factCartActivity.create({
     *   data: {
     *     // ... data to create a FactCartActivity
     *   }
     * })
     *
     */
    create<T extends FactCartActivityCreateArgs>(
      args: SelectSubset<T, FactCartActivityCreateArgs<ExtArgs>>
    ): Prisma__FactCartActivityClient<
      $Result.GetResult<
        Prisma.$FactCartActivityPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many FactCartActivities.
     * @param {FactCartActivityCreateManyArgs} args - Arguments to create many FactCartActivities.
     * @example
     * // Create many FactCartActivities
     * const factCartActivity = await prisma.factCartActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends FactCartActivityCreateManyArgs>(
      args?: SelectSubset<T, FactCartActivityCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FactCartActivities and returns the data saved in the database.
     * @param {FactCartActivityCreateManyAndReturnArgs} args - Arguments to create many FactCartActivities.
     * @example
     * // Create many FactCartActivities
     * const factCartActivity = await prisma.factCartActivity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many FactCartActivities and only return the `id`
     * const factCartActivityWithIdOnly = await prisma.factCartActivity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends FactCartActivityCreateManyAndReturnArgs>(
      args?: SelectSubset<T, FactCartActivityCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FactCartActivityPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Delete a FactCartActivity.
     * @param {FactCartActivityDeleteArgs} args - Arguments to delete one FactCartActivity.
     * @example
     * // Delete one FactCartActivity
     * const FactCartActivity = await prisma.factCartActivity.delete({
     *   where: {
     *     // ... filter to delete one FactCartActivity
     *   }
     * })
     *
     */
    delete<T extends FactCartActivityDeleteArgs>(
      args: SelectSubset<T, FactCartActivityDeleteArgs<ExtArgs>>
    ): Prisma__FactCartActivityClient<
      $Result.GetResult<
        Prisma.$FactCartActivityPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one FactCartActivity.
     * @param {FactCartActivityUpdateArgs} args - Arguments to update one FactCartActivity.
     * @example
     * // Update one FactCartActivity
     * const factCartActivity = await prisma.factCartActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends FactCartActivityUpdateArgs>(
      args: SelectSubset<T, FactCartActivityUpdateArgs<ExtArgs>>
    ): Prisma__FactCartActivityClient<
      $Result.GetResult<
        Prisma.$FactCartActivityPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more FactCartActivities.
     * @param {FactCartActivityDeleteManyArgs} args - Arguments to filter FactCartActivities to delete.
     * @example
     * // Delete a few FactCartActivities
     * const { count } = await prisma.factCartActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends FactCartActivityDeleteManyArgs>(
      args?: SelectSubset<T, FactCartActivityDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FactCartActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactCartActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FactCartActivities
     * const factCartActivity = await prisma.factCartActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends FactCartActivityUpdateManyArgs>(
      args: SelectSubset<T, FactCartActivityUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FactCartActivities and returns the data updated in the database.
     * @param {FactCartActivityUpdateManyAndReturnArgs} args - Arguments to update many FactCartActivities.
     * @example
     * // Update many FactCartActivities
     * const factCartActivity = await prisma.factCartActivity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more FactCartActivities and only return the `id`
     * const factCartActivityWithIdOnly = await prisma.factCartActivity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends FactCartActivityUpdateManyAndReturnArgs>(
      args: SelectSubset<T, FactCartActivityUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FactCartActivityPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Create or update one FactCartActivity.
     * @param {FactCartActivityUpsertArgs} args - Arguments to update or create a FactCartActivity.
     * @example
     * // Update or create a FactCartActivity
     * const factCartActivity = await prisma.factCartActivity.upsert({
     *   create: {
     *     // ... data to create a FactCartActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FactCartActivity we want to update
     *   }
     * })
     */
    upsert<T extends FactCartActivityUpsertArgs>(
      args: SelectSubset<T, FactCartActivityUpsertArgs<ExtArgs>>
    ): Prisma__FactCartActivityClient<
      $Result.GetResult<
        Prisma.$FactCartActivityPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of FactCartActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactCartActivityCountArgs} args - Arguments to filter FactCartActivities to count.
     * @example
     * // Count the number of FactCartActivities
     * const count = await prisma.factCartActivity.count({
     *   where: {
     *     // ... the filter for the FactCartActivities we want to count
     *   }
     * })
     **/
    count<T extends FactCartActivityCountArgs>(
      args?: Subset<T, FactCartActivityCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FactCartActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FactCartActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactCartActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FactCartActivityAggregateArgs>(
      args: Subset<T, FactCartActivityAggregateArgs>
    ): Prisma.PrismaPromise<GetFactCartActivityAggregateType<T>>

    /**
     * Group by FactCartActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactCartActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends FactCartActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FactCartActivityGroupByArgs['orderBy'] }
        : { orderBy?: FactCartActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ]
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, FactCartActivityGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetFactCartActivityGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the FactCartActivity model
     */
    readonly fields: FactCartActivityFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for FactCartActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FactCartActivityClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the FactCartActivity model
   */
  interface FactCartActivityFieldRefs {
    readonly id: FieldRef<'FactCartActivity', 'BigInt'>
    readonly sessionId: FieldRef<'FactCartActivity', 'String'>
    readonly userId: FieldRef<'FactCartActivity', 'BigInt'>
    readonly timestamp: FieldRef<'FactCartActivity', 'DateTime'>
    readonly action: FieldRef<'FactCartActivity', 'String'>
    readonly productId: FieldRef<'FactCartActivity', 'BigInt'>
    readonly sku: FieldRef<'FactCartActivity', 'String'>
    readonly quantityDelta: FieldRef<'FactCartActivity', 'Int'>
    readonly priceSnapshot: FieldRef<'FactCartActivity', 'Decimal'>
  }

  // Custom InputTypes
  /**
   * FactCartActivity findUnique
   */
  export type FactCartActivityFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactCartActivity
     */
    select?: FactCartActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactCartActivity
     */
    omit?: FactCartActivityOmit<ExtArgs> | null
    /**
     * Filter, which FactCartActivity to fetch.
     */
    where: FactCartActivityWhereUniqueInput
  }

  /**
   * FactCartActivity findUniqueOrThrow
   */
  export type FactCartActivityFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactCartActivity
     */
    select?: FactCartActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactCartActivity
     */
    omit?: FactCartActivityOmit<ExtArgs> | null
    /**
     * Filter, which FactCartActivity to fetch.
     */
    where: FactCartActivityWhereUniqueInput
  }

  /**
   * FactCartActivity findFirst
   */
  export type FactCartActivityFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactCartActivity
     */
    select?: FactCartActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactCartActivity
     */
    omit?: FactCartActivityOmit<ExtArgs> | null
    /**
     * Filter, which FactCartActivity to fetch.
     */
    where?: FactCartActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactCartActivities to fetch.
     */
    orderBy?:
      | FactCartActivityOrderByWithRelationInput
      | FactCartActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FactCartActivities.
     */
    cursor?: FactCartActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactCartActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactCartActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FactCartActivities.
     */
    distinct?:
      | FactCartActivityScalarFieldEnum
      | FactCartActivityScalarFieldEnum[]
  }

  /**
   * FactCartActivity findFirstOrThrow
   */
  export type FactCartActivityFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactCartActivity
     */
    select?: FactCartActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactCartActivity
     */
    omit?: FactCartActivityOmit<ExtArgs> | null
    /**
     * Filter, which FactCartActivity to fetch.
     */
    where?: FactCartActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactCartActivities to fetch.
     */
    orderBy?:
      | FactCartActivityOrderByWithRelationInput
      | FactCartActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FactCartActivities.
     */
    cursor?: FactCartActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactCartActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactCartActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FactCartActivities.
     */
    distinct?:
      | FactCartActivityScalarFieldEnum
      | FactCartActivityScalarFieldEnum[]
  }

  /**
   * FactCartActivity findMany
   */
  export type FactCartActivityFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactCartActivity
     */
    select?: FactCartActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactCartActivity
     */
    omit?: FactCartActivityOmit<ExtArgs> | null
    /**
     * Filter, which FactCartActivities to fetch.
     */
    where?: FactCartActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactCartActivities to fetch.
     */
    orderBy?:
      | FactCartActivityOrderByWithRelationInput
      | FactCartActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing FactCartActivities.
     */
    cursor?: FactCartActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactCartActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactCartActivities.
     */
    skip?: number
    distinct?:
      | FactCartActivityScalarFieldEnum
      | FactCartActivityScalarFieldEnum[]
  }

  /**
   * FactCartActivity create
   */
  export type FactCartActivityCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactCartActivity
     */
    select?: FactCartActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactCartActivity
     */
    omit?: FactCartActivityOmit<ExtArgs> | null
    /**
     * The data needed to create a FactCartActivity.
     */
    data: XOR<FactCartActivityCreateInput, FactCartActivityUncheckedCreateInput>
  }

  /**
   * FactCartActivity createMany
   */
  export type FactCartActivityCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many FactCartActivities.
     */
    data: FactCartActivityCreateManyInput | FactCartActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FactCartActivity createManyAndReturn
   */
  export type FactCartActivityCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactCartActivity
     */
    select?: FactCartActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FactCartActivity
     */
    omit?: FactCartActivityOmit<ExtArgs> | null
    /**
     * The data used to create many FactCartActivities.
     */
    data: FactCartActivityCreateManyInput | FactCartActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FactCartActivity update
   */
  export type FactCartActivityUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactCartActivity
     */
    select?: FactCartActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactCartActivity
     */
    omit?: FactCartActivityOmit<ExtArgs> | null
    /**
     * The data needed to update a FactCartActivity.
     */
    data: XOR<FactCartActivityUpdateInput, FactCartActivityUncheckedUpdateInput>
    /**
     * Choose, which FactCartActivity to update.
     */
    where: FactCartActivityWhereUniqueInput
  }

  /**
   * FactCartActivity updateMany
   */
  export type FactCartActivityUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update FactCartActivities.
     */
    data: XOR<
      FactCartActivityUpdateManyMutationInput,
      FactCartActivityUncheckedUpdateManyInput
    >
    /**
     * Filter which FactCartActivities to update
     */
    where?: FactCartActivityWhereInput
    /**
     * Limit how many FactCartActivities to update.
     */
    limit?: number
  }

  /**
   * FactCartActivity updateManyAndReturn
   */
  export type FactCartActivityUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactCartActivity
     */
    select?: FactCartActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FactCartActivity
     */
    omit?: FactCartActivityOmit<ExtArgs> | null
    /**
     * The data used to update FactCartActivities.
     */
    data: XOR<
      FactCartActivityUpdateManyMutationInput,
      FactCartActivityUncheckedUpdateManyInput
    >
    /**
     * Filter which FactCartActivities to update
     */
    where?: FactCartActivityWhereInput
    /**
     * Limit how many FactCartActivities to update.
     */
    limit?: number
  }

  /**
   * FactCartActivity upsert
   */
  export type FactCartActivityUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactCartActivity
     */
    select?: FactCartActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactCartActivity
     */
    omit?: FactCartActivityOmit<ExtArgs> | null
    /**
     * The filter to search for the FactCartActivity to update in case it exists.
     */
    where: FactCartActivityWhereUniqueInput
    /**
     * In case the FactCartActivity found by the `where` argument doesn't exist, create a new FactCartActivity with this data.
     */
    create: XOR<
      FactCartActivityCreateInput,
      FactCartActivityUncheckedCreateInput
    >
    /**
     * In case the FactCartActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      FactCartActivityUpdateInput,
      FactCartActivityUncheckedUpdateInput
    >
  }

  /**
   * FactCartActivity delete
   */
  export type FactCartActivityDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactCartActivity
     */
    select?: FactCartActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactCartActivity
     */
    omit?: FactCartActivityOmit<ExtArgs> | null
    /**
     * Filter which FactCartActivity to delete.
     */
    where: FactCartActivityWhereUniqueInput
  }

  /**
   * FactCartActivity deleteMany
   */
  export type FactCartActivityDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FactCartActivities to delete
     */
    where?: FactCartActivityWhereInput
    /**
     * Limit how many FactCartActivities to delete.
     */
    limit?: number
  }

  /**
   * FactCartActivity without action
   */
  export type FactCartActivityDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactCartActivity
     */
    select?: FactCartActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactCartActivity
     */
    omit?: FactCartActivityOmit<ExtArgs> | null
  }

  /**
   * Model FactReview
   */

  export type AggregateFactReview = {
    _count: FactReviewCountAggregateOutputType | null
    _avg: FactReviewAvgAggregateOutputType | null
    _sum: FactReviewSumAggregateOutputType | null
    _min: FactReviewMinAggregateOutputType | null
    _max: FactReviewMaxAggregateOutputType | null
  }

  export type FactReviewAvgAggregateOutputType = {
    id: number | null
    reviewId: number | null
    productId: number | null
    userId: number | null
    dateId: number | null
    rating: number | null
    textLength: number | null
    sentimentScore: number | null
  }

  export type FactReviewSumAggregateOutputType = {
    id: bigint | null
    reviewId: bigint | null
    productId: bigint | null
    userId: bigint | null
    dateId: number | null
    rating: number | null
    textLength: number | null
    sentimentScore: number | null
  }

  export type FactReviewMinAggregateOutputType = {
    id: bigint | null
    reviewId: bigint | null
    productId: bigint | null
    userId: bigint | null
    dateId: number | null
    timestamp: Date | null
    rating: number | null
    hasText: boolean | null
    hasImages: boolean | null
    textLength: number | null
    sentimentScore: number | null
    verified: boolean | null
  }

  export type FactReviewMaxAggregateOutputType = {
    id: bigint | null
    reviewId: bigint | null
    productId: bigint | null
    userId: bigint | null
    dateId: number | null
    timestamp: Date | null
    rating: number | null
    hasText: boolean | null
    hasImages: boolean | null
    textLength: number | null
    sentimentScore: number | null
    verified: boolean | null
  }

  export type FactReviewCountAggregateOutputType = {
    id: number
    reviewId: number
    productId: number
    userId: number
    dateId: number
    timestamp: number
    rating: number
    hasText: number
    hasImages: number
    textLength: number
    sentimentScore: number
    verified: number
    _all: number
  }

  export type FactReviewAvgAggregateInputType = {
    id?: true
    reviewId?: true
    productId?: true
    userId?: true
    dateId?: true
    rating?: true
    textLength?: true
    sentimentScore?: true
  }

  export type FactReviewSumAggregateInputType = {
    id?: true
    reviewId?: true
    productId?: true
    userId?: true
    dateId?: true
    rating?: true
    textLength?: true
    sentimentScore?: true
  }

  export type FactReviewMinAggregateInputType = {
    id?: true
    reviewId?: true
    productId?: true
    userId?: true
    dateId?: true
    timestamp?: true
    rating?: true
    hasText?: true
    hasImages?: true
    textLength?: true
    sentimentScore?: true
    verified?: true
  }

  export type FactReviewMaxAggregateInputType = {
    id?: true
    reviewId?: true
    productId?: true
    userId?: true
    dateId?: true
    timestamp?: true
    rating?: true
    hasText?: true
    hasImages?: true
    textLength?: true
    sentimentScore?: true
    verified?: true
  }

  export type FactReviewCountAggregateInputType = {
    id?: true
    reviewId?: true
    productId?: true
    userId?: true
    dateId?: true
    timestamp?: true
    rating?: true
    hasText?: true
    hasImages?: true
    textLength?: true
    sentimentScore?: true
    verified?: true
    _all?: true
  }

  export type FactReviewAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FactReview to aggregate.
     */
    where?: FactReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactReviews to fetch.
     */
    orderBy?:
      | FactReviewOrderByWithRelationInput
      | FactReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: FactReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned FactReviews
     **/
    _count?: true | FactReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: FactReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: FactReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FactReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FactReviewMaxAggregateInputType
  }

  export type GetFactReviewAggregateType<T extends FactReviewAggregateArgs> = {
    [P in keyof T & keyof AggregateFactReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFactReview[P]>
      : GetScalarType<T[P], AggregateFactReview[P]>
  }

  export type FactReviewGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FactReviewWhereInput
    orderBy?:
      | FactReviewOrderByWithAggregationInput
      | FactReviewOrderByWithAggregationInput[]
    by: FactReviewScalarFieldEnum[] | FactReviewScalarFieldEnum
    having?: FactReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FactReviewCountAggregateInputType | true
    _avg?: FactReviewAvgAggregateInputType
    _sum?: FactReviewSumAggregateInputType
    _min?: FactReviewMinAggregateInputType
    _max?: FactReviewMaxAggregateInputType
  }

  export type FactReviewGroupByOutputType = {
    id: bigint
    reviewId: bigint
    productId: bigint
    userId: bigint | null
    dateId: number
    timestamp: Date
    rating: number
    hasText: boolean
    hasImages: boolean
    textLength: number
    sentimentScore: number | null
    verified: boolean
    _count: FactReviewCountAggregateOutputType | null
    _avg: FactReviewAvgAggregateOutputType | null
    _sum: FactReviewSumAggregateOutputType | null
    _min: FactReviewMinAggregateOutputType | null
    _max: FactReviewMaxAggregateOutputType | null
  }

  type GetFactReviewGroupByPayload<T extends FactReviewGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<FactReviewGroupByOutputType, T['by']> & {
          [P in keyof T & keyof FactReviewGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FactReviewGroupByOutputType[P]>
            : GetScalarType<T[P], FactReviewGroupByOutputType[P]>
        }
      >
    >

  export type FactReviewSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      reviewId?: boolean
      productId?: boolean
      userId?: boolean
      dateId?: boolean
      timestamp?: boolean
      rating?: boolean
      hasText?: boolean
      hasImages?: boolean
      textLength?: boolean
      sentimentScore?: boolean
      verified?: boolean
    },
    ExtArgs['result']['factReview']
  >

  export type FactReviewSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      reviewId?: boolean
      productId?: boolean
      userId?: boolean
      dateId?: boolean
      timestamp?: boolean
      rating?: boolean
      hasText?: boolean
      hasImages?: boolean
      textLength?: boolean
      sentimentScore?: boolean
      verified?: boolean
    },
    ExtArgs['result']['factReview']
  >

  export type FactReviewSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      reviewId?: boolean
      productId?: boolean
      userId?: boolean
      dateId?: boolean
      timestamp?: boolean
      rating?: boolean
      hasText?: boolean
      hasImages?: boolean
      textLength?: boolean
      sentimentScore?: boolean
      verified?: boolean
    },
    ExtArgs['result']['factReview']
  >

  export type FactReviewSelectScalar = {
    id?: boolean
    reviewId?: boolean
    productId?: boolean
    userId?: boolean
    dateId?: boolean
    timestamp?: boolean
    rating?: boolean
    hasText?: boolean
    hasImages?: boolean
    textLength?: boolean
    sentimentScore?: boolean
    verified?: boolean
  }

  export type FactReviewOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'reviewId'
    | 'productId'
    | 'userId'
    | 'dateId'
    | 'timestamp'
    | 'rating'
    | 'hasText'
    | 'hasImages'
    | 'textLength'
    | 'sentimentScore'
    | 'verified',
    ExtArgs['result']['factReview']
  >

  export type $FactReviewPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'FactReview'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        id: bigint
        reviewId: bigint
        productId: bigint
        userId: bigint | null
        dateId: number
        timestamp: Date
        rating: number
        hasText: boolean
        hasImages: boolean
        textLength: number
        sentimentScore: number | null
        verified: boolean
      },
      ExtArgs['result']['factReview']
    >
    composites: {}
  }

  type FactReviewGetPayload<
    S extends boolean | null | undefined | FactReviewDefaultArgs,
  > = $Result.GetResult<Prisma.$FactReviewPayload, S>

  type FactReviewCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    FactReviewFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: FactReviewCountAggregateInputType | true
  }

  export interface FactReviewDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['FactReview']
      meta: { name: 'FactReview' }
    }
    /**
     * Find zero or one FactReview that matches the filter.
     * @param {FactReviewFindUniqueArgs} args - Arguments to find a FactReview
     * @example
     * // Get one FactReview
     * const factReview = await prisma.factReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FactReviewFindUniqueArgs>(
      args: SelectSubset<T, FactReviewFindUniqueArgs<ExtArgs>>
    ): Prisma__FactReviewClient<
      $Result.GetResult<
        Prisma.$FactReviewPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one FactReview that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FactReviewFindUniqueOrThrowArgs} args - Arguments to find a FactReview
     * @example
     * // Get one FactReview
     * const factReview = await prisma.factReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FactReviewFindUniqueOrThrowArgs>(
      args: SelectSubset<T, FactReviewFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FactReviewClient<
      $Result.GetResult<
        Prisma.$FactReviewPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first FactReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactReviewFindFirstArgs} args - Arguments to find a FactReview
     * @example
     * // Get one FactReview
     * const factReview = await prisma.factReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FactReviewFindFirstArgs>(
      args?: SelectSubset<T, FactReviewFindFirstArgs<ExtArgs>>
    ): Prisma__FactReviewClient<
      $Result.GetResult<
        Prisma.$FactReviewPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first FactReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactReviewFindFirstOrThrowArgs} args - Arguments to find a FactReview
     * @example
     * // Get one FactReview
     * const factReview = await prisma.factReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FactReviewFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FactReviewFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FactReviewClient<
      $Result.GetResult<
        Prisma.$FactReviewPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more FactReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FactReviews
     * const factReviews = await prisma.factReview.findMany()
     *
     * // Get first 10 FactReviews
     * const factReviews = await prisma.factReview.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const factReviewWithIdOnly = await prisma.factReview.findMany({ select: { id: true } })
     *
     */
    findMany<T extends FactReviewFindManyArgs>(
      args?: SelectSubset<T, FactReviewFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FactReviewPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a FactReview.
     * @param {FactReviewCreateArgs} args - Arguments to create a FactReview.
     * @example
     * // Create one FactReview
     * const FactReview = await prisma.factReview.create({
     *   data: {
     *     // ... data to create a FactReview
     *   }
     * })
     *
     */
    create<T extends FactReviewCreateArgs>(
      args: SelectSubset<T, FactReviewCreateArgs<ExtArgs>>
    ): Prisma__FactReviewClient<
      $Result.GetResult<
        Prisma.$FactReviewPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many FactReviews.
     * @param {FactReviewCreateManyArgs} args - Arguments to create many FactReviews.
     * @example
     * // Create many FactReviews
     * const factReview = await prisma.factReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends FactReviewCreateManyArgs>(
      args?: SelectSubset<T, FactReviewCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FactReviews and returns the data saved in the database.
     * @param {FactReviewCreateManyAndReturnArgs} args - Arguments to create many FactReviews.
     * @example
     * // Create many FactReviews
     * const factReview = await prisma.factReview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many FactReviews and only return the `id`
     * const factReviewWithIdOnly = await prisma.factReview.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends FactReviewCreateManyAndReturnArgs>(
      args?: SelectSubset<T, FactReviewCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FactReviewPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Delete a FactReview.
     * @param {FactReviewDeleteArgs} args - Arguments to delete one FactReview.
     * @example
     * // Delete one FactReview
     * const FactReview = await prisma.factReview.delete({
     *   where: {
     *     // ... filter to delete one FactReview
     *   }
     * })
     *
     */
    delete<T extends FactReviewDeleteArgs>(
      args: SelectSubset<T, FactReviewDeleteArgs<ExtArgs>>
    ): Prisma__FactReviewClient<
      $Result.GetResult<
        Prisma.$FactReviewPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one FactReview.
     * @param {FactReviewUpdateArgs} args - Arguments to update one FactReview.
     * @example
     * // Update one FactReview
     * const factReview = await prisma.factReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends FactReviewUpdateArgs>(
      args: SelectSubset<T, FactReviewUpdateArgs<ExtArgs>>
    ): Prisma__FactReviewClient<
      $Result.GetResult<
        Prisma.$FactReviewPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more FactReviews.
     * @param {FactReviewDeleteManyArgs} args - Arguments to filter FactReviews to delete.
     * @example
     * // Delete a few FactReviews
     * const { count } = await prisma.factReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends FactReviewDeleteManyArgs>(
      args?: SelectSubset<T, FactReviewDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FactReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FactReviews
     * const factReview = await prisma.factReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends FactReviewUpdateManyArgs>(
      args: SelectSubset<T, FactReviewUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FactReviews and returns the data updated in the database.
     * @param {FactReviewUpdateManyAndReturnArgs} args - Arguments to update many FactReviews.
     * @example
     * // Update many FactReviews
     * const factReview = await prisma.factReview.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more FactReviews and only return the `id`
     * const factReviewWithIdOnly = await prisma.factReview.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends FactReviewUpdateManyAndReturnArgs>(
      args: SelectSubset<T, FactReviewUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FactReviewPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Create or update one FactReview.
     * @param {FactReviewUpsertArgs} args - Arguments to update or create a FactReview.
     * @example
     * // Update or create a FactReview
     * const factReview = await prisma.factReview.upsert({
     *   create: {
     *     // ... data to create a FactReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FactReview we want to update
     *   }
     * })
     */
    upsert<T extends FactReviewUpsertArgs>(
      args: SelectSubset<T, FactReviewUpsertArgs<ExtArgs>>
    ): Prisma__FactReviewClient<
      $Result.GetResult<
        Prisma.$FactReviewPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of FactReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactReviewCountArgs} args - Arguments to filter FactReviews to count.
     * @example
     * // Count the number of FactReviews
     * const count = await prisma.factReview.count({
     *   where: {
     *     // ... the filter for the FactReviews we want to count
     *   }
     * })
     **/
    count<T extends FactReviewCountArgs>(
      args?: Subset<T, FactReviewCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FactReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FactReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FactReviewAggregateArgs>(
      args: Subset<T, FactReviewAggregateArgs>
    ): Prisma.PrismaPromise<GetFactReviewAggregateType<T>>

    /**
     * Group by FactReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends FactReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FactReviewGroupByArgs['orderBy'] }
        : { orderBy?: FactReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ]
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, FactReviewGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetFactReviewGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the FactReview model
     */
    readonly fields: FactReviewFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for FactReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FactReviewClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the FactReview model
   */
  interface FactReviewFieldRefs {
    readonly id: FieldRef<'FactReview', 'BigInt'>
    readonly reviewId: FieldRef<'FactReview', 'BigInt'>
    readonly productId: FieldRef<'FactReview', 'BigInt'>
    readonly userId: FieldRef<'FactReview', 'BigInt'>
    readonly dateId: FieldRef<'FactReview', 'Int'>
    readonly timestamp: FieldRef<'FactReview', 'DateTime'>
    readonly rating: FieldRef<'FactReview', 'Int'>
    readonly hasText: FieldRef<'FactReview', 'Boolean'>
    readonly hasImages: FieldRef<'FactReview', 'Boolean'>
    readonly textLength: FieldRef<'FactReview', 'Int'>
    readonly sentimentScore: FieldRef<'FactReview', 'Float'>
    readonly verified: FieldRef<'FactReview', 'Boolean'>
  }

  // Custom InputTypes
  /**
   * FactReview findUnique
   */
  export type FactReviewFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactReview
     */
    select?: FactReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactReview
     */
    omit?: FactReviewOmit<ExtArgs> | null
    /**
     * Filter, which FactReview to fetch.
     */
    where: FactReviewWhereUniqueInput
  }

  /**
   * FactReview findUniqueOrThrow
   */
  export type FactReviewFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactReview
     */
    select?: FactReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactReview
     */
    omit?: FactReviewOmit<ExtArgs> | null
    /**
     * Filter, which FactReview to fetch.
     */
    where: FactReviewWhereUniqueInput
  }

  /**
   * FactReview findFirst
   */
  export type FactReviewFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactReview
     */
    select?: FactReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactReview
     */
    omit?: FactReviewOmit<ExtArgs> | null
    /**
     * Filter, which FactReview to fetch.
     */
    where?: FactReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactReviews to fetch.
     */
    orderBy?:
      | FactReviewOrderByWithRelationInput
      | FactReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FactReviews.
     */
    cursor?: FactReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FactReviews.
     */
    distinct?: FactReviewScalarFieldEnum | FactReviewScalarFieldEnum[]
  }

  /**
   * FactReview findFirstOrThrow
   */
  export type FactReviewFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactReview
     */
    select?: FactReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactReview
     */
    omit?: FactReviewOmit<ExtArgs> | null
    /**
     * Filter, which FactReview to fetch.
     */
    where?: FactReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactReviews to fetch.
     */
    orderBy?:
      | FactReviewOrderByWithRelationInput
      | FactReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FactReviews.
     */
    cursor?: FactReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FactReviews.
     */
    distinct?: FactReviewScalarFieldEnum | FactReviewScalarFieldEnum[]
  }

  /**
   * FactReview findMany
   */
  export type FactReviewFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactReview
     */
    select?: FactReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactReview
     */
    omit?: FactReviewOmit<ExtArgs> | null
    /**
     * Filter, which FactReviews to fetch.
     */
    where?: FactReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FactReviews to fetch.
     */
    orderBy?:
      | FactReviewOrderByWithRelationInput
      | FactReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing FactReviews.
     */
    cursor?: FactReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FactReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FactReviews.
     */
    skip?: number
    distinct?: FactReviewScalarFieldEnum | FactReviewScalarFieldEnum[]
  }

  /**
   * FactReview create
   */
  export type FactReviewCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactReview
     */
    select?: FactReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactReview
     */
    omit?: FactReviewOmit<ExtArgs> | null
    /**
     * The data needed to create a FactReview.
     */
    data: XOR<FactReviewCreateInput, FactReviewUncheckedCreateInput>
  }

  /**
   * FactReview createMany
   */
  export type FactReviewCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many FactReviews.
     */
    data: FactReviewCreateManyInput | FactReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FactReview createManyAndReturn
   */
  export type FactReviewCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactReview
     */
    select?: FactReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FactReview
     */
    omit?: FactReviewOmit<ExtArgs> | null
    /**
     * The data used to create many FactReviews.
     */
    data: FactReviewCreateManyInput | FactReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FactReview update
   */
  export type FactReviewUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactReview
     */
    select?: FactReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactReview
     */
    omit?: FactReviewOmit<ExtArgs> | null
    /**
     * The data needed to update a FactReview.
     */
    data: XOR<FactReviewUpdateInput, FactReviewUncheckedUpdateInput>
    /**
     * Choose, which FactReview to update.
     */
    where: FactReviewWhereUniqueInput
  }

  /**
   * FactReview updateMany
   */
  export type FactReviewUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update FactReviews.
     */
    data: XOR<
      FactReviewUpdateManyMutationInput,
      FactReviewUncheckedUpdateManyInput
    >
    /**
     * Filter which FactReviews to update
     */
    where?: FactReviewWhereInput
    /**
     * Limit how many FactReviews to update.
     */
    limit?: number
  }

  /**
   * FactReview updateManyAndReturn
   */
  export type FactReviewUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactReview
     */
    select?: FactReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FactReview
     */
    omit?: FactReviewOmit<ExtArgs> | null
    /**
     * The data used to update FactReviews.
     */
    data: XOR<
      FactReviewUpdateManyMutationInput,
      FactReviewUncheckedUpdateManyInput
    >
    /**
     * Filter which FactReviews to update
     */
    where?: FactReviewWhereInput
    /**
     * Limit how many FactReviews to update.
     */
    limit?: number
  }

  /**
   * FactReview upsert
   */
  export type FactReviewUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactReview
     */
    select?: FactReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactReview
     */
    omit?: FactReviewOmit<ExtArgs> | null
    /**
     * The filter to search for the FactReview to update in case it exists.
     */
    where: FactReviewWhereUniqueInput
    /**
     * In case the FactReview found by the `where` argument doesn't exist, create a new FactReview with this data.
     */
    create: XOR<FactReviewCreateInput, FactReviewUncheckedCreateInput>
    /**
     * In case the FactReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FactReviewUpdateInput, FactReviewUncheckedUpdateInput>
  }

  /**
   * FactReview delete
   */
  export type FactReviewDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactReview
     */
    select?: FactReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactReview
     */
    omit?: FactReviewOmit<ExtArgs> | null
    /**
     * Filter which FactReview to delete.
     */
    where: FactReviewWhereUniqueInput
  }

  /**
   * FactReview deleteMany
   */
  export type FactReviewDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FactReviews to delete
     */
    where?: FactReviewWhereInput
    /**
     * Limit how many FactReviews to delete.
     */
    limit?: number
  }

  /**
   * FactReview without action
   */
  export type FactReviewDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FactReview
     */
    select?: FactReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FactReview
     */
    omit?: FactReviewOmit<ExtArgs> | null
  }

  /**
   * Model DimProduct
   */

  export type AggregateDimProduct = {
    _count: DimProductCountAggregateOutputType | null
    _avg: DimProductAvgAggregateOutputType | null
    _sum: DimProductSumAggregateOutputType | null
    _min: DimProductMinAggregateOutputType | null
    _max: DimProductMaxAggregateOutputType | null
  }

  export type DimProductAvgAggregateOutputType = {
    productScId: number | null
    productId: number | null
    categoryId: number | null
    brandId: number | null
    currentPrice: Decimal | null
    costPrice: Decimal | null
  }

  export type DimProductSumAggregateOutputType = {
    productScId: bigint | null
    productId: bigint | null
    categoryId: number | null
    brandId: number | null
    currentPrice: Decimal | null
    costPrice: Decimal | null
  }

  export type DimProductMinAggregateOutputType = {
    productScId: bigint | null
    productId: bigint | null
    sku: string | null
    name: string | null
    categoryId: number | null
    brandId: number | null
    currentPrice: Decimal | null
    costPrice: Decimal | null
    isActive: boolean | null
    validFrom: Date | null
    validTo: Date | null
    isCurrent: boolean | null
    categoryName: string | null
    brandName: string | null
    supplier: string | null
  }

  export type DimProductMaxAggregateOutputType = {
    productScId: bigint | null
    productId: bigint | null
    sku: string | null
    name: string | null
    categoryId: number | null
    brandId: number | null
    currentPrice: Decimal | null
    costPrice: Decimal | null
    isActive: boolean | null
    validFrom: Date | null
    validTo: Date | null
    isCurrent: boolean | null
    categoryName: string | null
    brandName: string | null
    supplier: string | null
  }

  export type DimProductCountAggregateOutputType = {
    productScId: number
    productId: number
    sku: number
    name: number
    categoryId: number
    brandId: number
    currentPrice: number
    costPrice: number
    isActive: number
    validFrom: number
    validTo: number
    isCurrent: number
    categoryName: number
    brandName: number
    supplier: number
    tags: number
    _all: number
  }

  export type DimProductAvgAggregateInputType = {
    productScId?: true
    productId?: true
    categoryId?: true
    brandId?: true
    currentPrice?: true
    costPrice?: true
  }

  export type DimProductSumAggregateInputType = {
    productScId?: true
    productId?: true
    categoryId?: true
    brandId?: true
    currentPrice?: true
    costPrice?: true
  }

  export type DimProductMinAggregateInputType = {
    productScId?: true
    productId?: true
    sku?: true
    name?: true
    categoryId?: true
    brandId?: true
    currentPrice?: true
    costPrice?: true
    isActive?: true
    validFrom?: true
    validTo?: true
    isCurrent?: true
    categoryName?: true
    brandName?: true
    supplier?: true
  }

  export type DimProductMaxAggregateInputType = {
    productScId?: true
    productId?: true
    sku?: true
    name?: true
    categoryId?: true
    brandId?: true
    currentPrice?: true
    costPrice?: true
    isActive?: true
    validFrom?: true
    validTo?: true
    isCurrent?: true
    categoryName?: true
    brandName?: true
    supplier?: true
  }

  export type DimProductCountAggregateInputType = {
    productScId?: true
    productId?: true
    sku?: true
    name?: true
    categoryId?: true
    brandId?: true
    currentPrice?: true
    costPrice?: true
    isActive?: true
    validFrom?: true
    validTo?: true
    isCurrent?: true
    categoryName?: true
    brandName?: true
    supplier?: true
    tags?: true
    _all?: true
  }

  export type DimProductAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which DimProduct to aggregate.
     */
    where?: DimProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DimProducts to fetch.
     */
    orderBy?:
      | DimProductOrderByWithRelationInput
      | DimProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: DimProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DimProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DimProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned DimProducts
     **/
    _count?: true | DimProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: DimProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: DimProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: DimProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: DimProductMaxAggregateInputType
  }

  export type GetDimProductAggregateType<T extends DimProductAggregateArgs> = {
    [P in keyof T & keyof AggregateDimProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDimProduct[P]>
      : GetScalarType<T[P], AggregateDimProduct[P]>
  }

  export type DimProductGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: DimProductWhereInput
    orderBy?:
      | DimProductOrderByWithAggregationInput
      | DimProductOrderByWithAggregationInput[]
    by: DimProductScalarFieldEnum[] | DimProductScalarFieldEnum
    having?: DimProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DimProductCountAggregateInputType | true
    _avg?: DimProductAvgAggregateInputType
    _sum?: DimProductSumAggregateInputType
    _min?: DimProductMinAggregateInputType
    _max?: DimProductMaxAggregateInputType
  }

  export type DimProductGroupByOutputType = {
    productScId: bigint
    productId: bigint
    sku: string
    name: string
    categoryId: number | null
    brandId: number | null
    currentPrice: Decimal
    costPrice: Decimal | null
    isActive: boolean
    validFrom: Date
    validTo: Date | null
    isCurrent: boolean
    categoryName: string | null
    brandName: string | null
    supplier: string | null
    tags: string[]
    _count: DimProductCountAggregateOutputType | null
    _avg: DimProductAvgAggregateOutputType | null
    _sum: DimProductSumAggregateOutputType | null
    _min: DimProductMinAggregateOutputType | null
    _max: DimProductMaxAggregateOutputType | null
  }

  type GetDimProductGroupByPayload<T extends DimProductGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<DimProductGroupByOutputType, T['by']> & {
          [P in keyof T & keyof DimProductGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DimProductGroupByOutputType[P]>
            : GetScalarType<T[P], DimProductGroupByOutputType[P]>
        }
      >
    >

  export type DimProductSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      productScId?: boolean
      productId?: boolean
      sku?: boolean
      name?: boolean
      categoryId?: boolean
      brandId?: boolean
      currentPrice?: boolean
      costPrice?: boolean
      isActive?: boolean
      validFrom?: boolean
      validTo?: boolean
      isCurrent?: boolean
      categoryName?: boolean
      brandName?: boolean
      supplier?: boolean
      tags?: boolean
    },
    ExtArgs['result']['dimProduct']
  >

  export type DimProductSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      productScId?: boolean
      productId?: boolean
      sku?: boolean
      name?: boolean
      categoryId?: boolean
      brandId?: boolean
      currentPrice?: boolean
      costPrice?: boolean
      isActive?: boolean
      validFrom?: boolean
      validTo?: boolean
      isCurrent?: boolean
      categoryName?: boolean
      brandName?: boolean
      supplier?: boolean
      tags?: boolean
    },
    ExtArgs['result']['dimProduct']
  >

  export type DimProductSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      productScId?: boolean
      productId?: boolean
      sku?: boolean
      name?: boolean
      categoryId?: boolean
      brandId?: boolean
      currentPrice?: boolean
      costPrice?: boolean
      isActive?: boolean
      validFrom?: boolean
      validTo?: boolean
      isCurrent?: boolean
      categoryName?: boolean
      brandName?: boolean
      supplier?: boolean
      tags?: boolean
    },
    ExtArgs['result']['dimProduct']
  >

  export type DimProductSelectScalar = {
    productScId?: boolean
    productId?: boolean
    sku?: boolean
    name?: boolean
    categoryId?: boolean
    brandId?: boolean
    currentPrice?: boolean
    costPrice?: boolean
    isActive?: boolean
    validFrom?: boolean
    validTo?: boolean
    isCurrent?: boolean
    categoryName?: boolean
    brandName?: boolean
    supplier?: boolean
    tags?: boolean
  }

  export type DimProductOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'productScId'
    | 'productId'
    | 'sku'
    | 'name'
    | 'categoryId'
    | 'brandId'
    | 'currentPrice'
    | 'costPrice'
    | 'isActive'
    | 'validFrom'
    | 'validTo'
    | 'isCurrent'
    | 'categoryName'
    | 'brandName'
    | 'supplier'
    | 'tags',
    ExtArgs['result']['dimProduct']
  >

  export type $DimProductPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'DimProduct'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        productScId: bigint
        productId: bigint
        sku: string
        name: string
        categoryId: number | null
        brandId: number | null
        currentPrice: Prisma.Decimal
        costPrice: Prisma.Decimal | null
        isActive: boolean
        validFrom: Date
        validTo: Date | null
        isCurrent: boolean
        categoryName: string | null
        brandName: string | null
        supplier: string | null
        tags: string[]
      },
      ExtArgs['result']['dimProduct']
    >
    composites: {}
  }

  type DimProductGetPayload<
    S extends boolean | null | undefined | DimProductDefaultArgs,
  > = $Result.GetResult<Prisma.$DimProductPayload, S>

  type DimProductCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    DimProductFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: DimProductCountAggregateInputType | true
  }

  export interface DimProductDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['DimProduct']
      meta: { name: 'DimProduct' }
    }
    /**
     * Find zero or one DimProduct that matches the filter.
     * @param {DimProductFindUniqueArgs} args - Arguments to find a DimProduct
     * @example
     * // Get one DimProduct
     * const dimProduct = await prisma.dimProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DimProductFindUniqueArgs>(
      args: SelectSubset<T, DimProductFindUniqueArgs<ExtArgs>>
    ): Prisma__DimProductClient<
      $Result.GetResult<
        Prisma.$DimProductPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one DimProduct that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DimProductFindUniqueOrThrowArgs} args - Arguments to find a DimProduct
     * @example
     * // Get one DimProduct
     * const dimProduct = await prisma.dimProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DimProductFindUniqueOrThrowArgs>(
      args: SelectSubset<T, DimProductFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DimProductClient<
      $Result.GetResult<
        Prisma.$DimProductPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first DimProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimProductFindFirstArgs} args - Arguments to find a DimProduct
     * @example
     * // Get one DimProduct
     * const dimProduct = await prisma.dimProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DimProductFindFirstArgs>(
      args?: SelectSubset<T, DimProductFindFirstArgs<ExtArgs>>
    ): Prisma__DimProductClient<
      $Result.GetResult<
        Prisma.$DimProductPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first DimProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimProductFindFirstOrThrowArgs} args - Arguments to find a DimProduct
     * @example
     * // Get one DimProduct
     * const dimProduct = await prisma.dimProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DimProductFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DimProductFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DimProductClient<
      $Result.GetResult<
        Prisma.$DimProductPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more DimProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DimProducts
     * const dimProducts = await prisma.dimProduct.findMany()
     *
     * // Get first 10 DimProducts
     * const dimProducts = await prisma.dimProduct.findMany({ take: 10 })
     *
     * // Only select the `productScId`
     * const dimProductWithProductScIdOnly = await prisma.dimProduct.findMany({ select: { productScId: true } })
     *
     */
    findMany<T extends DimProductFindManyArgs>(
      args?: SelectSubset<T, DimProductFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DimProductPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a DimProduct.
     * @param {DimProductCreateArgs} args - Arguments to create a DimProduct.
     * @example
     * // Create one DimProduct
     * const DimProduct = await prisma.dimProduct.create({
     *   data: {
     *     // ... data to create a DimProduct
     *   }
     * })
     *
     */
    create<T extends DimProductCreateArgs>(
      args: SelectSubset<T, DimProductCreateArgs<ExtArgs>>
    ): Prisma__DimProductClient<
      $Result.GetResult<
        Prisma.$DimProductPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many DimProducts.
     * @param {DimProductCreateManyArgs} args - Arguments to create many DimProducts.
     * @example
     * // Create many DimProducts
     * const dimProduct = await prisma.dimProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends DimProductCreateManyArgs>(
      args?: SelectSubset<T, DimProductCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DimProducts and returns the data saved in the database.
     * @param {DimProductCreateManyAndReturnArgs} args - Arguments to create many DimProducts.
     * @example
     * // Create many DimProducts
     * const dimProduct = await prisma.dimProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many DimProducts and only return the `productScId`
     * const dimProductWithProductScIdOnly = await prisma.dimProduct.createManyAndReturn({
     *   select: { productScId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends DimProductCreateManyAndReturnArgs>(
      args?: SelectSubset<T, DimProductCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DimProductPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Delete a DimProduct.
     * @param {DimProductDeleteArgs} args - Arguments to delete one DimProduct.
     * @example
     * // Delete one DimProduct
     * const DimProduct = await prisma.dimProduct.delete({
     *   where: {
     *     // ... filter to delete one DimProduct
     *   }
     * })
     *
     */
    delete<T extends DimProductDeleteArgs>(
      args: SelectSubset<T, DimProductDeleteArgs<ExtArgs>>
    ): Prisma__DimProductClient<
      $Result.GetResult<
        Prisma.$DimProductPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one DimProduct.
     * @param {DimProductUpdateArgs} args - Arguments to update one DimProduct.
     * @example
     * // Update one DimProduct
     * const dimProduct = await prisma.dimProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends DimProductUpdateArgs>(
      args: SelectSubset<T, DimProductUpdateArgs<ExtArgs>>
    ): Prisma__DimProductClient<
      $Result.GetResult<
        Prisma.$DimProductPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more DimProducts.
     * @param {DimProductDeleteManyArgs} args - Arguments to filter DimProducts to delete.
     * @example
     * // Delete a few DimProducts
     * const { count } = await prisma.dimProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends DimProductDeleteManyArgs>(
      args?: SelectSubset<T, DimProductDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DimProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DimProducts
     * const dimProduct = await prisma.dimProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends DimProductUpdateManyArgs>(
      args: SelectSubset<T, DimProductUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DimProducts and returns the data updated in the database.
     * @param {DimProductUpdateManyAndReturnArgs} args - Arguments to update many DimProducts.
     * @example
     * // Update many DimProducts
     * const dimProduct = await prisma.dimProduct.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more DimProducts and only return the `productScId`
     * const dimProductWithProductScIdOnly = await prisma.dimProduct.updateManyAndReturn({
     *   select: { productScId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends DimProductUpdateManyAndReturnArgs>(
      args: SelectSubset<T, DimProductUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DimProductPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Create or update one DimProduct.
     * @param {DimProductUpsertArgs} args - Arguments to update or create a DimProduct.
     * @example
     * // Update or create a DimProduct
     * const dimProduct = await prisma.dimProduct.upsert({
     *   create: {
     *     // ... data to create a DimProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DimProduct we want to update
     *   }
     * })
     */
    upsert<T extends DimProductUpsertArgs>(
      args: SelectSubset<T, DimProductUpsertArgs<ExtArgs>>
    ): Prisma__DimProductClient<
      $Result.GetResult<
        Prisma.$DimProductPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of DimProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimProductCountArgs} args - Arguments to filter DimProducts to count.
     * @example
     * // Count the number of DimProducts
     * const count = await prisma.dimProduct.count({
     *   where: {
     *     // ... the filter for the DimProducts we want to count
     *   }
     * })
     **/
    count<T extends DimProductCountArgs>(
      args?: Subset<T, DimProductCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DimProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DimProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends DimProductAggregateArgs>(
      args: Subset<T, DimProductAggregateArgs>
    ): Prisma.PrismaPromise<GetDimProductAggregateType<T>>

    /**
     * Group by DimProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends DimProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DimProductGroupByArgs['orderBy'] }
        : { orderBy?: DimProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ]
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, DimProductGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetDimProductGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the DimProduct model
     */
    readonly fields: DimProductFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for DimProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DimProductClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the DimProduct model
   */
  interface DimProductFieldRefs {
    readonly productScId: FieldRef<'DimProduct', 'BigInt'>
    readonly productId: FieldRef<'DimProduct', 'BigInt'>
    readonly sku: FieldRef<'DimProduct', 'String'>
    readonly name: FieldRef<'DimProduct', 'String'>
    readonly categoryId: FieldRef<'DimProduct', 'Int'>
    readonly brandId: FieldRef<'DimProduct', 'Int'>
    readonly currentPrice: FieldRef<'DimProduct', 'Decimal'>
    readonly costPrice: FieldRef<'DimProduct', 'Decimal'>
    readonly isActive: FieldRef<'DimProduct', 'Boolean'>
    readonly validFrom: FieldRef<'DimProduct', 'DateTime'>
    readonly validTo: FieldRef<'DimProduct', 'DateTime'>
    readonly isCurrent: FieldRef<'DimProduct', 'Boolean'>
    readonly categoryName: FieldRef<'DimProduct', 'String'>
    readonly brandName: FieldRef<'DimProduct', 'String'>
    readonly supplier: FieldRef<'DimProduct', 'String'>
    readonly tags: FieldRef<'DimProduct', 'String[]'>
  }

  // Custom InputTypes
  /**
   * DimProduct findUnique
   */
  export type DimProductFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimProduct
     */
    select?: DimProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimProduct
     */
    omit?: DimProductOmit<ExtArgs> | null
    /**
     * Filter, which DimProduct to fetch.
     */
    where: DimProductWhereUniqueInput
  }

  /**
   * DimProduct findUniqueOrThrow
   */
  export type DimProductFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimProduct
     */
    select?: DimProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimProduct
     */
    omit?: DimProductOmit<ExtArgs> | null
    /**
     * Filter, which DimProduct to fetch.
     */
    where: DimProductWhereUniqueInput
  }

  /**
   * DimProduct findFirst
   */
  export type DimProductFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimProduct
     */
    select?: DimProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimProduct
     */
    omit?: DimProductOmit<ExtArgs> | null
    /**
     * Filter, which DimProduct to fetch.
     */
    where?: DimProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DimProducts to fetch.
     */
    orderBy?:
      | DimProductOrderByWithRelationInput
      | DimProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for DimProducts.
     */
    cursor?: DimProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DimProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DimProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of DimProducts.
     */
    distinct?: DimProductScalarFieldEnum | DimProductScalarFieldEnum[]
  }

  /**
   * DimProduct findFirstOrThrow
   */
  export type DimProductFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimProduct
     */
    select?: DimProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimProduct
     */
    omit?: DimProductOmit<ExtArgs> | null
    /**
     * Filter, which DimProduct to fetch.
     */
    where?: DimProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DimProducts to fetch.
     */
    orderBy?:
      | DimProductOrderByWithRelationInput
      | DimProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for DimProducts.
     */
    cursor?: DimProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DimProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DimProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of DimProducts.
     */
    distinct?: DimProductScalarFieldEnum | DimProductScalarFieldEnum[]
  }

  /**
   * DimProduct findMany
   */
  export type DimProductFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimProduct
     */
    select?: DimProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimProduct
     */
    omit?: DimProductOmit<ExtArgs> | null
    /**
     * Filter, which DimProducts to fetch.
     */
    where?: DimProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DimProducts to fetch.
     */
    orderBy?:
      | DimProductOrderByWithRelationInput
      | DimProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing DimProducts.
     */
    cursor?: DimProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DimProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DimProducts.
     */
    skip?: number
    distinct?: DimProductScalarFieldEnum | DimProductScalarFieldEnum[]
  }

  /**
   * DimProduct create
   */
  export type DimProductCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimProduct
     */
    select?: DimProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimProduct
     */
    omit?: DimProductOmit<ExtArgs> | null
    /**
     * The data needed to create a DimProduct.
     */
    data: XOR<DimProductCreateInput, DimProductUncheckedCreateInput>
  }

  /**
   * DimProduct createMany
   */
  export type DimProductCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many DimProducts.
     */
    data: DimProductCreateManyInput | DimProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DimProduct createManyAndReturn
   */
  export type DimProductCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimProduct
     */
    select?: DimProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DimProduct
     */
    omit?: DimProductOmit<ExtArgs> | null
    /**
     * The data used to create many DimProducts.
     */
    data: DimProductCreateManyInput | DimProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DimProduct update
   */
  export type DimProductUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimProduct
     */
    select?: DimProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimProduct
     */
    omit?: DimProductOmit<ExtArgs> | null
    /**
     * The data needed to update a DimProduct.
     */
    data: XOR<DimProductUpdateInput, DimProductUncheckedUpdateInput>
    /**
     * Choose, which DimProduct to update.
     */
    where: DimProductWhereUniqueInput
  }

  /**
   * DimProduct updateMany
   */
  export type DimProductUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update DimProducts.
     */
    data: XOR<
      DimProductUpdateManyMutationInput,
      DimProductUncheckedUpdateManyInput
    >
    /**
     * Filter which DimProducts to update
     */
    where?: DimProductWhereInput
    /**
     * Limit how many DimProducts to update.
     */
    limit?: number
  }

  /**
   * DimProduct updateManyAndReturn
   */
  export type DimProductUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimProduct
     */
    select?: DimProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DimProduct
     */
    omit?: DimProductOmit<ExtArgs> | null
    /**
     * The data used to update DimProducts.
     */
    data: XOR<
      DimProductUpdateManyMutationInput,
      DimProductUncheckedUpdateManyInput
    >
    /**
     * Filter which DimProducts to update
     */
    where?: DimProductWhereInput
    /**
     * Limit how many DimProducts to update.
     */
    limit?: number
  }

  /**
   * DimProduct upsert
   */
  export type DimProductUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimProduct
     */
    select?: DimProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimProduct
     */
    omit?: DimProductOmit<ExtArgs> | null
    /**
     * The filter to search for the DimProduct to update in case it exists.
     */
    where: DimProductWhereUniqueInput
    /**
     * In case the DimProduct found by the `where` argument doesn't exist, create a new DimProduct with this data.
     */
    create: XOR<DimProductCreateInput, DimProductUncheckedCreateInput>
    /**
     * In case the DimProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DimProductUpdateInput, DimProductUncheckedUpdateInput>
  }

  /**
   * DimProduct delete
   */
  export type DimProductDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimProduct
     */
    select?: DimProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimProduct
     */
    omit?: DimProductOmit<ExtArgs> | null
    /**
     * Filter which DimProduct to delete.
     */
    where: DimProductWhereUniqueInput
  }

  /**
   * DimProduct deleteMany
   */
  export type DimProductDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which DimProducts to delete
     */
    where?: DimProductWhereInput
    /**
     * Limit how many DimProducts to delete.
     */
    limit?: number
  }

  /**
   * DimProduct without action
   */
  export type DimProductDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimProduct
     */
    select?: DimProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimProduct
     */
    omit?: DimProductOmit<ExtArgs> | null
  }

  /**
   * Model DimUser
   */

  export type AggregateDimUser = {
    _count: DimUserCountAggregateOutputType | null
    _avg: DimUserAvgAggregateOutputType | null
    _sum: DimUserSumAggregateOutputType | null
    _min: DimUserMinAggregateOutputType | null
    _max: DimUserMaxAggregateOutputType | null
  }

  export type DimUserAvgAggregateOutputType = {
    userScId: number | null
    userId: number | null
    ltv: Decimal | null
  }

  export type DimUserSumAggregateOutputType = {
    userScId: bigint | null
    userId: bigint | null
    ltv: Decimal | null
  }

  export type DimUserMinAggregateOutputType = {
    userScId: bigint | null
    userId: bigint | null
    email: string | null
    city: string | null
    country: string | null
    gender: string | null
    ageGroup: string | null
    segment: string | null
    ltv: Decimal | null
    firstOrderDate: Date | null
    validFrom: Date | null
    validTo: Date | null
    isCurrent: boolean | null
  }

  export type DimUserMaxAggregateOutputType = {
    userScId: bigint | null
    userId: bigint | null
    email: string | null
    city: string | null
    country: string | null
    gender: string | null
    ageGroup: string | null
    segment: string | null
    ltv: Decimal | null
    firstOrderDate: Date | null
    validFrom: Date | null
    validTo: Date | null
    isCurrent: boolean | null
  }

  export type DimUserCountAggregateOutputType = {
    userScId: number
    userId: number
    email: number
    city: number
    country: number
    gender: number
    ageGroup: number
    segment: number
    ltv: number
    firstOrderDate: number
    validFrom: number
    validTo: number
    isCurrent: number
    _all: number
  }

  export type DimUserAvgAggregateInputType = {
    userScId?: true
    userId?: true
    ltv?: true
  }

  export type DimUserSumAggregateInputType = {
    userScId?: true
    userId?: true
    ltv?: true
  }

  export type DimUserMinAggregateInputType = {
    userScId?: true
    userId?: true
    email?: true
    city?: true
    country?: true
    gender?: true
    ageGroup?: true
    segment?: true
    ltv?: true
    firstOrderDate?: true
    validFrom?: true
    validTo?: true
    isCurrent?: true
  }

  export type DimUserMaxAggregateInputType = {
    userScId?: true
    userId?: true
    email?: true
    city?: true
    country?: true
    gender?: true
    ageGroup?: true
    segment?: true
    ltv?: true
    firstOrderDate?: true
    validFrom?: true
    validTo?: true
    isCurrent?: true
  }

  export type DimUserCountAggregateInputType = {
    userScId?: true
    userId?: true
    email?: true
    city?: true
    country?: true
    gender?: true
    ageGroup?: true
    segment?: true
    ltv?: true
    firstOrderDate?: true
    validFrom?: true
    validTo?: true
    isCurrent?: true
    _all?: true
  }

  export type DimUserAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which DimUser to aggregate.
     */
    where?: DimUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DimUsers to fetch.
     */
    orderBy?:
      | DimUserOrderByWithRelationInput
      | DimUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: DimUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DimUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DimUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned DimUsers
     **/
    _count?: true | DimUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: DimUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: DimUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: DimUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: DimUserMaxAggregateInputType
  }

  export type GetDimUserAggregateType<T extends DimUserAggregateArgs> = {
    [P in keyof T & keyof AggregateDimUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDimUser[P]>
      : GetScalarType<T[P], AggregateDimUser[P]>
  }

  export type DimUserGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: DimUserWhereInput
    orderBy?:
      | DimUserOrderByWithAggregationInput
      | DimUserOrderByWithAggregationInput[]
    by: DimUserScalarFieldEnum[] | DimUserScalarFieldEnum
    having?: DimUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DimUserCountAggregateInputType | true
    _avg?: DimUserAvgAggregateInputType
    _sum?: DimUserSumAggregateInputType
    _min?: DimUserMinAggregateInputType
    _max?: DimUserMaxAggregateInputType
  }

  export type DimUserGroupByOutputType = {
    userScId: bigint
    userId: bigint
    email: string | null
    city: string | null
    country: string | null
    gender: string | null
    ageGroup: string | null
    segment: string | null
    ltv: Decimal | null
    firstOrderDate: Date | null
    validFrom: Date
    validTo: Date | null
    isCurrent: boolean
    _count: DimUserCountAggregateOutputType | null
    _avg: DimUserAvgAggregateOutputType | null
    _sum: DimUserSumAggregateOutputType | null
    _min: DimUserMinAggregateOutputType | null
    _max: DimUserMaxAggregateOutputType | null
  }

  type GetDimUserGroupByPayload<T extends DimUserGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<DimUserGroupByOutputType, T['by']> & {
          [P in keyof T & keyof DimUserGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DimUserGroupByOutputType[P]>
            : GetScalarType<T[P], DimUserGroupByOutputType[P]>
        }
      >
    >

  export type DimUserSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      userScId?: boolean
      userId?: boolean
      email?: boolean
      city?: boolean
      country?: boolean
      gender?: boolean
      ageGroup?: boolean
      segment?: boolean
      ltv?: boolean
      firstOrderDate?: boolean
      validFrom?: boolean
      validTo?: boolean
      isCurrent?: boolean
    },
    ExtArgs['result']['dimUser']
  >

  export type DimUserSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      userScId?: boolean
      userId?: boolean
      email?: boolean
      city?: boolean
      country?: boolean
      gender?: boolean
      ageGroup?: boolean
      segment?: boolean
      ltv?: boolean
      firstOrderDate?: boolean
      validFrom?: boolean
      validTo?: boolean
      isCurrent?: boolean
    },
    ExtArgs['result']['dimUser']
  >

  export type DimUserSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      userScId?: boolean
      userId?: boolean
      email?: boolean
      city?: boolean
      country?: boolean
      gender?: boolean
      ageGroup?: boolean
      segment?: boolean
      ltv?: boolean
      firstOrderDate?: boolean
      validFrom?: boolean
      validTo?: boolean
      isCurrent?: boolean
    },
    ExtArgs['result']['dimUser']
  >

  export type DimUserSelectScalar = {
    userScId?: boolean
    userId?: boolean
    email?: boolean
    city?: boolean
    country?: boolean
    gender?: boolean
    ageGroup?: boolean
    segment?: boolean
    ltv?: boolean
    firstOrderDate?: boolean
    validFrom?: boolean
    validTo?: boolean
    isCurrent?: boolean
  }

  export type DimUserOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'userScId'
    | 'userId'
    | 'email'
    | 'city'
    | 'country'
    | 'gender'
    | 'ageGroup'
    | 'segment'
    | 'ltv'
    | 'firstOrderDate'
    | 'validFrom'
    | 'validTo'
    | 'isCurrent',
    ExtArgs['result']['dimUser']
  >

  export type $DimUserPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'DimUser'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        userScId: bigint
        userId: bigint
        email: string | null
        city: string | null
        country: string | null
        gender: string | null
        ageGroup: string | null
        segment: string | null
        ltv: Prisma.Decimal | null
        firstOrderDate: Date | null
        validFrom: Date
        validTo: Date | null
        isCurrent: boolean
      },
      ExtArgs['result']['dimUser']
    >
    composites: {}
  }

  type DimUserGetPayload<
    S extends boolean | null | undefined | DimUserDefaultArgs,
  > = $Result.GetResult<Prisma.$DimUserPayload, S>

  type DimUserCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<DimUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: DimUserCountAggregateInputType | true
  }

  export interface DimUserDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['DimUser']
      meta: { name: 'DimUser' }
    }
    /**
     * Find zero or one DimUser that matches the filter.
     * @param {DimUserFindUniqueArgs} args - Arguments to find a DimUser
     * @example
     * // Get one DimUser
     * const dimUser = await prisma.dimUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DimUserFindUniqueArgs>(
      args: SelectSubset<T, DimUserFindUniqueArgs<ExtArgs>>
    ): Prisma__DimUserClient<
      $Result.GetResult<
        Prisma.$DimUserPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one DimUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DimUserFindUniqueOrThrowArgs} args - Arguments to find a DimUser
     * @example
     * // Get one DimUser
     * const dimUser = await prisma.dimUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DimUserFindUniqueOrThrowArgs>(
      args: SelectSubset<T, DimUserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DimUserClient<
      $Result.GetResult<
        Prisma.$DimUserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first DimUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimUserFindFirstArgs} args - Arguments to find a DimUser
     * @example
     * // Get one DimUser
     * const dimUser = await prisma.dimUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DimUserFindFirstArgs>(
      args?: SelectSubset<T, DimUserFindFirstArgs<ExtArgs>>
    ): Prisma__DimUserClient<
      $Result.GetResult<
        Prisma.$DimUserPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first DimUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimUserFindFirstOrThrowArgs} args - Arguments to find a DimUser
     * @example
     * // Get one DimUser
     * const dimUser = await prisma.dimUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DimUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DimUserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DimUserClient<
      $Result.GetResult<
        Prisma.$DimUserPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more DimUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DimUsers
     * const dimUsers = await prisma.dimUser.findMany()
     *
     * // Get first 10 DimUsers
     * const dimUsers = await prisma.dimUser.findMany({ take: 10 })
     *
     * // Only select the `userScId`
     * const dimUserWithUserScIdOnly = await prisma.dimUser.findMany({ select: { userScId: true } })
     *
     */
    findMany<T extends DimUserFindManyArgs>(
      args?: SelectSubset<T, DimUserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DimUserPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a DimUser.
     * @param {DimUserCreateArgs} args - Arguments to create a DimUser.
     * @example
     * // Create one DimUser
     * const DimUser = await prisma.dimUser.create({
     *   data: {
     *     // ... data to create a DimUser
     *   }
     * })
     *
     */
    create<T extends DimUserCreateArgs>(
      args: SelectSubset<T, DimUserCreateArgs<ExtArgs>>
    ): Prisma__DimUserClient<
      $Result.GetResult<
        Prisma.$DimUserPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many DimUsers.
     * @param {DimUserCreateManyArgs} args - Arguments to create many DimUsers.
     * @example
     * // Create many DimUsers
     * const dimUser = await prisma.dimUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends DimUserCreateManyArgs>(
      args?: SelectSubset<T, DimUserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DimUsers and returns the data saved in the database.
     * @param {DimUserCreateManyAndReturnArgs} args - Arguments to create many DimUsers.
     * @example
     * // Create many DimUsers
     * const dimUser = await prisma.dimUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many DimUsers and only return the `userScId`
     * const dimUserWithUserScIdOnly = await prisma.dimUser.createManyAndReturn({
     *   select: { userScId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends DimUserCreateManyAndReturnArgs>(
      args?: SelectSubset<T, DimUserCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DimUserPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Delete a DimUser.
     * @param {DimUserDeleteArgs} args - Arguments to delete one DimUser.
     * @example
     * // Delete one DimUser
     * const DimUser = await prisma.dimUser.delete({
     *   where: {
     *     // ... filter to delete one DimUser
     *   }
     * })
     *
     */
    delete<T extends DimUserDeleteArgs>(
      args: SelectSubset<T, DimUserDeleteArgs<ExtArgs>>
    ): Prisma__DimUserClient<
      $Result.GetResult<
        Prisma.$DimUserPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one DimUser.
     * @param {DimUserUpdateArgs} args - Arguments to update one DimUser.
     * @example
     * // Update one DimUser
     * const dimUser = await prisma.dimUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends DimUserUpdateArgs>(
      args: SelectSubset<T, DimUserUpdateArgs<ExtArgs>>
    ): Prisma__DimUserClient<
      $Result.GetResult<
        Prisma.$DimUserPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more DimUsers.
     * @param {DimUserDeleteManyArgs} args - Arguments to filter DimUsers to delete.
     * @example
     * // Delete a few DimUsers
     * const { count } = await prisma.dimUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends DimUserDeleteManyArgs>(
      args?: SelectSubset<T, DimUserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DimUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DimUsers
     * const dimUser = await prisma.dimUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends DimUserUpdateManyArgs>(
      args: SelectSubset<T, DimUserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DimUsers and returns the data updated in the database.
     * @param {DimUserUpdateManyAndReturnArgs} args - Arguments to update many DimUsers.
     * @example
     * // Update many DimUsers
     * const dimUser = await prisma.dimUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more DimUsers and only return the `userScId`
     * const dimUserWithUserScIdOnly = await prisma.dimUser.updateManyAndReturn({
     *   select: { userScId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends DimUserUpdateManyAndReturnArgs>(
      args: SelectSubset<T, DimUserUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DimUserPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Create or update one DimUser.
     * @param {DimUserUpsertArgs} args - Arguments to update or create a DimUser.
     * @example
     * // Update or create a DimUser
     * const dimUser = await prisma.dimUser.upsert({
     *   create: {
     *     // ... data to create a DimUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DimUser we want to update
     *   }
     * })
     */
    upsert<T extends DimUserUpsertArgs>(
      args: SelectSubset<T, DimUserUpsertArgs<ExtArgs>>
    ): Prisma__DimUserClient<
      $Result.GetResult<
        Prisma.$DimUserPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of DimUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimUserCountArgs} args - Arguments to filter DimUsers to count.
     * @example
     * // Count the number of DimUsers
     * const count = await prisma.dimUser.count({
     *   where: {
     *     // ... the filter for the DimUsers we want to count
     *   }
     * })
     **/
    count<T extends DimUserCountArgs>(
      args?: Subset<T, DimUserCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DimUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DimUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends DimUserAggregateArgs>(
      args: Subset<T, DimUserAggregateArgs>
    ): Prisma.PrismaPromise<GetDimUserAggregateType<T>>

    /**
     * Group by DimUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends DimUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DimUserGroupByArgs['orderBy'] }
        : { orderBy?: DimUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ]
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, DimUserGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetDimUserGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the DimUser model
     */
    readonly fields: DimUserFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for DimUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DimUserClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the DimUser model
   */
  interface DimUserFieldRefs {
    readonly userScId: FieldRef<'DimUser', 'BigInt'>
    readonly userId: FieldRef<'DimUser', 'BigInt'>
    readonly email: FieldRef<'DimUser', 'String'>
    readonly city: FieldRef<'DimUser', 'String'>
    readonly country: FieldRef<'DimUser', 'String'>
    readonly gender: FieldRef<'DimUser', 'String'>
    readonly ageGroup: FieldRef<'DimUser', 'String'>
    readonly segment: FieldRef<'DimUser', 'String'>
    readonly ltv: FieldRef<'DimUser', 'Decimal'>
    readonly firstOrderDate: FieldRef<'DimUser', 'DateTime'>
    readonly validFrom: FieldRef<'DimUser', 'DateTime'>
    readonly validTo: FieldRef<'DimUser', 'DateTime'>
    readonly isCurrent: FieldRef<'DimUser', 'Boolean'>
  }

  // Custom InputTypes
  /**
   * DimUser findUnique
   */
  export type DimUserFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimUser
     */
    select?: DimUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimUser
     */
    omit?: DimUserOmit<ExtArgs> | null
    /**
     * Filter, which DimUser to fetch.
     */
    where: DimUserWhereUniqueInput
  }

  /**
   * DimUser findUniqueOrThrow
   */
  export type DimUserFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimUser
     */
    select?: DimUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimUser
     */
    omit?: DimUserOmit<ExtArgs> | null
    /**
     * Filter, which DimUser to fetch.
     */
    where: DimUserWhereUniqueInput
  }

  /**
   * DimUser findFirst
   */
  export type DimUserFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimUser
     */
    select?: DimUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimUser
     */
    omit?: DimUserOmit<ExtArgs> | null
    /**
     * Filter, which DimUser to fetch.
     */
    where?: DimUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DimUsers to fetch.
     */
    orderBy?:
      | DimUserOrderByWithRelationInput
      | DimUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for DimUsers.
     */
    cursor?: DimUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DimUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DimUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of DimUsers.
     */
    distinct?: DimUserScalarFieldEnum | DimUserScalarFieldEnum[]
  }

  /**
   * DimUser findFirstOrThrow
   */
  export type DimUserFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimUser
     */
    select?: DimUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimUser
     */
    omit?: DimUserOmit<ExtArgs> | null
    /**
     * Filter, which DimUser to fetch.
     */
    where?: DimUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DimUsers to fetch.
     */
    orderBy?:
      | DimUserOrderByWithRelationInput
      | DimUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for DimUsers.
     */
    cursor?: DimUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DimUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DimUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of DimUsers.
     */
    distinct?: DimUserScalarFieldEnum | DimUserScalarFieldEnum[]
  }

  /**
   * DimUser findMany
   */
  export type DimUserFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimUser
     */
    select?: DimUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimUser
     */
    omit?: DimUserOmit<ExtArgs> | null
    /**
     * Filter, which DimUsers to fetch.
     */
    where?: DimUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DimUsers to fetch.
     */
    orderBy?:
      | DimUserOrderByWithRelationInput
      | DimUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing DimUsers.
     */
    cursor?: DimUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DimUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DimUsers.
     */
    skip?: number
    distinct?: DimUserScalarFieldEnum | DimUserScalarFieldEnum[]
  }

  /**
   * DimUser create
   */
  export type DimUserCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimUser
     */
    select?: DimUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimUser
     */
    omit?: DimUserOmit<ExtArgs> | null
    /**
     * The data needed to create a DimUser.
     */
    data: XOR<DimUserCreateInput, DimUserUncheckedCreateInput>
  }

  /**
   * DimUser createMany
   */
  export type DimUserCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many DimUsers.
     */
    data: DimUserCreateManyInput | DimUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DimUser createManyAndReturn
   */
  export type DimUserCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimUser
     */
    select?: DimUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DimUser
     */
    omit?: DimUserOmit<ExtArgs> | null
    /**
     * The data used to create many DimUsers.
     */
    data: DimUserCreateManyInput | DimUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DimUser update
   */
  export type DimUserUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimUser
     */
    select?: DimUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimUser
     */
    omit?: DimUserOmit<ExtArgs> | null
    /**
     * The data needed to update a DimUser.
     */
    data: XOR<DimUserUpdateInput, DimUserUncheckedUpdateInput>
    /**
     * Choose, which DimUser to update.
     */
    where: DimUserWhereUniqueInput
  }

  /**
   * DimUser updateMany
   */
  export type DimUserUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update DimUsers.
     */
    data: XOR<DimUserUpdateManyMutationInput, DimUserUncheckedUpdateManyInput>
    /**
     * Filter which DimUsers to update
     */
    where?: DimUserWhereInput
    /**
     * Limit how many DimUsers to update.
     */
    limit?: number
  }

  /**
   * DimUser updateManyAndReturn
   */
  export type DimUserUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimUser
     */
    select?: DimUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DimUser
     */
    omit?: DimUserOmit<ExtArgs> | null
    /**
     * The data used to update DimUsers.
     */
    data: XOR<DimUserUpdateManyMutationInput, DimUserUncheckedUpdateManyInput>
    /**
     * Filter which DimUsers to update
     */
    where?: DimUserWhereInput
    /**
     * Limit how many DimUsers to update.
     */
    limit?: number
  }

  /**
   * DimUser upsert
   */
  export type DimUserUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimUser
     */
    select?: DimUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimUser
     */
    omit?: DimUserOmit<ExtArgs> | null
    /**
     * The filter to search for the DimUser to update in case it exists.
     */
    where: DimUserWhereUniqueInput
    /**
     * In case the DimUser found by the `where` argument doesn't exist, create a new DimUser with this data.
     */
    create: XOR<DimUserCreateInput, DimUserUncheckedCreateInput>
    /**
     * In case the DimUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DimUserUpdateInput, DimUserUncheckedUpdateInput>
  }

  /**
   * DimUser delete
   */
  export type DimUserDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimUser
     */
    select?: DimUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimUser
     */
    omit?: DimUserOmit<ExtArgs> | null
    /**
     * Filter which DimUser to delete.
     */
    where: DimUserWhereUniqueInput
  }

  /**
   * DimUser deleteMany
   */
  export type DimUserDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which DimUsers to delete
     */
    where?: DimUserWhereInput
    /**
     * Limit how many DimUsers to delete.
     */
    limit?: number
  }

  /**
   * DimUser without action
   */
  export type DimUserDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimUser
     */
    select?: DimUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimUser
     */
    omit?: DimUserOmit<ExtArgs> | null
  }

  /**
   * Model DimDate
   */

  export type AggregateDimDate = {
    _count: DimDateCountAggregateOutputType | null
    _avg: DimDateAvgAggregateOutputType | null
    _sum: DimDateSumAggregateOutputType | null
    _min: DimDateMinAggregateOutputType | null
    _max: DimDateMaxAggregateOutputType | null
  }

  export type DimDateAvgAggregateOutputType = {
    dateId: number | null
    dayOfWeek: number | null
    dayOfMonth: number | null
    weekOfYear: number | null
    month: number | null
    quarter: number | null
    year: number | null
    fiscalYear: number | null
    fiscalPeriod: number | null
  }

  export type DimDateSumAggregateOutputType = {
    dateId: number | null
    dayOfWeek: number | null
    dayOfMonth: number | null
    weekOfYear: number | null
    month: number | null
    quarter: number | null
    year: number | null
    fiscalYear: number | null
    fiscalPeriod: number | null
  }

  export type DimDateMinAggregateOutputType = {
    dateId: number | null
    date: Date | null
    dayOfWeek: number | null
    dayName: string | null
    dayOfMonth: number | null
    weekOfYear: number | null
    month: number | null
    monthName: string | null
    quarter: number | null
    year: number | null
    isWeekend: boolean | null
    isHoliday: boolean | null
    fiscalYear: number | null
    fiscalPeriod: number | null
  }

  export type DimDateMaxAggregateOutputType = {
    dateId: number | null
    date: Date | null
    dayOfWeek: number | null
    dayName: string | null
    dayOfMonth: number | null
    weekOfYear: number | null
    month: number | null
    monthName: string | null
    quarter: number | null
    year: number | null
    isWeekend: boolean | null
    isHoliday: boolean | null
    fiscalYear: number | null
    fiscalPeriod: number | null
  }

  export type DimDateCountAggregateOutputType = {
    dateId: number
    date: number
    dayOfWeek: number
    dayName: number
    dayOfMonth: number
    weekOfYear: number
    month: number
    monthName: number
    quarter: number
    year: number
    isWeekend: number
    isHoliday: number
    fiscalYear: number
    fiscalPeriod: number
    _all: number
  }

  export type DimDateAvgAggregateInputType = {
    dateId?: true
    dayOfWeek?: true
    dayOfMonth?: true
    weekOfYear?: true
    month?: true
    quarter?: true
    year?: true
    fiscalYear?: true
    fiscalPeriod?: true
  }

  export type DimDateSumAggregateInputType = {
    dateId?: true
    dayOfWeek?: true
    dayOfMonth?: true
    weekOfYear?: true
    month?: true
    quarter?: true
    year?: true
    fiscalYear?: true
    fiscalPeriod?: true
  }

  export type DimDateMinAggregateInputType = {
    dateId?: true
    date?: true
    dayOfWeek?: true
    dayName?: true
    dayOfMonth?: true
    weekOfYear?: true
    month?: true
    monthName?: true
    quarter?: true
    year?: true
    isWeekend?: true
    isHoliday?: true
    fiscalYear?: true
    fiscalPeriod?: true
  }

  export type DimDateMaxAggregateInputType = {
    dateId?: true
    date?: true
    dayOfWeek?: true
    dayName?: true
    dayOfMonth?: true
    weekOfYear?: true
    month?: true
    monthName?: true
    quarter?: true
    year?: true
    isWeekend?: true
    isHoliday?: true
    fiscalYear?: true
    fiscalPeriod?: true
  }

  export type DimDateCountAggregateInputType = {
    dateId?: true
    date?: true
    dayOfWeek?: true
    dayName?: true
    dayOfMonth?: true
    weekOfYear?: true
    month?: true
    monthName?: true
    quarter?: true
    year?: true
    isWeekend?: true
    isHoliday?: true
    fiscalYear?: true
    fiscalPeriod?: true
    _all?: true
  }

  export type DimDateAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which DimDate to aggregate.
     */
    where?: DimDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DimDates to fetch.
     */
    orderBy?:
      | DimDateOrderByWithRelationInput
      | DimDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: DimDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DimDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DimDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned DimDates
     **/
    _count?: true | DimDateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: DimDateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: DimDateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: DimDateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: DimDateMaxAggregateInputType
  }

  export type GetDimDateAggregateType<T extends DimDateAggregateArgs> = {
    [P in keyof T & keyof AggregateDimDate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDimDate[P]>
      : GetScalarType<T[P], AggregateDimDate[P]>
  }

  export type DimDateGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: DimDateWhereInput
    orderBy?:
      | DimDateOrderByWithAggregationInput
      | DimDateOrderByWithAggregationInput[]
    by: DimDateScalarFieldEnum[] | DimDateScalarFieldEnum
    having?: DimDateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DimDateCountAggregateInputType | true
    _avg?: DimDateAvgAggregateInputType
    _sum?: DimDateSumAggregateInputType
    _min?: DimDateMinAggregateInputType
    _max?: DimDateMaxAggregateInputType
  }

  export type DimDateGroupByOutputType = {
    dateId: number
    date: Date
    dayOfWeek: number
    dayName: string
    dayOfMonth: number
    weekOfYear: number
    month: number
    monthName: string
    quarter: number
    year: number
    isWeekend: boolean
    isHoliday: boolean
    fiscalYear: number | null
    fiscalPeriod: number | null
    _count: DimDateCountAggregateOutputType | null
    _avg: DimDateAvgAggregateOutputType | null
    _sum: DimDateSumAggregateOutputType | null
    _min: DimDateMinAggregateOutputType | null
    _max: DimDateMaxAggregateOutputType | null
  }

  type GetDimDateGroupByPayload<T extends DimDateGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<DimDateGroupByOutputType, T['by']> & {
          [P in keyof T & keyof DimDateGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DimDateGroupByOutputType[P]>
            : GetScalarType<T[P], DimDateGroupByOutputType[P]>
        }
      >
    >

  export type DimDateSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      dateId?: boolean
      date?: boolean
      dayOfWeek?: boolean
      dayName?: boolean
      dayOfMonth?: boolean
      weekOfYear?: boolean
      month?: boolean
      monthName?: boolean
      quarter?: boolean
      year?: boolean
      isWeekend?: boolean
      isHoliday?: boolean
      fiscalYear?: boolean
      fiscalPeriod?: boolean
    },
    ExtArgs['result']['dimDate']
  >

  export type DimDateSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      dateId?: boolean
      date?: boolean
      dayOfWeek?: boolean
      dayName?: boolean
      dayOfMonth?: boolean
      weekOfYear?: boolean
      month?: boolean
      monthName?: boolean
      quarter?: boolean
      year?: boolean
      isWeekend?: boolean
      isHoliday?: boolean
      fiscalYear?: boolean
      fiscalPeriod?: boolean
    },
    ExtArgs['result']['dimDate']
  >

  export type DimDateSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      dateId?: boolean
      date?: boolean
      dayOfWeek?: boolean
      dayName?: boolean
      dayOfMonth?: boolean
      weekOfYear?: boolean
      month?: boolean
      monthName?: boolean
      quarter?: boolean
      year?: boolean
      isWeekend?: boolean
      isHoliday?: boolean
      fiscalYear?: boolean
      fiscalPeriod?: boolean
    },
    ExtArgs['result']['dimDate']
  >

  export type DimDateSelectScalar = {
    dateId?: boolean
    date?: boolean
    dayOfWeek?: boolean
    dayName?: boolean
    dayOfMonth?: boolean
    weekOfYear?: boolean
    month?: boolean
    monthName?: boolean
    quarter?: boolean
    year?: boolean
    isWeekend?: boolean
    isHoliday?: boolean
    fiscalYear?: boolean
    fiscalPeriod?: boolean
  }

  export type DimDateOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'dateId'
    | 'date'
    | 'dayOfWeek'
    | 'dayName'
    | 'dayOfMonth'
    | 'weekOfYear'
    | 'month'
    | 'monthName'
    | 'quarter'
    | 'year'
    | 'isWeekend'
    | 'isHoliday'
    | 'fiscalYear'
    | 'fiscalPeriod',
    ExtArgs['result']['dimDate']
  >

  export type $DimDatePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'DimDate'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        dateId: number
        date: Date
        dayOfWeek: number
        dayName: string
        dayOfMonth: number
        weekOfYear: number
        month: number
        monthName: string
        quarter: number
        year: number
        isWeekend: boolean
        isHoliday: boolean
        fiscalYear: number | null
        fiscalPeriod: number | null
      },
      ExtArgs['result']['dimDate']
    >
    composites: {}
  }

  type DimDateGetPayload<
    S extends boolean | null | undefined | DimDateDefaultArgs,
  > = $Result.GetResult<Prisma.$DimDatePayload, S>

  type DimDateCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<DimDateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: DimDateCountAggregateInputType | true
  }

  export interface DimDateDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['DimDate']
      meta: { name: 'DimDate' }
    }
    /**
     * Find zero or one DimDate that matches the filter.
     * @param {DimDateFindUniqueArgs} args - Arguments to find a DimDate
     * @example
     * // Get one DimDate
     * const dimDate = await prisma.dimDate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DimDateFindUniqueArgs>(
      args: SelectSubset<T, DimDateFindUniqueArgs<ExtArgs>>
    ): Prisma__DimDateClient<
      $Result.GetResult<
        Prisma.$DimDatePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one DimDate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DimDateFindUniqueOrThrowArgs} args - Arguments to find a DimDate
     * @example
     * // Get one DimDate
     * const dimDate = await prisma.dimDate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DimDateFindUniqueOrThrowArgs>(
      args: SelectSubset<T, DimDateFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DimDateClient<
      $Result.GetResult<
        Prisma.$DimDatePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first DimDate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimDateFindFirstArgs} args - Arguments to find a DimDate
     * @example
     * // Get one DimDate
     * const dimDate = await prisma.dimDate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DimDateFindFirstArgs>(
      args?: SelectSubset<T, DimDateFindFirstArgs<ExtArgs>>
    ): Prisma__DimDateClient<
      $Result.GetResult<
        Prisma.$DimDatePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first DimDate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimDateFindFirstOrThrowArgs} args - Arguments to find a DimDate
     * @example
     * // Get one DimDate
     * const dimDate = await prisma.dimDate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DimDateFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DimDateFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DimDateClient<
      $Result.GetResult<
        Prisma.$DimDatePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more DimDates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimDateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DimDates
     * const dimDates = await prisma.dimDate.findMany()
     *
     * // Get first 10 DimDates
     * const dimDates = await prisma.dimDate.findMany({ take: 10 })
     *
     * // Only select the `dateId`
     * const dimDateWithDateIdOnly = await prisma.dimDate.findMany({ select: { dateId: true } })
     *
     */
    findMany<T extends DimDateFindManyArgs>(
      args?: SelectSubset<T, DimDateFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DimDatePayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a DimDate.
     * @param {DimDateCreateArgs} args - Arguments to create a DimDate.
     * @example
     * // Create one DimDate
     * const DimDate = await prisma.dimDate.create({
     *   data: {
     *     // ... data to create a DimDate
     *   }
     * })
     *
     */
    create<T extends DimDateCreateArgs>(
      args: SelectSubset<T, DimDateCreateArgs<ExtArgs>>
    ): Prisma__DimDateClient<
      $Result.GetResult<
        Prisma.$DimDatePayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many DimDates.
     * @param {DimDateCreateManyArgs} args - Arguments to create many DimDates.
     * @example
     * // Create many DimDates
     * const dimDate = await prisma.dimDate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends DimDateCreateManyArgs>(
      args?: SelectSubset<T, DimDateCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DimDates and returns the data saved in the database.
     * @param {DimDateCreateManyAndReturnArgs} args - Arguments to create many DimDates.
     * @example
     * // Create many DimDates
     * const dimDate = await prisma.dimDate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many DimDates and only return the `dateId`
     * const dimDateWithDateIdOnly = await prisma.dimDate.createManyAndReturn({
     *   select: { dateId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends DimDateCreateManyAndReturnArgs>(
      args?: SelectSubset<T, DimDateCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DimDatePayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Delete a DimDate.
     * @param {DimDateDeleteArgs} args - Arguments to delete one DimDate.
     * @example
     * // Delete one DimDate
     * const DimDate = await prisma.dimDate.delete({
     *   where: {
     *     // ... filter to delete one DimDate
     *   }
     * })
     *
     */
    delete<T extends DimDateDeleteArgs>(
      args: SelectSubset<T, DimDateDeleteArgs<ExtArgs>>
    ): Prisma__DimDateClient<
      $Result.GetResult<
        Prisma.$DimDatePayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one DimDate.
     * @param {DimDateUpdateArgs} args - Arguments to update one DimDate.
     * @example
     * // Update one DimDate
     * const dimDate = await prisma.dimDate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends DimDateUpdateArgs>(
      args: SelectSubset<T, DimDateUpdateArgs<ExtArgs>>
    ): Prisma__DimDateClient<
      $Result.GetResult<
        Prisma.$DimDatePayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more DimDates.
     * @param {DimDateDeleteManyArgs} args - Arguments to filter DimDates to delete.
     * @example
     * // Delete a few DimDates
     * const { count } = await prisma.dimDate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends DimDateDeleteManyArgs>(
      args?: SelectSubset<T, DimDateDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DimDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimDateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DimDates
     * const dimDate = await prisma.dimDate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends DimDateUpdateManyArgs>(
      args: SelectSubset<T, DimDateUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DimDates and returns the data updated in the database.
     * @param {DimDateUpdateManyAndReturnArgs} args - Arguments to update many DimDates.
     * @example
     * // Update many DimDates
     * const dimDate = await prisma.dimDate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more DimDates and only return the `dateId`
     * const dimDateWithDateIdOnly = await prisma.dimDate.updateManyAndReturn({
     *   select: { dateId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends DimDateUpdateManyAndReturnArgs>(
      args: SelectSubset<T, DimDateUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DimDatePayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Create or update one DimDate.
     * @param {DimDateUpsertArgs} args - Arguments to update or create a DimDate.
     * @example
     * // Update or create a DimDate
     * const dimDate = await prisma.dimDate.upsert({
     *   create: {
     *     // ... data to create a DimDate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DimDate we want to update
     *   }
     * })
     */
    upsert<T extends DimDateUpsertArgs>(
      args: SelectSubset<T, DimDateUpsertArgs<ExtArgs>>
    ): Prisma__DimDateClient<
      $Result.GetResult<
        Prisma.$DimDatePayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of DimDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimDateCountArgs} args - Arguments to filter DimDates to count.
     * @example
     * // Count the number of DimDates
     * const count = await prisma.dimDate.count({
     *   where: {
     *     // ... the filter for the DimDates we want to count
     *   }
     * })
     **/
    count<T extends DimDateCountArgs>(
      args?: Subset<T, DimDateCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DimDateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DimDate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimDateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends DimDateAggregateArgs>(
      args: Subset<T, DimDateAggregateArgs>
    ): Prisma.PrismaPromise<GetDimDateAggregateType<T>>

    /**
     * Group by DimDate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimDateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends DimDateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DimDateGroupByArgs['orderBy'] }
        : { orderBy?: DimDateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ]
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, DimDateGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetDimDateGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the DimDate model
     */
    readonly fields: DimDateFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for DimDate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DimDateClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the DimDate model
   */
  interface DimDateFieldRefs {
    readonly dateId: FieldRef<'DimDate', 'Int'>
    readonly date: FieldRef<'DimDate', 'DateTime'>
    readonly dayOfWeek: FieldRef<'DimDate', 'Int'>
    readonly dayName: FieldRef<'DimDate', 'String'>
    readonly dayOfMonth: FieldRef<'DimDate', 'Int'>
    readonly weekOfYear: FieldRef<'DimDate', 'Int'>
    readonly month: FieldRef<'DimDate', 'Int'>
    readonly monthName: FieldRef<'DimDate', 'String'>
    readonly quarter: FieldRef<'DimDate', 'Int'>
    readonly year: FieldRef<'DimDate', 'Int'>
    readonly isWeekend: FieldRef<'DimDate', 'Boolean'>
    readonly isHoliday: FieldRef<'DimDate', 'Boolean'>
    readonly fiscalYear: FieldRef<'DimDate', 'Int'>
    readonly fiscalPeriod: FieldRef<'DimDate', 'Int'>
  }

  // Custom InputTypes
  /**
   * DimDate findUnique
   */
  export type DimDateFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimDate
     */
    select?: DimDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimDate
     */
    omit?: DimDateOmit<ExtArgs> | null
    /**
     * Filter, which DimDate to fetch.
     */
    where: DimDateWhereUniqueInput
  }

  /**
   * DimDate findUniqueOrThrow
   */
  export type DimDateFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimDate
     */
    select?: DimDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimDate
     */
    omit?: DimDateOmit<ExtArgs> | null
    /**
     * Filter, which DimDate to fetch.
     */
    where: DimDateWhereUniqueInput
  }

  /**
   * DimDate findFirst
   */
  export type DimDateFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimDate
     */
    select?: DimDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimDate
     */
    omit?: DimDateOmit<ExtArgs> | null
    /**
     * Filter, which DimDate to fetch.
     */
    where?: DimDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DimDates to fetch.
     */
    orderBy?:
      | DimDateOrderByWithRelationInput
      | DimDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for DimDates.
     */
    cursor?: DimDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DimDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DimDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of DimDates.
     */
    distinct?: DimDateScalarFieldEnum | DimDateScalarFieldEnum[]
  }

  /**
   * DimDate findFirstOrThrow
   */
  export type DimDateFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimDate
     */
    select?: DimDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimDate
     */
    omit?: DimDateOmit<ExtArgs> | null
    /**
     * Filter, which DimDate to fetch.
     */
    where?: DimDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DimDates to fetch.
     */
    orderBy?:
      | DimDateOrderByWithRelationInput
      | DimDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for DimDates.
     */
    cursor?: DimDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DimDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DimDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of DimDates.
     */
    distinct?: DimDateScalarFieldEnum | DimDateScalarFieldEnum[]
  }

  /**
   * DimDate findMany
   */
  export type DimDateFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimDate
     */
    select?: DimDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimDate
     */
    omit?: DimDateOmit<ExtArgs> | null
    /**
     * Filter, which DimDates to fetch.
     */
    where?: DimDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DimDates to fetch.
     */
    orderBy?:
      | DimDateOrderByWithRelationInput
      | DimDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing DimDates.
     */
    cursor?: DimDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DimDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DimDates.
     */
    skip?: number
    distinct?: DimDateScalarFieldEnum | DimDateScalarFieldEnum[]
  }

  /**
   * DimDate create
   */
  export type DimDateCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimDate
     */
    select?: DimDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimDate
     */
    omit?: DimDateOmit<ExtArgs> | null
    /**
     * The data needed to create a DimDate.
     */
    data: XOR<DimDateCreateInput, DimDateUncheckedCreateInput>
  }

  /**
   * DimDate createMany
   */
  export type DimDateCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many DimDates.
     */
    data: DimDateCreateManyInput | DimDateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DimDate createManyAndReturn
   */
  export type DimDateCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimDate
     */
    select?: DimDateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DimDate
     */
    omit?: DimDateOmit<ExtArgs> | null
    /**
     * The data used to create many DimDates.
     */
    data: DimDateCreateManyInput | DimDateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DimDate update
   */
  export type DimDateUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimDate
     */
    select?: DimDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimDate
     */
    omit?: DimDateOmit<ExtArgs> | null
    /**
     * The data needed to update a DimDate.
     */
    data: XOR<DimDateUpdateInput, DimDateUncheckedUpdateInput>
    /**
     * Choose, which DimDate to update.
     */
    where: DimDateWhereUniqueInput
  }

  /**
   * DimDate updateMany
   */
  export type DimDateUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update DimDates.
     */
    data: XOR<DimDateUpdateManyMutationInput, DimDateUncheckedUpdateManyInput>
    /**
     * Filter which DimDates to update
     */
    where?: DimDateWhereInput
    /**
     * Limit how many DimDates to update.
     */
    limit?: number
  }

  /**
   * DimDate updateManyAndReturn
   */
  export type DimDateUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimDate
     */
    select?: DimDateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DimDate
     */
    omit?: DimDateOmit<ExtArgs> | null
    /**
     * The data used to update DimDates.
     */
    data: XOR<DimDateUpdateManyMutationInput, DimDateUncheckedUpdateManyInput>
    /**
     * Filter which DimDates to update
     */
    where?: DimDateWhereInput
    /**
     * Limit how many DimDates to update.
     */
    limit?: number
  }

  /**
   * DimDate upsert
   */
  export type DimDateUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimDate
     */
    select?: DimDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimDate
     */
    omit?: DimDateOmit<ExtArgs> | null
    /**
     * The filter to search for the DimDate to update in case it exists.
     */
    where: DimDateWhereUniqueInput
    /**
     * In case the DimDate found by the `where` argument doesn't exist, create a new DimDate with this data.
     */
    create: XOR<DimDateCreateInput, DimDateUncheckedCreateInput>
    /**
     * In case the DimDate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DimDateUpdateInput, DimDateUncheckedUpdateInput>
  }

  /**
   * DimDate delete
   */
  export type DimDateDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimDate
     */
    select?: DimDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimDate
     */
    omit?: DimDateOmit<ExtArgs> | null
    /**
     * Filter which DimDate to delete.
     */
    where: DimDateWhereUniqueInput
  }

  /**
   * DimDate deleteMany
   */
  export type DimDateDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which DimDates to delete
     */
    where?: DimDateWhereInput
    /**
     * Limit how many DimDates to delete.
     */
    limit?: number
  }

  /**
   * DimDate without action
   */
  export type DimDateDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimDate
     */
    select?: DimDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimDate
     */
    omit?: DimDateOmit<ExtArgs> | null
  }

  /**
   * Model DimMarketing
   */

  export type AggregateDimMarketing = {
    _count: DimMarketingCountAggregateOutputType | null
    _avg: DimMarketingAvgAggregateOutputType | null
    _sum: DimMarketingSumAggregateOutputType | null
    _min: DimMarketingMinAggregateOutputType | null
    _max: DimMarketingMaxAggregateOutputType | null
  }

  export type DimMarketingAvgAggregateOutputType = {
    id: number | null
  }

  export type DimMarketingSumAggregateOutputType = {
    id: bigint | null
  }

  export type DimMarketingMinAggregateOutputType = {
    id: bigint | null
    utmSource: string | null
    utmMedium: string | null
    utmCampaign: string | null
    utmTerm: string | null
    utmContent: string | null
    channelGroup: string | null
    createdAt: Date | null
  }

  export type DimMarketingMaxAggregateOutputType = {
    id: bigint | null
    utmSource: string | null
    utmMedium: string | null
    utmCampaign: string | null
    utmTerm: string | null
    utmContent: string | null
    channelGroup: string | null
    createdAt: Date | null
  }

  export type DimMarketingCountAggregateOutputType = {
    id: number
    utmSource: number
    utmMedium: number
    utmCampaign: number
    utmTerm: number
    utmContent: number
    channelGroup: number
    createdAt: number
    _all: number
  }

  export type DimMarketingAvgAggregateInputType = {
    id?: true
  }

  export type DimMarketingSumAggregateInputType = {
    id?: true
  }

  export type DimMarketingMinAggregateInputType = {
    id?: true
    utmSource?: true
    utmMedium?: true
    utmCampaign?: true
    utmTerm?: true
    utmContent?: true
    channelGroup?: true
    createdAt?: true
  }

  export type DimMarketingMaxAggregateInputType = {
    id?: true
    utmSource?: true
    utmMedium?: true
    utmCampaign?: true
    utmTerm?: true
    utmContent?: true
    channelGroup?: true
    createdAt?: true
  }

  export type DimMarketingCountAggregateInputType = {
    id?: true
    utmSource?: true
    utmMedium?: true
    utmCampaign?: true
    utmTerm?: true
    utmContent?: true
    channelGroup?: true
    createdAt?: true
    _all?: true
  }

  export type DimMarketingAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which DimMarketing to aggregate.
     */
    where?: DimMarketingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DimMarketings to fetch.
     */
    orderBy?:
      | DimMarketingOrderByWithRelationInput
      | DimMarketingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: DimMarketingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DimMarketings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DimMarketings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned DimMarketings
     **/
    _count?: true | DimMarketingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: DimMarketingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: DimMarketingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: DimMarketingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: DimMarketingMaxAggregateInputType
  }

  export type GetDimMarketingAggregateType<
    T extends DimMarketingAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateDimMarketing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDimMarketing[P]>
      : GetScalarType<T[P], AggregateDimMarketing[P]>
  }

  export type DimMarketingGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: DimMarketingWhereInput
    orderBy?:
      | DimMarketingOrderByWithAggregationInput
      | DimMarketingOrderByWithAggregationInput[]
    by: DimMarketingScalarFieldEnum[] | DimMarketingScalarFieldEnum
    having?: DimMarketingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DimMarketingCountAggregateInputType | true
    _avg?: DimMarketingAvgAggregateInputType
    _sum?: DimMarketingSumAggregateInputType
    _min?: DimMarketingMinAggregateInputType
    _max?: DimMarketingMaxAggregateInputType
  }

  export type DimMarketingGroupByOutputType = {
    id: bigint
    utmSource: string | null
    utmMedium: string | null
    utmCampaign: string | null
    utmTerm: string | null
    utmContent: string | null
    channelGroup: string | null
    createdAt: Date
    _count: DimMarketingCountAggregateOutputType | null
    _avg: DimMarketingAvgAggregateOutputType | null
    _sum: DimMarketingSumAggregateOutputType | null
    _min: DimMarketingMinAggregateOutputType | null
    _max: DimMarketingMaxAggregateOutputType | null
  }

  type GetDimMarketingGroupByPayload<T extends DimMarketingGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<DimMarketingGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof DimMarketingGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DimMarketingGroupByOutputType[P]>
            : GetScalarType<T[P], DimMarketingGroupByOutputType[P]>
        }
      >
    >

  export type DimMarketingSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      utmSource?: boolean
      utmMedium?: boolean
      utmCampaign?: boolean
      utmTerm?: boolean
      utmContent?: boolean
      channelGroup?: boolean
      createdAt?: boolean
    },
    ExtArgs['result']['dimMarketing']
  >

  export type DimMarketingSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      utmSource?: boolean
      utmMedium?: boolean
      utmCampaign?: boolean
      utmTerm?: boolean
      utmContent?: boolean
      channelGroup?: boolean
      createdAt?: boolean
    },
    ExtArgs['result']['dimMarketing']
  >

  export type DimMarketingSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      utmSource?: boolean
      utmMedium?: boolean
      utmCampaign?: boolean
      utmTerm?: boolean
      utmContent?: boolean
      channelGroup?: boolean
      createdAt?: boolean
    },
    ExtArgs['result']['dimMarketing']
  >

  export type DimMarketingSelectScalar = {
    id?: boolean
    utmSource?: boolean
    utmMedium?: boolean
    utmCampaign?: boolean
    utmTerm?: boolean
    utmContent?: boolean
    channelGroup?: boolean
    createdAt?: boolean
  }

  export type DimMarketingOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'utmSource'
    | 'utmMedium'
    | 'utmCampaign'
    | 'utmTerm'
    | 'utmContent'
    | 'channelGroup'
    | 'createdAt',
    ExtArgs['result']['dimMarketing']
  >

  export type $DimMarketingPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'DimMarketing'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        id: bigint
        utmSource: string | null
        utmMedium: string | null
        utmCampaign: string | null
        utmTerm: string | null
        utmContent: string | null
        channelGroup: string | null
        createdAt: Date
      },
      ExtArgs['result']['dimMarketing']
    >
    composites: {}
  }

  type DimMarketingGetPayload<
    S extends boolean | null | undefined | DimMarketingDefaultArgs,
  > = $Result.GetResult<Prisma.$DimMarketingPayload, S>

  type DimMarketingCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    DimMarketingFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: DimMarketingCountAggregateInputType | true
  }

  export interface DimMarketingDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['DimMarketing']
      meta: { name: 'DimMarketing' }
    }
    /**
     * Find zero or one DimMarketing that matches the filter.
     * @param {DimMarketingFindUniqueArgs} args - Arguments to find a DimMarketing
     * @example
     * // Get one DimMarketing
     * const dimMarketing = await prisma.dimMarketing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DimMarketingFindUniqueArgs>(
      args: SelectSubset<T, DimMarketingFindUniqueArgs<ExtArgs>>
    ): Prisma__DimMarketingClient<
      $Result.GetResult<
        Prisma.$DimMarketingPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one DimMarketing that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DimMarketingFindUniqueOrThrowArgs} args - Arguments to find a DimMarketing
     * @example
     * // Get one DimMarketing
     * const dimMarketing = await prisma.dimMarketing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DimMarketingFindUniqueOrThrowArgs>(
      args: SelectSubset<T, DimMarketingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DimMarketingClient<
      $Result.GetResult<
        Prisma.$DimMarketingPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first DimMarketing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimMarketingFindFirstArgs} args - Arguments to find a DimMarketing
     * @example
     * // Get one DimMarketing
     * const dimMarketing = await prisma.dimMarketing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DimMarketingFindFirstArgs>(
      args?: SelectSubset<T, DimMarketingFindFirstArgs<ExtArgs>>
    ): Prisma__DimMarketingClient<
      $Result.GetResult<
        Prisma.$DimMarketingPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first DimMarketing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimMarketingFindFirstOrThrowArgs} args - Arguments to find a DimMarketing
     * @example
     * // Get one DimMarketing
     * const dimMarketing = await prisma.dimMarketing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DimMarketingFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DimMarketingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DimMarketingClient<
      $Result.GetResult<
        Prisma.$DimMarketingPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more DimMarketings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimMarketingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DimMarketings
     * const dimMarketings = await prisma.dimMarketing.findMany()
     *
     * // Get first 10 DimMarketings
     * const dimMarketings = await prisma.dimMarketing.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const dimMarketingWithIdOnly = await prisma.dimMarketing.findMany({ select: { id: true } })
     *
     */
    findMany<T extends DimMarketingFindManyArgs>(
      args?: SelectSubset<T, DimMarketingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DimMarketingPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a DimMarketing.
     * @param {DimMarketingCreateArgs} args - Arguments to create a DimMarketing.
     * @example
     * // Create one DimMarketing
     * const DimMarketing = await prisma.dimMarketing.create({
     *   data: {
     *     // ... data to create a DimMarketing
     *   }
     * })
     *
     */
    create<T extends DimMarketingCreateArgs>(
      args: SelectSubset<T, DimMarketingCreateArgs<ExtArgs>>
    ): Prisma__DimMarketingClient<
      $Result.GetResult<
        Prisma.$DimMarketingPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many DimMarketings.
     * @param {DimMarketingCreateManyArgs} args - Arguments to create many DimMarketings.
     * @example
     * // Create many DimMarketings
     * const dimMarketing = await prisma.dimMarketing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends DimMarketingCreateManyArgs>(
      args?: SelectSubset<T, DimMarketingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DimMarketings and returns the data saved in the database.
     * @param {DimMarketingCreateManyAndReturnArgs} args - Arguments to create many DimMarketings.
     * @example
     * // Create many DimMarketings
     * const dimMarketing = await prisma.dimMarketing.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many DimMarketings and only return the `id`
     * const dimMarketingWithIdOnly = await prisma.dimMarketing.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends DimMarketingCreateManyAndReturnArgs>(
      args?: SelectSubset<T, DimMarketingCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DimMarketingPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Delete a DimMarketing.
     * @param {DimMarketingDeleteArgs} args - Arguments to delete one DimMarketing.
     * @example
     * // Delete one DimMarketing
     * const DimMarketing = await prisma.dimMarketing.delete({
     *   where: {
     *     // ... filter to delete one DimMarketing
     *   }
     * })
     *
     */
    delete<T extends DimMarketingDeleteArgs>(
      args: SelectSubset<T, DimMarketingDeleteArgs<ExtArgs>>
    ): Prisma__DimMarketingClient<
      $Result.GetResult<
        Prisma.$DimMarketingPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one DimMarketing.
     * @param {DimMarketingUpdateArgs} args - Arguments to update one DimMarketing.
     * @example
     * // Update one DimMarketing
     * const dimMarketing = await prisma.dimMarketing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends DimMarketingUpdateArgs>(
      args: SelectSubset<T, DimMarketingUpdateArgs<ExtArgs>>
    ): Prisma__DimMarketingClient<
      $Result.GetResult<
        Prisma.$DimMarketingPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more DimMarketings.
     * @param {DimMarketingDeleteManyArgs} args - Arguments to filter DimMarketings to delete.
     * @example
     * // Delete a few DimMarketings
     * const { count } = await prisma.dimMarketing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends DimMarketingDeleteManyArgs>(
      args?: SelectSubset<T, DimMarketingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DimMarketings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimMarketingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DimMarketings
     * const dimMarketing = await prisma.dimMarketing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends DimMarketingUpdateManyArgs>(
      args: SelectSubset<T, DimMarketingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DimMarketings and returns the data updated in the database.
     * @param {DimMarketingUpdateManyAndReturnArgs} args - Arguments to update many DimMarketings.
     * @example
     * // Update many DimMarketings
     * const dimMarketing = await prisma.dimMarketing.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more DimMarketings and only return the `id`
     * const dimMarketingWithIdOnly = await prisma.dimMarketing.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends DimMarketingUpdateManyAndReturnArgs>(
      args: SelectSubset<T, DimMarketingUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DimMarketingPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Create or update one DimMarketing.
     * @param {DimMarketingUpsertArgs} args - Arguments to update or create a DimMarketing.
     * @example
     * // Update or create a DimMarketing
     * const dimMarketing = await prisma.dimMarketing.upsert({
     *   create: {
     *     // ... data to create a DimMarketing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DimMarketing we want to update
     *   }
     * })
     */
    upsert<T extends DimMarketingUpsertArgs>(
      args: SelectSubset<T, DimMarketingUpsertArgs<ExtArgs>>
    ): Prisma__DimMarketingClient<
      $Result.GetResult<
        Prisma.$DimMarketingPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of DimMarketings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimMarketingCountArgs} args - Arguments to filter DimMarketings to count.
     * @example
     * // Count the number of DimMarketings
     * const count = await prisma.dimMarketing.count({
     *   where: {
     *     // ... the filter for the DimMarketings we want to count
     *   }
     * })
     **/
    count<T extends DimMarketingCountArgs>(
      args?: Subset<T, DimMarketingCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DimMarketingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DimMarketing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimMarketingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends DimMarketingAggregateArgs>(
      args: Subset<T, DimMarketingAggregateArgs>
    ): Prisma.PrismaPromise<GetDimMarketingAggregateType<T>>

    /**
     * Group by DimMarketing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimMarketingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends DimMarketingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DimMarketingGroupByArgs['orderBy'] }
        : { orderBy?: DimMarketingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ]
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, DimMarketingGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetDimMarketingGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the DimMarketing model
     */
    readonly fields: DimMarketingFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for DimMarketing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DimMarketingClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the DimMarketing model
   */
  interface DimMarketingFieldRefs {
    readonly id: FieldRef<'DimMarketing', 'BigInt'>
    readonly utmSource: FieldRef<'DimMarketing', 'String'>
    readonly utmMedium: FieldRef<'DimMarketing', 'String'>
    readonly utmCampaign: FieldRef<'DimMarketing', 'String'>
    readonly utmTerm: FieldRef<'DimMarketing', 'String'>
    readonly utmContent: FieldRef<'DimMarketing', 'String'>
    readonly channelGroup: FieldRef<'DimMarketing', 'String'>
    readonly createdAt: FieldRef<'DimMarketing', 'DateTime'>
  }

  // Custom InputTypes
  /**
   * DimMarketing findUnique
   */
  export type DimMarketingFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimMarketing
     */
    select?: DimMarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimMarketing
     */
    omit?: DimMarketingOmit<ExtArgs> | null
    /**
     * Filter, which DimMarketing to fetch.
     */
    where: DimMarketingWhereUniqueInput
  }

  /**
   * DimMarketing findUniqueOrThrow
   */
  export type DimMarketingFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimMarketing
     */
    select?: DimMarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimMarketing
     */
    omit?: DimMarketingOmit<ExtArgs> | null
    /**
     * Filter, which DimMarketing to fetch.
     */
    where: DimMarketingWhereUniqueInput
  }

  /**
   * DimMarketing findFirst
   */
  export type DimMarketingFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimMarketing
     */
    select?: DimMarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimMarketing
     */
    omit?: DimMarketingOmit<ExtArgs> | null
    /**
     * Filter, which DimMarketing to fetch.
     */
    where?: DimMarketingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DimMarketings to fetch.
     */
    orderBy?:
      | DimMarketingOrderByWithRelationInput
      | DimMarketingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for DimMarketings.
     */
    cursor?: DimMarketingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DimMarketings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DimMarketings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of DimMarketings.
     */
    distinct?: DimMarketingScalarFieldEnum | DimMarketingScalarFieldEnum[]
  }

  /**
   * DimMarketing findFirstOrThrow
   */
  export type DimMarketingFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimMarketing
     */
    select?: DimMarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimMarketing
     */
    omit?: DimMarketingOmit<ExtArgs> | null
    /**
     * Filter, which DimMarketing to fetch.
     */
    where?: DimMarketingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DimMarketings to fetch.
     */
    orderBy?:
      | DimMarketingOrderByWithRelationInput
      | DimMarketingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for DimMarketings.
     */
    cursor?: DimMarketingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DimMarketings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DimMarketings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of DimMarketings.
     */
    distinct?: DimMarketingScalarFieldEnum | DimMarketingScalarFieldEnum[]
  }

  /**
   * DimMarketing findMany
   */
  export type DimMarketingFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimMarketing
     */
    select?: DimMarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimMarketing
     */
    omit?: DimMarketingOmit<ExtArgs> | null
    /**
     * Filter, which DimMarketings to fetch.
     */
    where?: DimMarketingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DimMarketings to fetch.
     */
    orderBy?:
      | DimMarketingOrderByWithRelationInput
      | DimMarketingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing DimMarketings.
     */
    cursor?: DimMarketingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DimMarketings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DimMarketings.
     */
    skip?: number
    distinct?: DimMarketingScalarFieldEnum | DimMarketingScalarFieldEnum[]
  }

  /**
   * DimMarketing create
   */
  export type DimMarketingCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimMarketing
     */
    select?: DimMarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimMarketing
     */
    omit?: DimMarketingOmit<ExtArgs> | null
    /**
     * The data needed to create a DimMarketing.
     */
    data?: XOR<DimMarketingCreateInput, DimMarketingUncheckedCreateInput>
  }

  /**
   * DimMarketing createMany
   */
  export type DimMarketingCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many DimMarketings.
     */
    data: DimMarketingCreateManyInput | DimMarketingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DimMarketing createManyAndReturn
   */
  export type DimMarketingCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimMarketing
     */
    select?: DimMarketingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DimMarketing
     */
    omit?: DimMarketingOmit<ExtArgs> | null
    /**
     * The data used to create many DimMarketings.
     */
    data: DimMarketingCreateManyInput | DimMarketingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DimMarketing update
   */
  export type DimMarketingUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimMarketing
     */
    select?: DimMarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimMarketing
     */
    omit?: DimMarketingOmit<ExtArgs> | null
    /**
     * The data needed to update a DimMarketing.
     */
    data: XOR<DimMarketingUpdateInput, DimMarketingUncheckedUpdateInput>
    /**
     * Choose, which DimMarketing to update.
     */
    where: DimMarketingWhereUniqueInput
  }

  /**
   * DimMarketing updateMany
   */
  export type DimMarketingUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update DimMarketings.
     */
    data: XOR<
      DimMarketingUpdateManyMutationInput,
      DimMarketingUncheckedUpdateManyInput
    >
    /**
     * Filter which DimMarketings to update
     */
    where?: DimMarketingWhereInput
    /**
     * Limit how many DimMarketings to update.
     */
    limit?: number
  }

  /**
   * DimMarketing updateManyAndReturn
   */
  export type DimMarketingUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimMarketing
     */
    select?: DimMarketingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DimMarketing
     */
    omit?: DimMarketingOmit<ExtArgs> | null
    /**
     * The data used to update DimMarketings.
     */
    data: XOR<
      DimMarketingUpdateManyMutationInput,
      DimMarketingUncheckedUpdateManyInput
    >
    /**
     * Filter which DimMarketings to update
     */
    where?: DimMarketingWhereInput
    /**
     * Limit how many DimMarketings to update.
     */
    limit?: number
  }

  /**
   * DimMarketing upsert
   */
  export type DimMarketingUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimMarketing
     */
    select?: DimMarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimMarketing
     */
    omit?: DimMarketingOmit<ExtArgs> | null
    /**
     * The filter to search for the DimMarketing to update in case it exists.
     */
    where: DimMarketingWhereUniqueInput
    /**
     * In case the DimMarketing found by the `where` argument doesn't exist, create a new DimMarketing with this data.
     */
    create: XOR<DimMarketingCreateInput, DimMarketingUncheckedCreateInput>
    /**
     * In case the DimMarketing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DimMarketingUpdateInput, DimMarketingUncheckedUpdateInput>
  }

  /**
   * DimMarketing delete
   */
  export type DimMarketingDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimMarketing
     */
    select?: DimMarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimMarketing
     */
    omit?: DimMarketingOmit<ExtArgs> | null
    /**
     * Filter which DimMarketing to delete.
     */
    where: DimMarketingWhereUniqueInput
  }

  /**
   * DimMarketing deleteMany
   */
  export type DimMarketingDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which DimMarketings to delete
     */
    where?: DimMarketingWhereInput
    /**
     * Limit how many DimMarketings to delete.
     */
    limit?: number
  }

  /**
   * DimMarketing without action
   */
  export type DimMarketingDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimMarketing
     */
    select?: DimMarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimMarketing
     */
    omit?: DimMarketingOmit<ExtArgs> | null
  }

  /**
   * Model DimLocation
   */

  export type AggregateDimLocation = {
    _count: DimLocationCountAggregateOutputType | null
    _avg: DimLocationAvgAggregateOutputType | null
    _sum: DimLocationSumAggregateOutputType | null
    _min: DimLocationMinAggregateOutputType | null
    _max: DimLocationMaxAggregateOutputType | null
  }

  export type DimLocationAvgAggregateOutputType = {
    id: number | null
  }

  export type DimLocationSumAggregateOutputType = {
    id: number | null
  }

  export type DimLocationMinAggregateOutputType = {
    id: number | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    countryCode: string | null
    region: string | null
  }

  export type DimLocationMaxAggregateOutputType = {
    id: number | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    countryCode: string | null
    region: string | null
  }

  export type DimLocationCountAggregateOutputType = {
    id: number
    city: number
    state: number
    postalCode: number
    country: number
    countryCode: number
    region: number
    _all: number
  }

  export type DimLocationAvgAggregateInputType = {
    id?: true
  }

  export type DimLocationSumAggregateInputType = {
    id?: true
  }

  export type DimLocationMinAggregateInputType = {
    id?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    countryCode?: true
    region?: true
  }

  export type DimLocationMaxAggregateInputType = {
    id?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    countryCode?: true
    region?: true
  }

  export type DimLocationCountAggregateInputType = {
    id?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    countryCode?: true
    region?: true
    _all?: true
  }

  export type DimLocationAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which DimLocation to aggregate.
     */
    where?: DimLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DimLocations to fetch.
     */
    orderBy?:
      | DimLocationOrderByWithRelationInput
      | DimLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: DimLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DimLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DimLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned DimLocations
     **/
    _count?: true | DimLocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: DimLocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: DimLocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: DimLocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: DimLocationMaxAggregateInputType
  }

  export type GetDimLocationAggregateType<T extends DimLocationAggregateArgs> =
    {
      [P in keyof T & keyof AggregateDimLocation]: P extends '_count' | 'count'
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregateDimLocation[P]>
        : GetScalarType<T[P], AggregateDimLocation[P]>
    }

  export type DimLocationGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: DimLocationWhereInput
    orderBy?:
      | DimLocationOrderByWithAggregationInput
      | DimLocationOrderByWithAggregationInput[]
    by: DimLocationScalarFieldEnum[] | DimLocationScalarFieldEnum
    having?: DimLocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DimLocationCountAggregateInputType | true
    _avg?: DimLocationAvgAggregateInputType
    _sum?: DimLocationSumAggregateInputType
    _min?: DimLocationMinAggregateInputType
    _max?: DimLocationMaxAggregateInputType
  }

  export type DimLocationGroupByOutputType = {
    id: number
    city: string | null
    state: string | null
    postalCode: string | null
    country: string
    countryCode: string
    region: string | null
    _count: DimLocationCountAggregateOutputType | null
    _avg: DimLocationAvgAggregateOutputType | null
    _sum: DimLocationSumAggregateOutputType | null
    _min: DimLocationMinAggregateOutputType | null
    _max: DimLocationMaxAggregateOutputType | null
  }

  type GetDimLocationGroupByPayload<T extends DimLocationGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<DimLocationGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof DimLocationGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DimLocationGroupByOutputType[P]>
            : GetScalarType<T[P], DimLocationGroupByOutputType[P]>
        }
      >
    >

  export type DimLocationSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      city?: boolean
      state?: boolean
      postalCode?: boolean
      country?: boolean
      countryCode?: boolean
      region?: boolean
    },
    ExtArgs['result']['dimLocation']
  >

  export type DimLocationSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      city?: boolean
      state?: boolean
      postalCode?: boolean
      country?: boolean
      countryCode?: boolean
      region?: boolean
    },
    ExtArgs['result']['dimLocation']
  >

  export type DimLocationSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      city?: boolean
      state?: boolean
      postalCode?: boolean
      country?: boolean
      countryCode?: boolean
      region?: boolean
    },
    ExtArgs['result']['dimLocation']
  >

  export type DimLocationSelectScalar = {
    id?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    countryCode?: boolean
    region?: boolean
  }

  export type DimLocationOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'city'
    | 'state'
    | 'postalCode'
    | 'country'
    | 'countryCode'
    | 'region',
    ExtArgs['result']['dimLocation']
  >

  export type $DimLocationPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'DimLocation'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        id: number
        city: string | null
        state: string | null
        postalCode: string | null
        country: string
        countryCode: string
        region: string | null
      },
      ExtArgs['result']['dimLocation']
    >
    composites: {}
  }

  type DimLocationGetPayload<
    S extends boolean | null | undefined | DimLocationDefaultArgs,
  > = $Result.GetResult<Prisma.$DimLocationPayload, S>

  type DimLocationCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    DimLocationFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: DimLocationCountAggregateInputType | true
  }

  export interface DimLocationDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['DimLocation']
      meta: { name: 'DimLocation' }
    }
    /**
     * Find zero or one DimLocation that matches the filter.
     * @param {DimLocationFindUniqueArgs} args - Arguments to find a DimLocation
     * @example
     * // Get one DimLocation
     * const dimLocation = await prisma.dimLocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DimLocationFindUniqueArgs>(
      args: SelectSubset<T, DimLocationFindUniqueArgs<ExtArgs>>
    ): Prisma__DimLocationClient<
      $Result.GetResult<
        Prisma.$DimLocationPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one DimLocation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DimLocationFindUniqueOrThrowArgs} args - Arguments to find a DimLocation
     * @example
     * // Get one DimLocation
     * const dimLocation = await prisma.dimLocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DimLocationFindUniqueOrThrowArgs>(
      args: SelectSubset<T, DimLocationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DimLocationClient<
      $Result.GetResult<
        Prisma.$DimLocationPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first DimLocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimLocationFindFirstArgs} args - Arguments to find a DimLocation
     * @example
     * // Get one DimLocation
     * const dimLocation = await prisma.dimLocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DimLocationFindFirstArgs>(
      args?: SelectSubset<T, DimLocationFindFirstArgs<ExtArgs>>
    ): Prisma__DimLocationClient<
      $Result.GetResult<
        Prisma.$DimLocationPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first DimLocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimLocationFindFirstOrThrowArgs} args - Arguments to find a DimLocation
     * @example
     * // Get one DimLocation
     * const dimLocation = await prisma.dimLocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DimLocationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DimLocationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DimLocationClient<
      $Result.GetResult<
        Prisma.$DimLocationPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more DimLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimLocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DimLocations
     * const dimLocations = await prisma.dimLocation.findMany()
     *
     * // Get first 10 DimLocations
     * const dimLocations = await prisma.dimLocation.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const dimLocationWithIdOnly = await prisma.dimLocation.findMany({ select: { id: true } })
     *
     */
    findMany<T extends DimLocationFindManyArgs>(
      args?: SelectSubset<T, DimLocationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DimLocationPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a DimLocation.
     * @param {DimLocationCreateArgs} args - Arguments to create a DimLocation.
     * @example
     * // Create one DimLocation
     * const DimLocation = await prisma.dimLocation.create({
     *   data: {
     *     // ... data to create a DimLocation
     *   }
     * })
     *
     */
    create<T extends DimLocationCreateArgs>(
      args: SelectSubset<T, DimLocationCreateArgs<ExtArgs>>
    ): Prisma__DimLocationClient<
      $Result.GetResult<
        Prisma.$DimLocationPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many DimLocations.
     * @param {DimLocationCreateManyArgs} args - Arguments to create many DimLocations.
     * @example
     * // Create many DimLocations
     * const dimLocation = await prisma.dimLocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends DimLocationCreateManyArgs>(
      args?: SelectSubset<T, DimLocationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DimLocations and returns the data saved in the database.
     * @param {DimLocationCreateManyAndReturnArgs} args - Arguments to create many DimLocations.
     * @example
     * // Create many DimLocations
     * const dimLocation = await prisma.dimLocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many DimLocations and only return the `id`
     * const dimLocationWithIdOnly = await prisma.dimLocation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends DimLocationCreateManyAndReturnArgs>(
      args?: SelectSubset<T, DimLocationCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DimLocationPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Delete a DimLocation.
     * @param {DimLocationDeleteArgs} args - Arguments to delete one DimLocation.
     * @example
     * // Delete one DimLocation
     * const DimLocation = await prisma.dimLocation.delete({
     *   where: {
     *     // ... filter to delete one DimLocation
     *   }
     * })
     *
     */
    delete<T extends DimLocationDeleteArgs>(
      args: SelectSubset<T, DimLocationDeleteArgs<ExtArgs>>
    ): Prisma__DimLocationClient<
      $Result.GetResult<
        Prisma.$DimLocationPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one DimLocation.
     * @param {DimLocationUpdateArgs} args - Arguments to update one DimLocation.
     * @example
     * // Update one DimLocation
     * const dimLocation = await prisma.dimLocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends DimLocationUpdateArgs>(
      args: SelectSubset<T, DimLocationUpdateArgs<ExtArgs>>
    ): Prisma__DimLocationClient<
      $Result.GetResult<
        Prisma.$DimLocationPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more DimLocations.
     * @param {DimLocationDeleteManyArgs} args - Arguments to filter DimLocations to delete.
     * @example
     * // Delete a few DimLocations
     * const { count } = await prisma.dimLocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends DimLocationDeleteManyArgs>(
      args?: SelectSubset<T, DimLocationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DimLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimLocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DimLocations
     * const dimLocation = await prisma.dimLocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends DimLocationUpdateManyArgs>(
      args: SelectSubset<T, DimLocationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DimLocations and returns the data updated in the database.
     * @param {DimLocationUpdateManyAndReturnArgs} args - Arguments to update many DimLocations.
     * @example
     * // Update many DimLocations
     * const dimLocation = await prisma.dimLocation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more DimLocations and only return the `id`
     * const dimLocationWithIdOnly = await prisma.dimLocation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends DimLocationUpdateManyAndReturnArgs>(
      args: SelectSubset<T, DimLocationUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DimLocationPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Create or update one DimLocation.
     * @param {DimLocationUpsertArgs} args - Arguments to update or create a DimLocation.
     * @example
     * // Update or create a DimLocation
     * const dimLocation = await prisma.dimLocation.upsert({
     *   create: {
     *     // ... data to create a DimLocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DimLocation we want to update
     *   }
     * })
     */
    upsert<T extends DimLocationUpsertArgs>(
      args: SelectSubset<T, DimLocationUpsertArgs<ExtArgs>>
    ): Prisma__DimLocationClient<
      $Result.GetResult<
        Prisma.$DimLocationPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of DimLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimLocationCountArgs} args - Arguments to filter DimLocations to count.
     * @example
     * // Count the number of DimLocations
     * const count = await prisma.dimLocation.count({
     *   where: {
     *     // ... the filter for the DimLocations we want to count
     *   }
     * })
     **/
    count<T extends DimLocationCountArgs>(
      args?: Subset<T, DimLocationCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DimLocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DimLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimLocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends DimLocationAggregateArgs>(
      args: Subset<T, DimLocationAggregateArgs>
    ): Prisma.PrismaPromise<GetDimLocationAggregateType<T>>

    /**
     * Group by DimLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DimLocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends DimLocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DimLocationGroupByArgs['orderBy'] }
        : { orderBy?: DimLocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ]
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, DimLocationGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetDimLocationGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the DimLocation model
     */
    readonly fields: DimLocationFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for DimLocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DimLocationClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the DimLocation model
   */
  interface DimLocationFieldRefs {
    readonly id: FieldRef<'DimLocation', 'Int'>
    readonly city: FieldRef<'DimLocation', 'String'>
    readonly state: FieldRef<'DimLocation', 'String'>
    readonly postalCode: FieldRef<'DimLocation', 'String'>
    readonly country: FieldRef<'DimLocation', 'String'>
    readonly countryCode: FieldRef<'DimLocation', 'String'>
    readonly region: FieldRef<'DimLocation', 'String'>
  }

  // Custom InputTypes
  /**
   * DimLocation findUnique
   */
  export type DimLocationFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimLocation
     */
    select?: DimLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimLocation
     */
    omit?: DimLocationOmit<ExtArgs> | null
    /**
     * Filter, which DimLocation to fetch.
     */
    where: DimLocationWhereUniqueInput
  }

  /**
   * DimLocation findUniqueOrThrow
   */
  export type DimLocationFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimLocation
     */
    select?: DimLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimLocation
     */
    omit?: DimLocationOmit<ExtArgs> | null
    /**
     * Filter, which DimLocation to fetch.
     */
    where: DimLocationWhereUniqueInput
  }

  /**
   * DimLocation findFirst
   */
  export type DimLocationFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimLocation
     */
    select?: DimLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimLocation
     */
    omit?: DimLocationOmit<ExtArgs> | null
    /**
     * Filter, which DimLocation to fetch.
     */
    where?: DimLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DimLocations to fetch.
     */
    orderBy?:
      | DimLocationOrderByWithRelationInput
      | DimLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for DimLocations.
     */
    cursor?: DimLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DimLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DimLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of DimLocations.
     */
    distinct?: DimLocationScalarFieldEnum | DimLocationScalarFieldEnum[]
  }

  /**
   * DimLocation findFirstOrThrow
   */
  export type DimLocationFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimLocation
     */
    select?: DimLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimLocation
     */
    omit?: DimLocationOmit<ExtArgs> | null
    /**
     * Filter, which DimLocation to fetch.
     */
    where?: DimLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DimLocations to fetch.
     */
    orderBy?:
      | DimLocationOrderByWithRelationInput
      | DimLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for DimLocations.
     */
    cursor?: DimLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DimLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DimLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of DimLocations.
     */
    distinct?: DimLocationScalarFieldEnum | DimLocationScalarFieldEnum[]
  }

  /**
   * DimLocation findMany
   */
  export type DimLocationFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimLocation
     */
    select?: DimLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimLocation
     */
    omit?: DimLocationOmit<ExtArgs> | null
    /**
     * Filter, which DimLocations to fetch.
     */
    where?: DimLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DimLocations to fetch.
     */
    orderBy?:
      | DimLocationOrderByWithRelationInput
      | DimLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing DimLocations.
     */
    cursor?: DimLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DimLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DimLocations.
     */
    skip?: number
    distinct?: DimLocationScalarFieldEnum | DimLocationScalarFieldEnum[]
  }

  /**
   * DimLocation create
   */
  export type DimLocationCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimLocation
     */
    select?: DimLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimLocation
     */
    omit?: DimLocationOmit<ExtArgs> | null
    /**
     * The data needed to create a DimLocation.
     */
    data: XOR<DimLocationCreateInput, DimLocationUncheckedCreateInput>
  }

  /**
   * DimLocation createMany
   */
  export type DimLocationCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many DimLocations.
     */
    data: DimLocationCreateManyInput | DimLocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DimLocation createManyAndReturn
   */
  export type DimLocationCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimLocation
     */
    select?: DimLocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DimLocation
     */
    omit?: DimLocationOmit<ExtArgs> | null
    /**
     * The data used to create many DimLocations.
     */
    data: DimLocationCreateManyInput | DimLocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DimLocation update
   */
  export type DimLocationUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimLocation
     */
    select?: DimLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimLocation
     */
    omit?: DimLocationOmit<ExtArgs> | null
    /**
     * The data needed to update a DimLocation.
     */
    data: XOR<DimLocationUpdateInput, DimLocationUncheckedUpdateInput>
    /**
     * Choose, which DimLocation to update.
     */
    where: DimLocationWhereUniqueInput
  }

  /**
   * DimLocation updateMany
   */
  export type DimLocationUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update DimLocations.
     */
    data: XOR<
      DimLocationUpdateManyMutationInput,
      DimLocationUncheckedUpdateManyInput
    >
    /**
     * Filter which DimLocations to update
     */
    where?: DimLocationWhereInput
    /**
     * Limit how many DimLocations to update.
     */
    limit?: number
  }

  /**
   * DimLocation updateManyAndReturn
   */
  export type DimLocationUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimLocation
     */
    select?: DimLocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DimLocation
     */
    omit?: DimLocationOmit<ExtArgs> | null
    /**
     * The data used to update DimLocations.
     */
    data: XOR<
      DimLocationUpdateManyMutationInput,
      DimLocationUncheckedUpdateManyInput
    >
    /**
     * Filter which DimLocations to update
     */
    where?: DimLocationWhereInput
    /**
     * Limit how many DimLocations to update.
     */
    limit?: number
  }

  /**
   * DimLocation upsert
   */
  export type DimLocationUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimLocation
     */
    select?: DimLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimLocation
     */
    omit?: DimLocationOmit<ExtArgs> | null
    /**
     * The filter to search for the DimLocation to update in case it exists.
     */
    where: DimLocationWhereUniqueInput
    /**
     * In case the DimLocation found by the `where` argument doesn't exist, create a new DimLocation with this data.
     */
    create: XOR<DimLocationCreateInput, DimLocationUncheckedCreateInput>
    /**
     * In case the DimLocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DimLocationUpdateInput, DimLocationUncheckedUpdateInput>
  }

  /**
   * DimLocation delete
   */
  export type DimLocationDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimLocation
     */
    select?: DimLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimLocation
     */
    omit?: DimLocationOmit<ExtArgs> | null
    /**
     * Filter which DimLocation to delete.
     */
    where: DimLocationWhereUniqueInput
  }

  /**
   * DimLocation deleteMany
   */
  export type DimLocationDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which DimLocations to delete
     */
    where?: DimLocationWhereInput
    /**
     * Limit how many DimLocations to delete.
     */
    limit?: number
  }

  /**
   * DimLocation without action
   */
  export type DimLocationDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DimLocation
     */
    select?: DimLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DimLocation
     */
    omit?: DimLocationOmit<ExtArgs> | null
  }

  /**
   * Model IngestOffset
   */

  export type AggregateIngestOffset = {
    _count: IngestOffsetCountAggregateOutputType | null
    _avg: IngestOffsetAvgAggregateOutputType | null
    _sum: IngestOffsetSumAggregateOutputType | null
    _min: IngestOffsetMinAggregateOutputType | null
    _max: IngestOffsetMaxAggregateOutputType | null
  }

  export type IngestOffsetAvgAggregateOutputType = {
    id: number | null
    partition: number | null
    lastOffset: number | null
  }

  export type IngestOffsetSumAggregateOutputType = {
    id: bigint | null
    partition: number | null
    lastOffset: bigint | null
  }

  export type IngestOffsetMinAggregateOutputType = {
    id: bigint | null
    source: string | null
    partition: number | null
    lastOffset: bigint | null
    lastTimestamp: Date | null
    payloadHash: string | null
    updatedAt: Date | null
  }

  export type IngestOffsetMaxAggregateOutputType = {
    id: bigint | null
    source: string | null
    partition: number | null
    lastOffset: bigint | null
    lastTimestamp: Date | null
    payloadHash: string | null
    updatedAt: Date | null
  }

  export type IngestOffsetCountAggregateOutputType = {
    id: number
    source: number
    partition: number
    lastOffset: number
    lastTimestamp: number
    payloadHash: number
    updatedAt: number
    _all: number
  }

  export type IngestOffsetAvgAggregateInputType = {
    id?: true
    partition?: true
    lastOffset?: true
  }

  export type IngestOffsetSumAggregateInputType = {
    id?: true
    partition?: true
    lastOffset?: true
  }

  export type IngestOffsetMinAggregateInputType = {
    id?: true
    source?: true
    partition?: true
    lastOffset?: true
    lastTimestamp?: true
    payloadHash?: true
    updatedAt?: true
  }

  export type IngestOffsetMaxAggregateInputType = {
    id?: true
    source?: true
    partition?: true
    lastOffset?: true
    lastTimestamp?: true
    payloadHash?: true
    updatedAt?: true
  }

  export type IngestOffsetCountAggregateInputType = {
    id?: true
    source?: true
    partition?: true
    lastOffset?: true
    lastTimestamp?: true
    payloadHash?: true
    updatedAt?: true
    _all?: true
  }

  export type IngestOffsetAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which IngestOffset to aggregate.
     */
    where?: IngestOffsetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of IngestOffsets to fetch.
     */
    orderBy?:
      | IngestOffsetOrderByWithRelationInput
      | IngestOffsetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: IngestOffsetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` IngestOffsets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` IngestOffsets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned IngestOffsets
     **/
    _count?: true | IngestOffsetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: IngestOffsetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: IngestOffsetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: IngestOffsetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: IngestOffsetMaxAggregateInputType
  }

  export type GetIngestOffsetAggregateType<
    T extends IngestOffsetAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateIngestOffset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIngestOffset[P]>
      : GetScalarType<T[P], AggregateIngestOffset[P]>
  }

  export type IngestOffsetGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: IngestOffsetWhereInput
    orderBy?:
      | IngestOffsetOrderByWithAggregationInput
      | IngestOffsetOrderByWithAggregationInput[]
    by: IngestOffsetScalarFieldEnum[] | IngestOffsetScalarFieldEnum
    having?: IngestOffsetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IngestOffsetCountAggregateInputType | true
    _avg?: IngestOffsetAvgAggregateInputType
    _sum?: IngestOffsetSumAggregateInputType
    _min?: IngestOffsetMinAggregateInputType
    _max?: IngestOffsetMaxAggregateInputType
  }

  export type IngestOffsetGroupByOutputType = {
    id: bigint
    source: string
    partition: number
    lastOffset: bigint | null
    lastTimestamp: Date | null
    payloadHash: string | null
    updatedAt: Date
    _count: IngestOffsetCountAggregateOutputType | null
    _avg: IngestOffsetAvgAggregateOutputType | null
    _sum: IngestOffsetSumAggregateOutputType | null
    _min: IngestOffsetMinAggregateOutputType | null
    _max: IngestOffsetMaxAggregateOutputType | null
  }

  type GetIngestOffsetGroupByPayload<T extends IngestOffsetGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<IngestOffsetGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof IngestOffsetGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IngestOffsetGroupByOutputType[P]>
            : GetScalarType<T[P], IngestOffsetGroupByOutputType[P]>
        }
      >
    >

  export type IngestOffsetSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      source?: boolean
      partition?: boolean
      lastOffset?: boolean
      lastTimestamp?: boolean
      payloadHash?: boolean
      updatedAt?: boolean
    },
    ExtArgs['result']['ingestOffset']
  >

  export type IngestOffsetSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      source?: boolean
      partition?: boolean
      lastOffset?: boolean
      lastTimestamp?: boolean
      payloadHash?: boolean
      updatedAt?: boolean
    },
    ExtArgs['result']['ingestOffset']
  >

  export type IngestOffsetSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      source?: boolean
      partition?: boolean
      lastOffset?: boolean
      lastTimestamp?: boolean
      payloadHash?: boolean
      updatedAt?: boolean
    },
    ExtArgs['result']['ingestOffset']
  >

  export type IngestOffsetSelectScalar = {
    id?: boolean
    source?: boolean
    partition?: boolean
    lastOffset?: boolean
    lastTimestamp?: boolean
    payloadHash?: boolean
    updatedAt?: boolean
  }

  export type IngestOffsetOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'source'
    | 'partition'
    | 'lastOffset'
    | 'lastTimestamp'
    | 'payloadHash'
    | 'updatedAt',
    ExtArgs['result']['ingestOffset']
  >

  export type $IngestOffsetPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'IngestOffset'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        id: bigint
        source: string
        partition: number
        lastOffset: bigint | null
        lastTimestamp: Date | null
        payloadHash: string | null
        updatedAt: Date
      },
      ExtArgs['result']['ingestOffset']
    >
    composites: {}
  }

  type IngestOffsetGetPayload<
    S extends boolean | null | undefined | IngestOffsetDefaultArgs,
  > = $Result.GetResult<Prisma.$IngestOffsetPayload, S>

  type IngestOffsetCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    IngestOffsetFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: IngestOffsetCountAggregateInputType | true
  }

  export interface IngestOffsetDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['IngestOffset']
      meta: { name: 'IngestOffset' }
    }
    /**
     * Find zero or one IngestOffset that matches the filter.
     * @param {IngestOffsetFindUniqueArgs} args - Arguments to find a IngestOffset
     * @example
     * // Get one IngestOffset
     * const ingestOffset = await prisma.ingestOffset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IngestOffsetFindUniqueArgs>(
      args: SelectSubset<T, IngestOffsetFindUniqueArgs<ExtArgs>>
    ): Prisma__IngestOffsetClient<
      $Result.GetResult<
        Prisma.$IngestOffsetPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one IngestOffset that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IngestOffsetFindUniqueOrThrowArgs} args - Arguments to find a IngestOffset
     * @example
     * // Get one IngestOffset
     * const ingestOffset = await prisma.ingestOffset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IngestOffsetFindUniqueOrThrowArgs>(
      args: SelectSubset<T, IngestOffsetFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__IngestOffsetClient<
      $Result.GetResult<
        Prisma.$IngestOffsetPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first IngestOffset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestOffsetFindFirstArgs} args - Arguments to find a IngestOffset
     * @example
     * // Get one IngestOffset
     * const ingestOffset = await prisma.ingestOffset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IngestOffsetFindFirstArgs>(
      args?: SelectSubset<T, IngestOffsetFindFirstArgs<ExtArgs>>
    ): Prisma__IngestOffsetClient<
      $Result.GetResult<
        Prisma.$IngestOffsetPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first IngestOffset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestOffsetFindFirstOrThrowArgs} args - Arguments to find a IngestOffset
     * @example
     * // Get one IngestOffset
     * const ingestOffset = await prisma.ingestOffset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IngestOffsetFindFirstOrThrowArgs>(
      args?: SelectSubset<T, IngestOffsetFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__IngestOffsetClient<
      $Result.GetResult<
        Prisma.$IngestOffsetPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more IngestOffsets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestOffsetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IngestOffsets
     * const ingestOffsets = await prisma.ingestOffset.findMany()
     *
     * // Get first 10 IngestOffsets
     * const ingestOffsets = await prisma.ingestOffset.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const ingestOffsetWithIdOnly = await prisma.ingestOffset.findMany({ select: { id: true } })
     *
     */
    findMany<T extends IngestOffsetFindManyArgs>(
      args?: SelectSubset<T, IngestOffsetFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$IngestOffsetPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a IngestOffset.
     * @param {IngestOffsetCreateArgs} args - Arguments to create a IngestOffset.
     * @example
     * // Create one IngestOffset
     * const IngestOffset = await prisma.ingestOffset.create({
     *   data: {
     *     // ... data to create a IngestOffset
     *   }
     * })
     *
     */
    create<T extends IngestOffsetCreateArgs>(
      args: SelectSubset<T, IngestOffsetCreateArgs<ExtArgs>>
    ): Prisma__IngestOffsetClient<
      $Result.GetResult<
        Prisma.$IngestOffsetPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many IngestOffsets.
     * @param {IngestOffsetCreateManyArgs} args - Arguments to create many IngestOffsets.
     * @example
     * // Create many IngestOffsets
     * const ingestOffset = await prisma.ingestOffset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends IngestOffsetCreateManyArgs>(
      args?: SelectSubset<T, IngestOffsetCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IngestOffsets and returns the data saved in the database.
     * @param {IngestOffsetCreateManyAndReturnArgs} args - Arguments to create many IngestOffsets.
     * @example
     * // Create many IngestOffsets
     * const ingestOffset = await prisma.ingestOffset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many IngestOffsets and only return the `id`
     * const ingestOffsetWithIdOnly = await prisma.ingestOffset.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends IngestOffsetCreateManyAndReturnArgs>(
      args?: SelectSubset<T, IngestOffsetCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$IngestOffsetPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Delete a IngestOffset.
     * @param {IngestOffsetDeleteArgs} args - Arguments to delete one IngestOffset.
     * @example
     * // Delete one IngestOffset
     * const IngestOffset = await prisma.ingestOffset.delete({
     *   where: {
     *     // ... filter to delete one IngestOffset
     *   }
     * })
     *
     */
    delete<T extends IngestOffsetDeleteArgs>(
      args: SelectSubset<T, IngestOffsetDeleteArgs<ExtArgs>>
    ): Prisma__IngestOffsetClient<
      $Result.GetResult<
        Prisma.$IngestOffsetPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one IngestOffset.
     * @param {IngestOffsetUpdateArgs} args - Arguments to update one IngestOffset.
     * @example
     * // Update one IngestOffset
     * const ingestOffset = await prisma.ingestOffset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends IngestOffsetUpdateArgs>(
      args: SelectSubset<T, IngestOffsetUpdateArgs<ExtArgs>>
    ): Prisma__IngestOffsetClient<
      $Result.GetResult<
        Prisma.$IngestOffsetPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more IngestOffsets.
     * @param {IngestOffsetDeleteManyArgs} args - Arguments to filter IngestOffsets to delete.
     * @example
     * // Delete a few IngestOffsets
     * const { count } = await prisma.ingestOffset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends IngestOffsetDeleteManyArgs>(
      args?: SelectSubset<T, IngestOffsetDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IngestOffsets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestOffsetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IngestOffsets
     * const ingestOffset = await prisma.ingestOffset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends IngestOffsetUpdateManyArgs>(
      args: SelectSubset<T, IngestOffsetUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IngestOffsets and returns the data updated in the database.
     * @param {IngestOffsetUpdateManyAndReturnArgs} args - Arguments to update many IngestOffsets.
     * @example
     * // Update many IngestOffsets
     * const ingestOffset = await prisma.ingestOffset.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more IngestOffsets and only return the `id`
     * const ingestOffsetWithIdOnly = await prisma.ingestOffset.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends IngestOffsetUpdateManyAndReturnArgs>(
      args: SelectSubset<T, IngestOffsetUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$IngestOffsetPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Create or update one IngestOffset.
     * @param {IngestOffsetUpsertArgs} args - Arguments to update or create a IngestOffset.
     * @example
     * // Update or create a IngestOffset
     * const ingestOffset = await prisma.ingestOffset.upsert({
     *   create: {
     *     // ... data to create a IngestOffset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IngestOffset we want to update
     *   }
     * })
     */
    upsert<T extends IngestOffsetUpsertArgs>(
      args: SelectSubset<T, IngestOffsetUpsertArgs<ExtArgs>>
    ): Prisma__IngestOffsetClient<
      $Result.GetResult<
        Prisma.$IngestOffsetPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of IngestOffsets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestOffsetCountArgs} args - Arguments to filter IngestOffsets to count.
     * @example
     * // Count the number of IngestOffsets
     * const count = await prisma.ingestOffset.count({
     *   where: {
     *     // ... the filter for the IngestOffsets we want to count
     *   }
     * })
     **/
    count<T extends IngestOffsetCountArgs>(
      args?: Subset<T, IngestOffsetCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IngestOffsetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IngestOffset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestOffsetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends IngestOffsetAggregateArgs>(
      args: Subset<T, IngestOffsetAggregateArgs>
    ): Prisma.PrismaPromise<GetIngestOffsetAggregateType<T>>

    /**
     * Group by IngestOffset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestOffsetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends IngestOffsetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IngestOffsetGroupByArgs['orderBy'] }
        : { orderBy?: IngestOffsetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ]
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, IngestOffsetGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetIngestOffsetGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the IngestOffset model
     */
    readonly fields: IngestOffsetFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for IngestOffset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IngestOffsetClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the IngestOffset model
   */
  interface IngestOffsetFieldRefs {
    readonly id: FieldRef<'IngestOffset', 'BigInt'>
    readonly source: FieldRef<'IngestOffset', 'String'>
    readonly partition: FieldRef<'IngestOffset', 'Int'>
    readonly lastOffset: FieldRef<'IngestOffset', 'BigInt'>
    readonly lastTimestamp: FieldRef<'IngestOffset', 'DateTime'>
    readonly payloadHash: FieldRef<'IngestOffset', 'String'>
    readonly updatedAt: FieldRef<'IngestOffset', 'DateTime'>
  }

  // Custom InputTypes
  /**
   * IngestOffset findUnique
   */
  export type IngestOffsetFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IngestOffset
     */
    select?: IngestOffsetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestOffset
     */
    omit?: IngestOffsetOmit<ExtArgs> | null
    /**
     * Filter, which IngestOffset to fetch.
     */
    where: IngestOffsetWhereUniqueInput
  }

  /**
   * IngestOffset findUniqueOrThrow
   */
  export type IngestOffsetFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IngestOffset
     */
    select?: IngestOffsetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestOffset
     */
    omit?: IngestOffsetOmit<ExtArgs> | null
    /**
     * Filter, which IngestOffset to fetch.
     */
    where: IngestOffsetWhereUniqueInput
  }

  /**
   * IngestOffset findFirst
   */
  export type IngestOffsetFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IngestOffset
     */
    select?: IngestOffsetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestOffset
     */
    omit?: IngestOffsetOmit<ExtArgs> | null
    /**
     * Filter, which IngestOffset to fetch.
     */
    where?: IngestOffsetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of IngestOffsets to fetch.
     */
    orderBy?:
      | IngestOffsetOrderByWithRelationInput
      | IngestOffsetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for IngestOffsets.
     */
    cursor?: IngestOffsetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` IngestOffsets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` IngestOffsets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of IngestOffsets.
     */
    distinct?: IngestOffsetScalarFieldEnum | IngestOffsetScalarFieldEnum[]
  }

  /**
   * IngestOffset findFirstOrThrow
   */
  export type IngestOffsetFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IngestOffset
     */
    select?: IngestOffsetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestOffset
     */
    omit?: IngestOffsetOmit<ExtArgs> | null
    /**
     * Filter, which IngestOffset to fetch.
     */
    where?: IngestOffsetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of IngestOffsets to fetch.
     */
    orderBy?:
      | IngestOffsetOrderByWithRelationInput
      | IngestOffsetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for IngestOffsets.
     */
    cursor?: IngestOffsetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` IngestOffsets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` IngestOffsets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of IngestOffsets.
     */
    distinct?: IngestOffsetScalarFieldEnum | IngestOffsetScalarFieldEnum[]
  }

  /**
   * IngestOffset findMany
   */
  export type IngestOffsetFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IngestOffset
     */
    select?: IngestOffsetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestOffset
     */
    omit?: IngestOffsetOmit<ExtArgs> | null
    /**
     * Filter, which IngestOffsets to fetch.
     */
    where?: IngestOffsetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of IngestOffsets to fetch.
     */
    orderBy?:
      | IngestOffsetOrderByWithRelationInput
      | IngestOffsetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing IngestOffsets.
     */
    cursor?: IngestOffsetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` IngestOffsets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` IngestOffsets.
     */
    skip?: number
    distinct?: IngestOffsetScalarFieldEnum | IngestOffsetScalarFieldEnum[]
  }

  /**
   * IngestOffset create
   */
  export type IngestOffsetCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IngestOffset
     */
    select?: IngestOffsetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestOffset
     */
    omit?: IngestOffsetOmit<ExtArgs> | null
    /**
     * The data needed to create a IngestOffset.
     */
    data: XOR<IngestOffsetCreateInput, IngestOffsetUncheckedCreateInput>
  }

  /**
   * IngestOffset createMany
   */
  export type IngestOffsetCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many IngestOffsets.
     */
    data: IngestOffsetCreateManyInput | IngestOffsetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IngestOffset createManyAndReturn
   */
  export type IngestOffsetCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IngestOffset
     */
    select?: IngestOffsetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IngestOffset
     */
    omit?: IngestOffsetOmit<ExtArgs> | null
    /**
     * The data used to create many IngestOffsets.
     */
    data: IngestOffsetCreateManyInput | IngestOffsetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IngestOffset update
   */
  export type IngestOffsetUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IngestOffset
     */
    select?: IngestOffsetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestOffset
     */
    omit?: IngestOffsetOmit<ExtArgs> | null
    /**
     * The data needed to update a IngestOffset.
     */
    data: XOR<IngestOffsetUpdateInput, IngestOffsetUncheckedUpdateInput>
    /**
     * Choose, which IngestOffset to update.
     */
    where: IngestOffsetWhereUniqueInput
  }

  /**
   * IngestOffset updateMany
   */
  export type IngestOffsetUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update IngestOffsets.
     */
    data: XOR<
      IngestOffsetUpdateManyMutationInput,
      IngestOffsetUncheckedUpdateManyInput
    >
    /**
     * Filter which IngestOffsets to update
     */
    where?: IngestOffsetWhereInput
    /**
     * Limit how many IngestOffsets to update.
     */
    limit?: number
  }

  /**
   * IngestOffset updateManyAndReturn
   */
  export type IngestOffsetUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IngestOffset
     */
    select?: IngestOffsetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IngestOffset
     */
    omit?: IngestOffsetOmit<ExtArgs> | null
    /**
     * The data used to update IngestOffsets.
     */
    data: XOR<
      IngestOffsetUpdateManyMutationInput,
      IngestOffsetUncheckedUpdateManyInput
    >
    /**
     * Filter which IngestOffsets to update
     */
    where?: IngestOffsetWhereInput
    /**
     * Limit how many IngestOffsets to update.
     */
    limit?: number
  }

  /**
   * IngestOffset upsert
   */
  export type IngestOffsetUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IngestOffset
     */
    select?: IngestOffsetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestOffset
     */
    omit?: IngestOffsetOmit<ExtArgs> | null
    /**
     * The filter to search for the IngestOffset to update in case it exists.
     */
    where: IngestOffsetWhereUniqueInput
    /**
     * In case the IngestOffset found by the `where` argument doesn't exist, create a new IngestOffset with this data.
     */
    create: XOR<IngestOffsetCreateInput, IngestOffsetUncheckedCreateInput>
    /**
     * In case the IngestOffset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IngestOffsetUpdateInput, IngestOffsetUncheckedUpdateInput>
  }

  /**
   * IngestOffset delete
   */
  export type IngestOffsetDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IngestOffset
     */
    select?: IngestOffsetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestOffset
     */
    omit?: IngestOffsetOmit<ExtArgs> | null
    /**
     * Filter which IngestOffset to delete.
     */
    where: IngestOffsetWhereUniqueInput
  }

  /**
   * IngestOffset deleteMany
   */
  export type IngestOffsetDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which IngestOffsets to delete
     */
    where?: IngestOffsetWhereInput
    /**
     * Limit how many IngestOffsets to delete.
     */
    limit?: number
  }

  /**
   * IngestOffset without action
   */
  export type IngestOffsetDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the IngestOffset
     */
    select?: IngestOffsetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestOffset
     */
    omit?: IngestOffsetOmit<ExtArgs> | null
  }

  /**
   * Model StagingRawEvent
   */

  export type AggregateStagingRawEvent = {
    _count: StagingRawEventCountAggregateOutputType | null
    _avg: StagingRawEventAvgAggregateOutputType | null
    _sum: StagingRawEventSumAggregateOutputType | null
    _min: StagingRawEventMinAggregateOutputType | null
    _max: StagingRawEventMaxAggregateOutputType | null
  }

  export type StagingRawEventAvgAggregateOutputType = {
    id: number | null
    retryCount: number | null
  }

  export type StagingRawEventSumAggregateOutputType = {
    id: bigint | null
    retryCount: number | null
  }

  export type StagingRawEventMinAggregateOutputType = {
    id: bigint | null
    eventType: string | null
    source: string | null
    receivedAt: Date | null
    processedAt: Date | null
    status: string | null
    error: string | null
    retryCount: number | null
  }

  export type StagingRawEventMaxAggregateOutputType = {
    id: bigint | null
    eventType: string | null
    source: string | null
    receivedAt: Date | null
    processedAt: Date | null
    status: string | null
    error: string | null
    retryCount: number | null
  }

  export type StagingRawEventCountAggregateOutputType = {
    id: number
    eventType: number
    source: number
    payload: number
    headers: number
    receivedAt: number
    processedAt: number
    status: number
    error: number
    retryCount: number
    _all: number
  }

  export type StagingRawEventAvgAggregateInputType = {
    id?: true
    retryCount?: true
  }

  export type StagingRawEventSumAggregateInputType = {
    id?: true
    retryCount?: true
  }

  export type StagingRawEventMinAggregateInputType = {
    id?: true
    eventType?: true
    source?: true
    receivedAt?: true
    processedAt?: true
    status?: true
    error?: true
    retryCount?: true
  }

  export type StagingRawEventMaxAggregateInputType = {
    id?: true
    eventType?: true
    source?: true
    receivedAt?: true
    processedAt?: true
    status?: true
    error?: true
    retryCount?: true
  }

  export type StagingRawEventCountAggregateInputType = {
    id?: true
    eventType?: true
    source?: true
    payload?: true
    headers?: true
    receivedAt?: true
    processedAt?: true
    status?: true
    error?: true
    retryCount?: true
    _all?: true
  }

  export type StagingRawEventAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which StagingRawEvent to aggregate.
     */
    where?: StagingRawEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of StagingRawEvents to fetch.
     */
    orderBy?:
      | StagingRawEventOrderByWithRelationInput
      | StagingRawEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: StagingRawEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` StagingRawEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` StagingRawEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned StagingRawEvents
     **/
    _count?: true | StagingRawEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: StagingRawEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: StagingRawEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: StagingRawEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: StagingRawEventMaxAggregateInputType
  }

  export type GetStagingRawEventAggregateType<
    T extends StagingRawEventAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateStagingRawEvent]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStagingRawEvent[P]>
      : GetScalarType<T[P], AggregateStagingRawEvent[P]>
  }

  export type StagingRawEventGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: StagingRawEventWhereInput
    orderBy?:
      | StagingRawEventOrderByWithAggregationInput
      | StagingRawEventOrderByWithAggregationInput[]
    by: StagingRawEventScalarFieldEnum[] | StagingRawEventScalarFieldEnum
    having?: StagingRawEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StagingRawEventCountAggregateInputType | true
    _avg?: StagingRawEventAvgAggregateInputType
    _sum?: StagingRawEventSumAggregateInputType
    _min?: StagingRawEventMinAggregateInputType
    _max?: StagingRawEventMaxAggregateInputType
  }

  export type StagingRawEventGroupByOutputType = {
    id: bigint
    eventType: string
    source: string
    payload: JsonValue
    headers: JsonValue | null
    receivedAt: Date
    processedAt: Date | null
    status: string
    error: string | null
    retryCount: number
    _count: StagingRawEventCountAggregateOutputType | null
    _avg: StagingRawEventAvgAggregateOutputType | null
    _sum: StagingRawEventSumAggregateOutputType | null
    _min: StagingRawEventMinAggregateOutputType | null
    _max: StagingRawEventMaxAggregateOutputType | null
  }

  type GetStagingRawEventGroupByPayload<T extends StagingRawEventGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<StagingRawEventGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof StagingRawEventGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StagingRawEventGroupByOutputType[P]>
            : GetScalarType<T[P], StagingRawEventGroupByOutputType[P]>
        }
      >
    >

  export type StagingRawEventSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      eventType?: boolean
      source?: boolean
      payload?: boolean
      headers?: boolean
      receivedAt?: boolean
      processedAt?: boolean
      status?: boolean
      error?: boolean
      retryCount?: boolean
    },
    ExtArgs['result']['stagingRawEvent']
  >

  export type StagingRawEventSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      eventType?: boolean
      source?: boolean
      payload?: boolean
      headers?: boolean
      receivedAt?: boolean
      processedAt?: boolean
      status?: boolean
      error?: boolean
      retryCount?: boolean
    },
    ExtArgs['result']['stagingRawEvent']
  >

  export type StagingRawEventSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean
      eventType?: boolean
      source?: boolean
      payload?: boolean
      headers?: boolean
      receivedAt?: boolean
      processedAt?: boolean
      status?: boolean
      error?: boolean
      retryCount?: boolean
    },
    ExtArgs['result']['stagingRawEvent']
  >

  export type StagingRawEventSelectScalar = {
    id?: boolean
    eventType?: boolean
    source?: boolean
    payload?: boolean
    headers?: boolean
    receivedAt?: boolean
    processedAt?: boolean
    status?: boolean
    error?: boolean
    retryCount?: boolean
  }

  export type StagingRawEventOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'eventType'
    | 'source'
    | 'payload'
    | 'headers'
    | 'receivedAt'
    | 'processedAt'
    | 'status'
    | 'error'
    | 'retryCount',
    ExtArgs['result']['stagingRawEvent']
  >

  export type $StagingRawEventPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'StagingRawEvent'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        id: bigint
        eventType: string
        source: string
        payload: Prisma.JsonValue
        headers: Prisma.JsonValue | null
        receivedAt: Date
        processedAt: Date | null
        status: string
        error: string | null
        retryCount: number
      },
      ExtArgs['result']['stagingRawEvent']
    >
    composites: {}
  }

  type StagingRawEventGetPayload<
    S extends boolean | null | undefined | StagingRawEventDefaultArgs,
  > = $Result.GetResult<Prisma.$StagingRawEventPayload, S>

  type StagingRawEventCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    StagingRawEventFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: StagingRawEventCountAggregateInputType | true
  }

  export interface StagingRawEventDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['StagingRawEvent']
      meta: { name: 'StagingRawEvent' }
    }
    /**
     * Find zero or one StagingRawEvent that matches the filter.
     * @param {StagingRawEventFindUniqueArgs} args - Arguments to find a StagingRawEvent
     * @example
     * // Get one StagingRawEvent
     * const stagingRawEvent = await prisma.stagingRawEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StagingRawEventFindUniqueArgs>(
      args: SelectSubset<T, StagingRawEventFindUniqueArgs<ExtArgs>>
    ): Prisma__StagingRawEventClient<
      $Result.GetResult<
        Prisma.$StagingRawEventPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one StagingRawEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StagingRawEventFindUniqueOrThrowArgs} args - Arguments to find a StagingRawEvent
     * @example
     * // Get one StagingRawEvent
     * const stagingRawEvent = await prisma.stagingRawEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StagingRawEventFindUniqueOrThrowArgs>(
      args: SelectSubset<T, StagingRawEventFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StagingRawEventClient<
      $Result.GetResult<
        Prisma.$StagingRawEventPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first StagingRawEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StagingRawEventFindFirstArgs} args - Arguments to find a StagingRawEvent
     * @example
     * // Get one StagingRawEvent
     * const stagingRawEvent = await prisma.stagingRawEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StagingRawEventFindFirstArgs>(
      args?: SelectSubset<T, StagingRawEventFindFirstArgs<ExtArgs>>
    ): Prisma__StagingRawEventClient<
      $Result.GetResult<
        Prisma.$StagingRawEventPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first StagingRawEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StagingRawEventFindFirstOrThrowArgs} args - Arguments to find a StagingRawEvent
     * @example
     * // Get one StagingRawEvent
     * const stagingRawEvent = await prisma.stagingRawEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StagingRawEventFindFirstOrThrowArgs>(
      args?: SelectSubset<T, StagingRawEventFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StagingRawEventClient<
      $Result.GetResult<
        Prisma.$StagingRawEventPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more StagingRawEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StagingRawEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StagingRawEvents
     * const stagingRawEvents = await prisma.stagingRawEvent.findMany()
     *
     * // Get first 10 StagingRawEvents
     * const stagingRawEvents = await prisma.stagingRawEvent.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const stagingRawEventWithIdOnly = await prisma.stagingRawEvent.findMany({ select: { id: true } })
     *
     */
    findMany<T extends StagingRawEventFindManyArgs>(
      args?: SelectSubset<T, StagingRawEventFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$StagingRawEventPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a StagingRawEvent.
     * @param {StagingRawEventCreateArgs} args - Arguments to create a StagingRawEvent.
     * @example
     * // Create one StagingRawEvent
     * const StagingRawEvent = await prisma.stagingRawEvent.create({
     *   data: {
     *     // ... data to create a StagingRawEvent
     *   }
     * })
     *
     */
    create<T extends StagingRawEventCreateArgs>(
      args: SelectSubset<T, StagingRawEventCreateArgs<ExtArgs>>
    ): Prisma__StagingRawEventClient<
      $Result.GetResult<
        Prisma.$StagingRawEventPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many StagingRawEvents.
     * @param {StagingRawEventCreateManyArgs} args - Arguments to create many StagingRawEvents.
     * @example
     * // Create many StagingRawEvents
     * const stagingRawEvent = await prisma.stagingRawEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends StagingRawEventCreateManyArgs>(
      args?: SelectSubset<T, StagingRawEventCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StagingRawEvents and returns the data saved in the database.
     * @param {StagingRawEventCreateManyAndReturnArgs} args - Arguments to create many StagingRawEvents.
     * @example
     * // Create many StagingRawEvents
     * const stagingRawEvent = await prisma.stagingRawEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many StagingRawEvents and only return the `id`
     * const stagingRawEventWithIdOnly = await prisma.stagingRawEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends StagingRawEventCreateManyAndReturnArgs>(
      args?: SelectSubset<T, StagingRawEventCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$StagingRawEventPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Delete a StagingRawEvent.
     * @param {StagingRawEventDeleteArgs} args - Arguments to delete one StagingRawEvent.
     * @example
     * // Delete one StagingRawEvent
     * const StagingRawEvent = await prisma.stagingRawEvent.delete({
     *   where: {
     *     // ... filter to delete one StagingRawEvent
     *   }
     * })
     *
     */
    delete<T extends StagingRawEventDeleteArgs>(
      args: SelectSubset<T, StagingRawEventDeleteArgs<ExtArgs>>
    ): Prisma__StagingRawEventClient<
      $Result.GetResult<
        Prisma.$StagingRawEventPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one StagingRawEvent.
     * @param {StagingRawEventUpdateArgs} args - Arguments to update one StagingRawEvent.
     * @example
     * // Update one StagingRawEvent
     * const stagingRawEvent = await prisma.stagingRawEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends StagingRawEventUpdateArgs>(
      args: SelectSubset<T, StagingRawEventUpdateArgs<ExtArgs>>
    ): Prisma__StagingRawEventClient<
      $Result.GetResult<
        Prisma.$StagingRawEventPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more StagingRawEvents.
     * @param {StagingRawEventDeleteManyArgs} args - Arguments to filter StagingRawEvents to delete.
     * @example
     * // Delete a few StagingRawEvents
     * const { count } = await prisma.stagingRawEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends StagingRawEventDeleteManyArgs>(
      args?: SelectSubset<T, StagingRawEventDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StagingRawEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StagingRawEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StagingRawEvents
     * const stagingRawEvent = await prisma.stagingRawEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends StagingRawEventUpdateManyArgs>(
      args: SelectSubset<T, StagingRawEventUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StagingRawEvents and returns the data updated in the database.
     * @param {StagingRawEventUpdateManyAndReturnArgs} args - Arguments to update many StagingRawEvents.
     * @example
     * // Update many StagingRawEvents
     * const stagingRawEvent = await prisma.stagingRawEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more StagingRawEvents and only return the `id`
     * const stagingRawEventWithIdOnly = await prisma.stagingRawEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends StagingRawEventUpdateManyAndReturnArgs>(
      args: SelectSubset<T, StagingRawEventUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$StagingRawEventPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Create or update one StagingRawEvent.
     * @param {StagingRawEventUpsertArgs} args - Arguments to update or create a StagingRawEvent.
     * @example
     * // Update or create a StagingRawEvent
     * const stagingRawEvent = await prisma.stagingRawEvent.upsert({
     *   create: {
     *     // ... data to create a StagingRawEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StagingRawEvent we want to update
     *   }
     * })
     */
    upsert<T extends StagingRawEventUpsertArgs>(
      args: SelectSubset<T, StagingRawEventUpsertArgs<ExtArgs>>
    ): Prisma__StagingRawEventClient<
      $Result.GetResult<
        Prisma.$StagingRawEventPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of StagingRawEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StagingRawEventCountArgs} args - Arguments to filter StagingRawEvents to count.
     * @example
     * // Count the number of StagingRawEvents
     * const count = await prisma.stagingRawEvent.count({
     *   where: {
     *     // ... the filter for the StagingRawEvents we want to count
     *   }
     * })
     **/
    count<T extends StagingRawEventCountArgs>(
      args?: Subset<T, StagingRawEventCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StagingRawEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StagingRawEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StagingRawEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends StagingRawEventAggregateArgs>(
      args: Subset<T, StagingRawEventAggregateArgs>
    ): Prisma.PrismaPromise<GetStagingRawEventAggregateType<T>>

    /**
     * Group by StagingRawEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StagingRawEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends StagingRawEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StagingRawEventGroupByArgs['orderBy'] }
        : { orderBy?: StagingRawEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ]
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, StagingRawEventGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetStagingRawEventGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the StagingRawEvent model
     */
    readonly fields: StagingRawEventFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for StagingRawEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StagingRawEventClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the StagingRawEvent model
   */
  interface StagingRawEventFieldRefs {
    readonly id: FieldRef<'StagingRawEvent', 'BigInt'>
    readonly eventType: FieldRef<'StagingRawEvent', 'String'>
    readonly source: FieldRef<'StagingRawEvent', 'String'>
    readonly payload: FieldRef<'StagingRawEvent', 'Json'>
    readonly headers: FieldRef<'StagingRawEvent', 'Json'>
    readonly receivedAt: FieldRef<'StagingRawEvent', 'DateTime'>
    readonly processedAt: FieldRef<'StagingRawEvent', 'DateTime'>
    readonly status: FieldRef<'StagingRawEvent', 'String'>
    readonly error: FieldRef<'StagingRawEvent', 'String'>
    readonly retryCount: FieldRef<'StagingRawEvent', 'Int'>
  }

  // Custom InputTypes
  /**
   * StagingRawEvent findUnique
   */
  export type StagingRawEventFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StagingRawEvent
     */
    select?: StagingRawEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StagingRawEvent
     */
    omit?: StagingRawEventOmit<ExtArgs> | null
    /**
     * Filter, which StagingRawEvent to fetch.
     */
    where: StagingRawEventWhereUniqueInput
  }

  /**
   * StagingRawEvent findUniqueOrThrow
   */
  export type StagingRawEventFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StagingRawEvent
     */
    select?: StagingRawEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StagingRawEvent
     */
    omit?: StagingRawEventOmit<ExtArgs> | null
    /**
     * Filter, which StagingRawEvent to fetch.
     */
    where: StagingRawEventWhereUniqueInput
  }

  /**
   * StagingRawEvent findFirst
   */
  export type StagingRawEventFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StagingRawEvent
     */
    select?: StagingRawEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StagingRawEvent
     */
    omit?: StagingRawEventOmit<ExtArgs> | null
    /**
     * Filter, which StagingRawEvent to fetch.
     */
    where?: StagingRawEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of StagingRawEvents to fetch.
     */
    orderBy?:
      | StagingRawEventOrderByWithRelationInput
      | StagingRawEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for StagingRawEvents.
     */
    cursor?: StagingRawEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` StagingRawEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` StagingRawEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of StagingRawEvents.
     */
    distinct?: StagingRawEventScalarFieldEnum | StagingRawEventScalarFieldEnum[]
  }

  /**
   * StagingRawEvent findFirstOrThrow
   */
  export type StagingRawEventFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StagingRawEvent
     */
    select?: StagingRawEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StagingRawEvent
     */
    omit?: StagingRawEventOmit<ExtArgs> | null
    /**
     * Filter, which StagingRawEvent to fetch.
     */
    where?: StagingRawEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of StagingRawEvents to fetch.
     */
    orderBy?:
      | StagingRawEventOrderByWithRelationInput
      | StagingRawEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for StagingRawEvents.
     */
    cursor?: StagingRawEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` StagingRawEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` StagingRawEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of StagingRawEvents.
     */
    distinct?: StagingRawEventScalarFieldEnum | StagingRawEventScalarFieldEnum[]
  }

  /**
   * StagingRawEvent findMany
   */
  export type StagingRawEventFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StagingRawEvent
     */
    select?: StagingRawEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StagingRawEvent
     */
    omit?: StagingRawEventOmit<ExtArgs> | null
    /**
     * Filter, which StagingRawEvents to fetch.
     */
    where?: StagingRawEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of StagingRawEvents to fetch.
     */
    orderBy?:
      | StagingRawEventOrderByWithRelationInput
      | StagingRawEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing StagingRawEvents.
     */
    cursor?: StagingRawEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` StagingRawEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` StagingRawEvents.
     */
    skip?: number
    distinct?: StagingRawEventScalarFieldEnum | StagingRawEventScalarFieldEnum[]
  }

  /**
   * StagingRawEvent create
   */
  export type StagingRawEventCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StagingRawEvent
     */
    select?: StagingRawEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StagingRawEvent
     */
    omit?: StagingRawEventOmit<ExtArgs> | null
    /**
     * The data needed to create a StagingRawEvent.
     */
    data: XOR<StagingRawEventCreateInput, StagingRawEventUncheckedCreateInput>
  }

  /**
   * StagingRawEvent createMany
   */
  export type StagingRawEventCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many StagingRawEvents.
     */
    data: StagingRawEventCreateManyInput | StagingRawEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StagingRawEvent createManyAndReturn
   */
  export type StagingRawEventCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StagingRawEvent
     */
    select?: StagingRawEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StagingRawEvent
     */
    omit?: StagingRawEventOmit<ExtArgs> | null
    /**
     * The data used to create many StagingRawEvents.
     */
    data: StagingRawEventCreateManyInput | StagingRawEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StagingRawEvent update
   */
  export type StagingRawEventUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StagingRawEvent
     */
    select?: StagingRawEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StagingRawEvent
     */
    omit?: StagingRawEventOmit<ExtArgs> | null
    /**
     * The data needed to update a StagingRawEvent.
     */
    data: XOR<StagingRawEventUpdateInput, StagingRawEventUncheckedUpdateInput>
    /**
     * Choose, which StagingRawEvent to update.
     */
    where: StagingRawEventWhereUniqueInput
  }

  /**
   * StagingRawEvent updateMany
   */
  export type StagingRawEventUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update StagingRawEvents.
     */
    data: XOR<
      StagingRawEventUpdateManyMutationInput,
      StagingRawEventUncheckedUpdateManyInput
    >
    /**
     * Filter which StagingRawEvents to update
     */
    where?: StagingRawEventWhereInput
    /**
     * Limit how many StagingRawEvents to update.
     */
    limit?: number
  }

  /**
   * StagingRawEvent updateManyAndReturn
   */
  export type StagingRawEventUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StagingRawEvent
     */
    select?: StagingRawEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StagingRawEvent
     */
    omit?: StagingRawEventOmit<ExtArgs> | null
    /**
     * The data used to update StagingRawEvents.
     */
    data: XOR<
      StagingRawEventUpdateManyMutationInput,
      StagingRawEventUncheckedUpdateManyInput
    >
    /**
     * Filter which StagingRawEvents to update
     */
    where?: StagingRawEventWhereInput
    /**
     * Limit how many StagingRawEvents to update.
     */
    limit?: number
  }

  /**
   * StagingRawEvent upsert
   */
  export type StagingRawEventUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StagingRawEvent
     */
    select?: StagingRawEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StagingRawEvent
     */
    omit?: StagingRawEventOmit<ExtArgs> | null
    /**
     * The filter to search for the StagingRawEvent to update in case it exists.
     */
    where: StagingRawEventWhereUniqueInput
    /**
     * In case the StagingRawEvent found by the `where` argument doesn't exist, create a new StagingRawEvent with this data.
     */
    create: XOR<StagingRawEventCreateInput, StagingRawEventUncheckedCreateInput>
    /**
     * In case the StagingRawEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StagingRawEventUpdateInput, StagingRawEventUncheckedUpdateInput>
  }

  /**
   * StagingRawEvent delete
   */
  export type StagingRawEventDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StagingRawEvent
     */
    select?: StagingRawEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StagingRawEvent
     */
    omit?: StagingRawEventOmit<ExtArgs> | null
    /**
     * Filter which StagingRawEvent to delete.
     */
    where: StagingRawEventWhereUniqueInput
  }

  /**
   * StagingRawEvent deleteMany
   */
  export type StagingRawEventDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which StagingRawEvents to delete
     */
    where?: StagingRawEventWhereInput
    /**
     * Limit how many StagingRawEvents to delete.
     */
    limit?: number
  }

  /**
   * StagingRawEvent without action
   */
  export type StagingRawEventDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StagingRawEvent
     */
    select?: StagingRawEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StagingRawEvent
     */
    omit?: StagingRawEventOmit<ExtArgs> | null
  }

  /**
   * Model AggDailyStats
   */

  export type AggregateAggDailyStats = {
    _count: AggDailyStatsCountAggregateOutputType | null
    _avg: AggDailyStatsAvgAggregateOutputType | null
    _sum: AggDailyStatsSumAggregateOutputType | null
    _min: AggDailyStatsMinAggregateOutputType | null
    _max: AggDailyStatsMaxAggregateOutputType | null
  }

  export type AggDailyStatsAvgAggregateOutputType = {
    dateId: number | null
    totalRevenue: Decimal | null
    totalOrders: number | null
    totalVisits: number | null
    conversionRate: Decimal | null
    aov: Decimal | null
  }

  export type AggDailyStatsSumAggregateOutputType = {
    dateId: number | null
    totalRevenue: Decimal | null
    totalOrders: number | null
    totalVisits: number | null
    conversionRate: Decimal | null
    aov: Decimal | null
  }

  export type AggDailyStatsMinAggregateOutputType = {
    dateId: number | null
    totalRevenue: Decimal | null
    totalOrders: number | null
    totalVisits: number | null
    conversionRate: Decimal | null
    aov: Decimal | null
    updatedAt: Date | null
  }

  export type AggDailyStatsMaxAggregateOutputType = {
    dateId: number | null
    totalRevenue: Decimal | null
    totalOrders: number | null
    totalVisits: number | null
    conversionRate: Decimal | null
    aov: Decimal | null
    updatedAt: Date | null
  }

  export type AggDailyStatsCountAggregateOutputType = {
    dateId: number
    totalRevenue: number
    totalOrders: number
    totalVisits: number
    conversionRate: number
    aov: number
    updatedAt: number
    _all: number
  }

  export type AggDailyStatsAvgAggregateInputType = {
    dateId?: true
    totalRevenue?: true
    totalOrders?: true
    totalVisits?: true
    conversionRate?: true
    aov?: true
  }

  export type AggDailyStatsSumAggregateInputType = {
    dateId?: true
    totalRevenue?: true
    totalOrders?: true
    totalVisits?: true
    conversionRate?: true
    aov?: true
  }

  export type AggDailyStatsMinAggregateInputType = {
    dateId?: true
    totalRevenue?: true
    totalOrders?: true
    totalVisits?: true
    conversionRate?: true
    aov?: true
    updatedAt?: true
  }

  export type AggDailyStatsMaxAggregateInputType = {
    dateId?: true
    totalRevenue?: true
    totalOrders?: true
    totalVisits?: true
    conversionRate?: true
    aov?: true
    updatedAt?: true
  }

  export type AggDailyStatsCountAggregateInputType = {
    dateId?: true
    totalRevenue?: true
    totalOrders?: true
    totalVisits?: true
    conversionRate?: true
    aov?: true
    updatedAt?: true
    _all?: true
  }

  export type AggDailyStatsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AggDailyStats to aggregate.
     */
    where?: AggDailyStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AggDailyStats to fetch.
     */
    orderBy?:
      | AggDailyStatsOrderByWithRelationInput
      | AggDailyStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AggDailyStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AggDailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AggDailyStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned AggDailyStats
     **/
    _count?: true | AggDailyStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: AggDailyStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: AggDailyStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AggDailyStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AggDailyStatsMaxAggregateInputType
  }

  export type GetAggDailyStatsAggregateType<
    T extends AggDailyStatsAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateAggDailyStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAggDailyStats[P]>
      : GetScalarType<T[P], AggregateAggDailyStats[P]>
  }

  export type AggDailyStatsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AggDailyStatsWhereInput
    orderBy?:
      | AggDailyStatsOrderByWithAggregationInput
      | AggDailyStatsOrderByWithAggregationInput[]
    by: AggDailyStatsScalarFieldEnum[] | AggDailyStatsScalarFieldEnum
    having?: AggDailyStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AggDailyStatsCountAggregateInputType | true
    _avg?: AggDailyStatsAvgAggregateInputType
    _sum?: AggDailyStatsSumAggregateInputType
    _min?: AggDailyStatsMinAggregateInputType
    _max?: AggDailyStatsMaxAggregateInputType
  }

  export type AggDailyStatsGroupByOutputType = {
    dateId: number
    totalRevenue: Decimal
    totalOrders: number
    totalVisits: number
    conversionRate: Decimal | null
    aov: Decimal | null
    updatedAt: Date
    _count: AggDailyStatsCountAggregateOutputType | null
    _avg: AggDailyStatsAvgAggregateOutputType | null
    _sum: AggDailyStatsSumAggregateOutputType | null
    _min: AggDailyStatsMinAggregateOutputType | null
    _max: AggDailyStatsMaxAggregateOutputType | null
  }

  type GetAggDailyStatsGroupByPayload<T extends AggDailyStatsGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<AggDailyStatsGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof AggDailyStatsGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AggDailyStatsGroupByOutputType[P]>
            : GetScalarType<T[P], AggDailyStatsGroupByOutputType[P]>
        }
      >
    >

  export type AggDailyStatsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      dateId?: boolean
      totalRevenue?: boolean
      totalOrders?: boolean
      totalVisits?: boolean
      conversionRate?: boolean
      aov?: boolean
      updatedAt?: boolean
    },
    ExtArgs['result']['aggDailyStats']
  >

  export type AggDailyStatsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      dateId?: boolean
      totalRevenue?: boolean
      totalOrders?: boolean
      totalVisits?: boolean
      conversionRate?: boolean
      aov?: boolean
      updatedAt?: boolean
    },
    ExtArgs['result']['aggDailyStats']
  >

  export type AggDailyStatsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      dateId?: boolean
      totalRevenue?: boolean
      totalOrders?: boolean
      totalVisits?: boolean
      conversionRate?: boolean
      aov?: boolean
      updatedAt?: boolean
    },
    ExtArgs['result']['aggDailyStats']
  >

  export type AggDailyStatsSelectScalar = {
    dateId?: boolean
    totalRevenue?: boolean
    totalOrders?: boolean
    totalVisits?: boolean
    conversionRate?: boolean
    aov?: boolean
    updatedAt?: boolean
  }

  export type AggDailyStatsOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'dateId'
    | 'totalRevenue'
    | 'totalOrders'
    | 'totalVisits'
    | 'conversionRate'
    | 'aov'
    | 'updatedAt',
    ExtArgs['result']['aggDailyStats']
  >

  export type $AggDailyStatsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'AggDailyStats'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        dateId: number
        totalRevenue: Prisma.Decimal
        totalOrders: number
        totalVisits: number
        conversionRate: Prisma.Decimal | null
        aov: Prisma.Decimal | null
        updatedAt: Date
      },
      ExtArgs['result']['aggDailyStats']
    >
    composites: {}
  }

  type AggDailyStatsGetPayload<
    S extends boolean | null | undefined | AggDailyStatsDefaultArgs,
  > = $Result.GetResult<Prisma.$AggDailyStatsPayload, S>

  type AggDailyStatsCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    AggDailyStatsFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: AggDailyStatsCountAggregateInputType | true
  }

  export interface AggDailyStatsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['AggDailyStats']
      meta: { name: 'AggDailyStats' }
    }
    /**
     * Find zero or one AggDailyStats that matches the filter.
     * @param {AggDailyStatsFindUniqueArgs} args - Arguments to find a AggDailyStats
     * @example
     * // Get one AggDailyStats
     * const aggDailyStats = await prisma.aggDailyStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AggDailyStatsFindUniqueArgs>(
      args: SelectSubset<T, AggDailyStatsFindUniqueArgs<ExtArgs>>
    ): Prisma__AggDailyStatsClient<
      $Result.GetResult<
        Prisma.$AggDailyStatsPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one AggDailyStats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AggDailyStatsFindUniqueOrThrowArgs} args - Arguments to find a AggDailyStats
     * @example
     * // Get one AggDailyStats
     * const aggDailyStats = await prisma.aggDailyStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AggDailyStatsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AggDailyStatsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AggDailyStatsClient<
      $Result.GetResult<
        Prisma.$AggDailyStatsPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first AggDailyStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AggDailyStatsFindFirstArgs} args - Arguments to find a AggDailyStats
     * @example
     * // Get one AggDailyStats
     * const aggDailyStats = await prisma.aggDailyStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AggDailyStatsFindFirstArgs>(
      args?: SelectSubset<T, AggDailyStatsFindFirstArgs<ExtArgs>>
    ): Prisma__AggDailyStatsClient<
      $Result.GetResult<
        Prisma.$AggDailyStatsPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first AggDailyStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AggDailyStatsFindFirstOrThrowArgs} args - Arguments to find a AggDailyStats
     * @example
     * // Get one AggDailyStats
     * const aggDailyStats = await prisma.aggDailyStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AggDailyStatsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AggDailyStatsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AggDailyStatsClient<
      $Result.GetResult<
        Prisma.$AggDailyStatsPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more AggDailyStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AggDailyStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AggDailyStats
     * const aggDailyStats = await prisma.aggDailyStats.findMany()
     *
     * // Get first 10 AggDailyStats
     * const aggDailyStats = await prisma.aggDailyStats.findMany({ take: 10 })
     *
     * // Only select the `dateId`
     * const aggDailyStatsWithDateIdOnly = await prisma.aggDailyStats.findMany({ select: { dateId: true } })
     *
     */
    findMany<T extends AggDailyStatsFindManyArgs>(
      args?: SelectSubset<T, AggDailyStatsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AggDailyStatsPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a AggDailyStats.
     * @param {AggDailyStatsCreateArgs} args - Arguments to create a AggDailyStats.
     * @example
     * // Create one AggDailyStats
     * const AggDailyStats = await prisma.aggDailyStats.create({
     *   data: {
     *     // ... data to create a AggDailyStats
     *   }
     * })
     *
     */
    create<T extends AggDailyStatsCreateArgs>(
      args: SelectSubset<T, AggDailyStatsCreateArgs<ExtArgs>>
    ): Prisma__AggDailyStatsClient<
      $Result.GetResult<
        Prisma.$AggDailyStatsPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many AggDailyStats.
     * @param {AggDailyStatsCreateManyArgs} args - Arguments to create many AggDailyStats.
     * @example
     * // Create many AggDailyStats
     * const aggDailyStats = await prisma.aggDailyStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AggDailyStatsCreateManyArgs>(
      args?: SelectSubset<T, AggDailyStatsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AggDailyStats and returns the data saved in the database.
     * @param {AggDailyStatsCreateManyAndReturnArgs} args - Arguments to create many AggDailyStats.
     * @example
     * // Create many AggDailyStats
     * const aggDailyStats = await prisma.aggDailyStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many AggDailyStats and only return the `dateId`
     * const aggDailyStatsWithDateIdOnly = await prisma.aggDailyStats.createManyAndReturn({
     *   select: { dateId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AggDailyStatsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, AggDailyStatsCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AggDailyStatsPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Delete a AggDailyStats.
     * @param {AggDailyStatsDeleteArgs} args - Arguments to delete one AggDailyStats.
     * @example
     * // Delete one AggDailyStats
     * const AggDailyStats = await prisma.aggDailyStats.delete({
     *   where: {
     *     // ... filter to delete one AggDailyStats
     *   }
     * })
     *
     */
    delete<T extends AggDailyStatsDeleteArgs>(
      args: SelectSubset<T, AggDailyStatsDeleteArgs<ExtArgs>>
    ): Prisma__AggDailyStatsClient<
      $Result.GetResult<
        Prisma.$AggDailyStatsPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one AggDailyStats.
     * @param {AggDailyStatsUpdateArgs} args - Arguments to update one AggDailyStats.
     * @example
     * // Update one AggDailyStats
     * const aggDailyStats = await prisma.aggDailyStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AggDailyStatsUpdateArgs>(
      args: SelectSubset<T, AggDailyStatsUpdateArgs<ExtArgs>>
    ): Prisma__AggDailyStatsClient<
      $Result.GetResult<
        Prisma.$AggDailyStatsPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more AggDailyStats.
     * @param {AggDailyStatsDeleteManyArgs} args - Arguments to filter AggDailyStats to delete.
     * @example
     * // Delete a few AggDailyStats
     * const { count } = await prisma.aggDailyStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AggDailyStatsDeleteManyArgs>(
      args?: SelectSubset<T, AggDailyStatsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AggDailyStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AggDailyStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AggDailyStats
     * const aggDailyStats = await prisma.aggDailyStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AggDailyStatsUpdateManyArgs>(
      args: SelectSubset<T, AggDailyStatsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AggDailyStats and returns the data updated in the database.
     * @param {AggDailyStatsUpdateManyAndReturnArgs} args - Arguments to update many AggDailyStats.
     * @example
     * // Update many AggDailyStats
     * const aggDailyStats = await prisma.aggDailyStats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more AggDailyStats and only return the `dateId`
     * const aggDailyStatsWithDateIdOnly = await prisma.aggDailyStats.updateManyAndReturn({
     *   select: { dateId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends AggDailyStatsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, AggDailyStatsUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AggDailyStatsPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Create or update one AggDailyStats.
     * @param {AggDailyStatsUpsertArgs} args - Arguments to update or create a AggDailyStats.
     * @example
     * // Update or create a AggDailyStats
     * const aggDailyStats = await prisma.aggDailyStats.upsert({
     *   create: {
     *     // ... data to create a AggDailyStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AggDailyStats we want to update
     *   }
     * })
     */
    upsert<T extends AggDailyStatsUpsertArgs>(
      args: SelectSubset<T, AggDailyStatsUpsertArgs<ExtArgs>>
    ): Prisma__AggDailyStatsClient<
      $Result.GetResult<
        Prisma.$AggDailyStatsPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of AggDailyStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AggDailyStatsCountArgs} args - Arguments to filter AggDailyStats to count.
     * @example
     * // Count the number of AggDailyStats
     * const count = await prisma.aggDailyStats.count({
     *   where: {
     *     // ... the filter for the AggDailyStats we want to count
     *   }
     * })
     **/
    count<T extends AggDailyStatsCountArgs>(
      args?: Subset<T, AggDailyStatsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AggDailyStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AggDailyStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AggDailyStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AggDailyStatsAggregateArgs>(
      args: Subset<T, AggDailyStatsAggregateArgs>
    ): Prisma.PrismaPromise<GetAggDailyStatsAggregateType<T>>

    /**
     * Group by AggDailyStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AggDailyStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AggDailyStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AggDailyStatsGroupByArgs['orderBy'] }
        : { orderBy?: AggDailyStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ]
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AggDailyStatsGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetAggDailyStatsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the AggDailyStats model
     */
    readonly fields: AggDailyStatsFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for AggDailyStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AggDailyStatsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the AggDailyStats model
   */
  interface AggDailyStatsFieldRefs {
    readonly dateId: FieldRef<'AggDailyStats', 'Int'>
    readonly totalRevenue: FieldRef<'AggDailyStats', 'Decimal'>
    readonly totalOrders: FieldRef<'AggDailyStats', 'Int'>
    readonly totalVisits: FieldRef<'AggDailyStats', 'Int'>
    readonly conversionRate: FieldRef<'AggDailyStats', 'Decimal'>
    readonly aov: FieldRef<'AggDailyStats', 'Decimal'>
    readonly updatedAt: FieldRef<'AggDailyStats', 'DateTime'>
  }

  // Custom InputTypes
  /**
   * AggDailyStats findUnique
   */
  export type AggDailyStatsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AggDailyStats
     */
    select?: AggDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AggDailyStats
     */
    omit?: AggDailyStatsOmit<ExtArgs> | null
    /**
     * Filter, which AggDailyStats to fetch.
     */
    where: AggDailyStatsWhereUniqueInput
  }

  /**
   * AggDailyStats findUniqueOrThrow
   */
  export type AggDailyStatsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AggDailyStats
     */
    select?: AggDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AggDailyStats
     */
    omit?: AggDailyStatsOmit<ExtArgs> | null
    /**
     * Filter, which AggDailyStats to fetch.
     */
    where: AggDailyStatsWhereUniqueInput
  }

  /**
   * AggDailyStats findFirst
   */
  export type AggDailyStatsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AggDailyStats
     */
    select?: AggDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AggDailyStats
     */
    omit?: AggDailyStatsOmit<ExtArgs> | null
    /**
     * Filter, which AggDailyStats to fetch.
     */
    where?: AggDailyStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AggDailyStats to fetch.
     */
    orderBy?:
      | AggDailyStatsOrderByWithRelationInput
      | AggDailyStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AggDailyStats.
     */
    cursor?: AggDailyStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AggDailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AggDailyStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AggDailyStats.
     */
    distinct?: AggDailyStatsScalarFieldEnum | AggDailyStatsScalarFieldEnum[]
  }

  /**
   * AggDailyStats findFirstOrThrow
   */
  export type AggDailyStatsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AggDailyStats
     */
    select?: AggDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AggDailyStats
     */
    omit?: AggDailyStatsOmit<ExtArgs> | null
    /**
     * Filter, which AggDailyStats to fetch.
     */
    where?: AggDailyStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AggDailyStats to fetch.
     */
    orderBy?:
      | AggDailyStatsOrderByWithRelationInput
      | AggDailyStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AggDailyStats.
     */
    cursor?: AggDailyStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AggDailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AggDailyStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AggDailyStats.
     */
    distinct?: AggDailyStatsScalarFieldEnum | AggDailyStatsScalarFieldEnum[]
  }

  /**
   * AggDailyStats findMany
   */
  export type AggDailyStatsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AggDailyStats
     */
    select?: AggDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AggDailyStats
     */
    omit?: AggDailyStatsOmit<ExtArgs> | null
    /**
     * Filter, which AggDailyStats to fetch.
     */
    where?: AggDailyStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AggDailyStats to fetch.
     */
    orderBy?:
      | AggDailyStatsOrderByWithRelationInput
      | AggDailyStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing AggDailyStats.
     */
    cursor?: AggDailyStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AggDailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AggDailyStats.
     */
    skip?: number
    distinct?: AggDailyStatsScalarFieldEnum | AggDailyStatsScalarFieldEnum[]
  }

  /**
   * AggDailyStats create
   */
  export type AggDailyStatsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AggDailyStats
     */
    select?: AggDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AggDailyStats
     */
    omit?: AggDailyStatsOmit<ExtArgs> | null
    /**
     * The data needed to create a AggDailyStats.
     */
    data: XOR<AggDailyStatsCreateInput, AggDailyStatsUncheckedCreateInput>
  }

  /**
   * AggDailyStats createMany
   */
  export type AggDailyStatsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many AggDailyStats.
     */
    data: AggDailyStatsCreateManyInput | AggDailyStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AggDailyStats createManyAndReturn
   */
  export type AggDailyStatsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AggDailyStats
     */
    select?: AggDailyStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AggDailyStats
     */
    omit?: AggDailyStatsOmit<ExtArgs> | null
    /**
     * The data used to create many AggDailyStats.
     */
    data: AggDailyStatsCreateManyInput | AggDailyStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AggDailyStats update
   */
  export type AggDailyStatsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AggDailyStats
     */
    select?: AggDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AggDailyStats
     */
    omit?: AggDailyStatsOmit<ExtArgs> | null
    /**
     * The data needed to update a AggDailyStats.
     */
    data: XOR<AggDailyStatsUpdateInput, AggDailyStatsUncheckedUpdateInput>
    /**
     * Choose, which AggDailyStats to update.
     */
    where: AggDailyStatsWhereUniqueInput
  }

  /**
   * AggDailyStats updateMany
   */
  export type AggDailyStatsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update AggDailyStats.
     */
    data: XOR<
      AggDailyStatsUpdateManyMutationInput,
      AggDailyStatsUncheckedUpdateManyInput
    >
    /**
     * Filter which AggDailyStats to update
     */
    where?: AggDailyStatsWhereInput
    /**
     * Limit how many AggDailyStats to update.
     */
    limit?: number
  }

  /**
   * AggDailyStats updateManyAndReturn
   */
  export type AggDailyStatsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AggDailyStats
     */
    select?: AggDailyStatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AggDailyStats
     */
    omit?: AggDailyStatsOmit<ExtArgs> | null
    /**
     * The data used to update AggDailyStats.
     */
    data: XOR<
      AggDailyStatsUpdateManyMutationInput,
      AggDailyStatsUncheckedUpdateManyInput
    >
    /**
     * Filter which AggDailyStats to update
     */
    where?: AggDailyStatsWhereInput
    /**
     * Limit how many AggDailyStats to update.
     */
    limit?: number
  }

  /**
   * AggDailyStats upsert
   */
  export type AggDailyStatsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AggDailyStats
     */
    select?: AggDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AggDailyStats
     */
    omit?: AggDailyStatsOmit<ExtArgs> | null
    /**
     * The filter to search for the AggDailyStats to update in case it exists.
     */
    where: AggDailyStatsWhereUniqueInput
    /**
     * In case the AggDailyStats found by the `where` argument doesn't exist, create a new AggDailyStats with this data.
     */
    create: XOR<AggDailyStatsCreateInput, AggDailyStatsUncheckedCreateInput>
    /**
     * In case the AggDailyStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AggDailyStatsUpdateInput, AggDailyStatsUncheckedUpdateInput>
  }

  /**
   * AggDailyStats delete
   */
  export type AggDailyStatsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AggDailyStats
     */
    select?: AggDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AggDailyStats
     */
    omit?: AggDailyStatsOmit<ExtArgs> | null
    /**
     * Filter which AggDailyStats to delete.
     */
    where: AggDailyStatsWhereUniqueInput
  }

  /**
   * AggDailyStats deleteMany
   */
  export type AggDailyStatsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AggDailyStats to delete
     */
    where?: AggDailyStatsWhereInput
    /**
     * Limit how many AggDailyStats to delete.
     */
    limit?: number
  }

  /**
   * AggDailyStats without action
   */
  export type AggDailyStatsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AggDailyStats
     */
    select?: AggDailyStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AggDailyStats
     */
    omit?: AggDailyStatsOmit<ExtArgs> | null
  }

  /**
   * Model AggProductPerformance
   */

  export type AggregateAggProductPerformance = {
    _count: AggProductPerformanceCountAggregateOutputType | null
    _avg: AggProductPerformanceAvgAggregateOutputType | null
    _sum: AggProductPerformanceSumAggregateOutputType | null
    _min: AggProductPerformanceMinAggregateOutputType | null
    _max: AggProductPerformanceMaxAggregateOutputType | null
  }

  export type AggProductPerformanceAvgAggregateOutputType = {
    dateId: number | null
    productId: number | null
    views: number | null
    cartAdds: number | null
    purchases: number | null
    revenue: Decimal | null
    returns: number | null
  }

  export type AggProductPerformanceSumAggregateOutputType = {
    dateId: number | null
    productId: bigint | null
    views: number | null
    cartAdds: number | null
    purchases: number | null
    revenue: Decimal | null
    returns: number | null
  }

  export type AggProductPerformanceMinAggregateOutputType = {
    dateId: number | null
    productId: bigint | null
    views: number | null
    cartAdds: number | null
    purchases: number | null
    revenue: Decimal | null
    returns: number | null
  }

  export type AggProductPerformanceMaxAggregateOutputType = {
    dateId: number | null
    productId: bigint | null
    views: number | null
    cartAdds: number | null
    purchases: number | null
    revenue: Decimal | null
    returns: number | null
  }

  export type AggProductPerformanceCountAggregateOutputType = {
    dateId: number
    productId: number
    views: number
    cartAdds: number
    purchases: number
    revenue: number
    returns: number
    _all: number
  }

  export type AggProductPerformanceAvgAggregateInputType = {
    dateId?: true
    productId?: true
    views?: true
    cartAdds?: true
    purchases?: true
    revenue?: true
    returns?: true
  }

  export type AggProductPerformanceSumAggregateInputType = {
    dateId?: true
    productId?: true
    views?: true
    cartAdds?: true
    purchases?: true
    revenue?: true
    returns?: true
  }

  export type AggProductPerformanceMinAggregateInputType = {
    dateId?: true
    productId?: true
    views?: true
    cartAdds?: true
    purchases?: true
    revenue?: true
    returns?: true
  }

  export type AggProductPerformanceMaxAggregateInputType = {
    dateId?: true
    productId?: true
    views?: true
    cartAdds?: true
    purchases?: true
    revenue?: true
    returns?: true
  }

  export type AggProductPerformanceCountAggregateInputType = {
    dateId?: true
    productId?: true
    views?: true
    cartAdds?: true
    purchases?: true
    revenue?: true
    returns?: true
    _all?: true
  }

  export type AggProductPerformanceAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AggProductPerformance to aggregate.
     */
    where?: AggProductPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AggProductPerformances to fetch.
     */
    orderBy?:
      | AggProductPerformanceOrderByWithRelationInput
      | AggProductPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AggProductPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AggProductPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AggProductPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned AggProductPerformances
     **/
    _count?: true | AggProductPerformanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: AggProductPerformanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: AggProductPerformanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AggProductPerformanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AggProductPerformanceMaxAggregateInputType
  }

  export type GetAggProductPerformanceAggregateType<
    T extends AggProductPerformanceAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateAggProductPerformance]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAggProductPerformance[P]>
      : GetScalarType<T[P], AggregateAggProductPerformance[P]>
  }

  export type AggProductPerformanceGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AggProductPerformanceWhereInput
    orderBy?:
      | AggProductPerformanceOrderByWithAggregationInput
      | AggProductPerformanceOrderByWithAggregationInput[]
    by:
      | AggProductPerformanceScalarFieldEnum[]
      | AggProductPerformanceScalarFieldEnum
    having?: AggProductPerformanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AggProductPerformanceCountAggregateInputType | true
    _avg?: AggProductPerformanceAvgAggregateInputType
    _sum?: AggProductPerformanceSumAggregateInputType
    _min?: AggProductPerformanceMinAggregateInputType
    _max?: AggProductPerformanceMaxAggregateInputType
  }

  export type AggProductPerformanceGroupByOutputType = {
    dateId: number
    productId: bigint
    views: number
    cartAdds: number
    purchases: number
    revenue: Decimal
    returns: number
    _count: AggProductPerformanceCountAggregateOutputType | null
    _avg: AggProductPerformanceAvgAggregateOutputType | null
    _sum: AggProductPerformanceSumAggregateOutputType | null
    _min: AggProductPerformanceMinAggregateOutputType | null
    _max: AggProductPerformanceMaxAggregateOutputType | null
  }

  type GetAggProductPerformanceGroupByPayload<
    T extends AggProductPerformanceGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AggProductPerformanceGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof AggProductPerformanceGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], AggProductPerformanceGroupByOutputType[P]>
          : GetScalarType<T[P], AggProductPerformanceGroupByOutputType[P]>
      }
    >
  >

  export type AggProductPerformanceSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      dateId?: boolean
      productId?: boolean
      views?: boolean
      cartAdds?: boolean
      purchases?: boolean
      revenue?: boolean
      returns?: boolean
    },
    ExtArgs['result']['aggProductPerformance']
  >

  export type AggProductPerformanceSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      dateId?: boolean
      productId?: boolean
      views?: boolean
      cartAdds?: boolean
      purchases?: boolean
      revenue?: boolean
      returns?: boolean
    },
    ExtArgs['result']['aggProductPerformance']
  >

  export type AggProductPerformanceSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      dateId?: boolean
      productId?: boolean
      views?: boolean
      cartAdds?: boolean
      purchases?: boolean
      revenue?: boolean
      returns?: boolean
    },
    ExtArgs['result']['aggProductPerformance']
  >

  export type AggProductPerformanceSelectScalar = {
    dateId?: boolean
    productId?: boolean
    views?: boolean
    cartAdds?: boolean
    purchases?: boolean
    revenue?: boolean
    returns?: boolean
  }

  export type AggProductPerformanceOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'dateId'
    | 'productId'
    | 'views'
    | 'cartAdds'
    | 'purchases'
    | 'revenue'
    | 'returns',
    ExtArgs['result']['aggProductPerformance']
  >

  export type $AggProductPerformancePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'AggProductPerformance'
    objects: {}
    scalars: $Extensions.GetPayloadResult<
      {
        dateId: number
        productId: bigint
        views: number
        cartAdds: number
        purchases: number
        revenue: Prisma.Decimal
        returns: number
      },
      ExtArgs['result']['aggProductPerformance']
    >
    composites: {}
  }

  type AggProductPerformanceGetPayload<
    S extends boolean | null | undefined | AggProductPerformanceDefaultArgs,
  > = $Result.GetResult<Prisma.$AggProductPerformancePayload, S>

  type AggProductPerformanceCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    AggProductPerformanceFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: AggProductPerformanceCountAggregateInputType | true
  }

  export interface AggProductPerformanceDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['AggProductPerformance']
      meta: { name: 'AggProductPerformance' }
    }
    /**
     * Find zero or one AggProductPerformance that matches the filter.
     * @param {AggProductPerformanceFindUniqueArgs} args - Arguments to find a AggProductPerformance
     * @example
     * // Get one AggProductPerformance
     * const aggProductPerformance = await prisma.aggProductPerformance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AggProductPerformanceFindUniqueArgs>(
      args: SelectSubset<T, AggProductPerformanceFindUniqueArgs<ExtArgs>>
    ): Prisma__AggProductPerformanceClient<
      $Result.GetResult<
        Prisma.$AggProductPerformancePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find one AggProductPerformance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AggProductPerformanceFindUniqueOrThrowArgs} args - Arguments to find a AggProductPerformance
     * @example
     * // Get one AggProductPerformance
     * const aggProductPerformance = await prisma.aggProductPerformance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AggProductPerformanceFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AggProductPerformanceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AggProductPerformanceClient<
      $Result.GetResult<
        Prisma.$AggProductPerformancePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first AggProductPerformance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AggProductPerformanceFindFirstArgs} args - Arguments to find a AggProductPerformance
     * @example
     * // Get one AggProductPerformance
     * const aggProductPerformance = await prisma.aggProductPerformance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AggProductPerformanceFindFirstArgs>(
      args?: SelectSubset<T, AggProductPerformanceFindFirstArgs<ExtArgs>>
    ): Prisma__AggProductPerformanceClient<
      $Result.GetResult<
        Prisma.$AggProductPerformancePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find the first AggProductPerformance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AggProductPerformanceFindFirstOrThrowArgs} args - Arguments to find a AggProductPerformance
     * @example
     * // Get one AggProductPerformance
     * const aggProductPerformance = await prisma.aggProductPerformance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AggProductPerformanceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AggProductPerformanceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AggProductPerformanceClient<
      $Result.GetResult<
        Prisma.$AggProductPerformancePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Find zero or more AggProductPerformances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AggProductPerformanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AggProductPerformances
     * const aggProductPerformances = await prisma.aggProductPerformance.findMany()
     *
     * // Get first 10 AggProductPerformances
     * const aggProductPerformances = await prisma.aggProductPerformance.findMany({ take: 10 })
     *
     * // Only select the `dateId`
     * const aggProductPerformanceWithDateIdOnly = await prisma.aggProductPerformance.findMany({ select: { dateId: true } })
     *
     */
    findMany<T extends AggProductPerformanceFindManyArgs>(
      args?: SelectSubset<T, AggProductPerformanceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AggProductPerformancePayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >

    /**
     * Create a AggProductPerformance.
     * @param {AggProductPerformanceCreateArgs} args - Arguments to create a AggProductPerformance.
     * @example
     * // Create one AggProductPerformance
     * const AggProductPerformance = await prisma.aggProductPerformance.create({
     *   data: {
     *     // ... data to create a AggProductPerformance
     *   }
     * })
     *
     */
    create<T extends AggProductPerformanceCreateArgs>(
      args: SelectSubset<T, AggProductPerformanceCreateArgs<ExtArgs>>
    ): Prisma__AggProductPerformanceClient<
      $Result.GetResult<
        Prisma.$AggProductPerformancePayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Create many AggProductPerformances.
     * @param {AggProductPerformanceCreateManyArgs} args - Arguments to create many AggProductPerformances.
     * @example
     * // Create many AggProductPerformances
     * const aggProductPerformance = await prisma.aggProductPerformance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AggProductPerformanceCreateManyArgs>(
      args?: SelectSubset<T, AggProductPerformanceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AggProductPerformances and returns the data saved in the database.
     * @param {AggProductPerformanceCreateManyAndReturnArgs} args - Arguments to create many AggProductPerformances.
     * @example
     * // Create many AggProductPerformances
     * const aggProductPerformance = await prisma.aggProductPerformance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many AggProductPerformances and only return the `dateId`
     * const aggProductPerformanceWithDateIdOnly = await prisma.aggProductPerformance.createManyAndReturn({
     *   select: { dateId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AggProductPerformanceCreateManyAndReturnArgs>(
      args?: SelectSubset<
        T,
        AggProductPerformanceCreateManyAndReturnArgs<ExtArgs>
      >
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AggProductPerformancePayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Delete a AggProductPerformance.
     * @param {AggProductPerformanceDeleteArgs} args - Arguments to delete one AggProductPerformance.
     * @example
     * // Delete one AggProductPerformance
     * const AggProductPerformance = await prisma.aggProductPerformance.delete({
     *   where: {
     *     // ... filter to delete one AggProductPerformance
     *   }
     * })
     *
     */
    delete<T extends AggProductPerformanceDeleteArgs>(
      args: SelectSubset<T, AggProductPerformanceDeleteArgs<ExtArgs>>
    ): Prisma__AggProductPerformanceClient<
      $Result.GetResult<
        Prisma.$AggProductPerformancePayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Update one AggProductPerformance.
     * @param {AggProductPerformanceUpdateArgs} args - Arguments to update one AggProductPerformance.
     * @example
     * // Update one AggProductPerformance
     * const aggProductPerformance = await prisma.aggProductPerformance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AggProductPerformanceUpdateArgs>(
      args: SelectSubset<T, AggProductPerformanceUpdateArgs<ExtArgs>>
    ): Prisma__AggProductPerformanceClient<
      $Result.GetResult<
        Prisma.$AggProductPerformancePayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Delete zero or more AggProductPerformances.
     * @param {AggProductPerformanceDeleteManyArgs} args - Arguments to filter AggProductPerformances to delete.
     * @example
     * // Delete a few AggProductPerformances
     * const { count } = await prisma.aggProductPerformance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AggProductPerformanceDeleteManyArgs>(
      args?: SelectSubset<T, AggProductPerformanceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AggProductPerformances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AggProductPerformanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AggProductPerformances
     * const aggProductPerformance = await prisma.aggProductPerformance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AggProductPerformanceUpdateManyArgs>(
      args: SelectSubset<T, AggProductPerformanceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AggProductPerformances and returns the data updated in the database.
     * @param {AggProductPerformanceUpdateManyAndReturnArgs} args - Arguments to update many AggProductPerformances.
     * @example
     * // Update many AggProductPerformances
     * const aggProductPerformance = await prisma.aggProductPerformance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more AggProductPerformances and only return the `dateId`
     * const aggProductPerformanceWithDateIdOnly = await prisma.aggProductPerformance.updateManyAndReturn({
     *   select: { dateId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends AggProductPerformanceUpdateManyAndReturnArgs>(
      args: SelectSubset<
        T,
        AggProductPerformanceUpdateManyAndReturnArgs<ExtArgs>
      >
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AggProductPerformancePayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >

    /**
     * Create or update one AggProductPerformance.
     * @param {AggProductPerformanceUpsertArgs} args - Arguments to update or create a AggProductPerformance.
     * @example
     * // Update or create a AggProductPerformance
     * const aggProductPerformance = await prisma.aggProductPerformance.upsert({
     *   create: {
     *     // ... data to create a AggProductPerformance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AggProductPerformance we want to update
     *   }
     * })
     */
    upsert<T extends AggProductPerformanceUpsertArgs>(
      args: SelectSubset<T, AggProductPerformanceUpsertArgs<ExtArgs>>
    ): Prisma__AggProductPerformanceClient<
      $Result.GetResult<
        Prisma.$AggProductPerformancePayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >

    /**
     * Count the number of AggProductPerformances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AggProductPerformanceCountArgs} args - Arguments to filter AggProductPerformances to count.
     * @example
     * // Count the number of AggProductPerformances
     * const count = await prisma.aggProductPerformance.count({
     *   where: {
     *     // ... the filter for the AggProductPerformances we want to count
     *   }
     * })
     **/
    count<T extends AggProductPerformanceCountArgs>(
      args?: Subset<T, AggProductPerformanceCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<
              T['select'],
              AggProductPerformanceCountAggregateOutputType
            >
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AggProductPerformance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AggProductPerformanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AggProductPerformanceAggregateArgs>(
      args: Subset<T, AggProductPerformanceAggregateArgs>
    ): Prisma.PrismaPromise<GetAggProductPerformanceAggregateType<T>>

    /**
     * Group by AggProductPerformance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AggProductPerformanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AggProductPerformanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AggProductPerformanceGroupByArgs['orderBy'] }
        : { orderBy?: AggProductPerformanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ]
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                  }[OrderFields],
    >(
      args: SubsetIntersection<
        T,
        AggProductPerformanceGroupByArgs,
        OrderByArg
      > &
        InputErrors
    ): {} extends InputErrors
      ? GetAggProductPerformanceGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>
    /**
     * Fields of the AggProductPerformance model
     */
    readonly fields: AggProductPerformanceFieldRefs
  }

  /**
   * The delegate class that acts as a "Promise-like" for AggProductPerformance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AggProductPerformanceClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise'
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }

  /**
   * Fields of the AggProductPerformance model
   */
  interface AggProductPerformanceFieldRefs {
    readonly dateId: FieldRef<'AggProductPerformance', 'Int'>
    readonly productId: FieldRef<'AggProductPerformance', 'BigInt'>
    readonly views: FieldRef<'AggProductPerformance', 'Int'>
    readonly cartAdds: FieldRef<'AggProductPerformance', 'Int'>
    readonly purchases: FieldRef<'AggProductPerformance', 'Int'>
    readonly revenue: FieldRef<'AggProductPerformance', 'Decimal'>
    readonly returns: FieldRef<'AggProductPerformance', 'Int'>
  }

  // Custom InputTypes
  /**
   * AggProductPerformance findUnique
   */
  export type AggProductPerformanceFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AggProductPerformance
     */
    select?: AggProductPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AggProductPerformance
     */
    omit?: AggProductPerformanceOmit<ExtArgs> | null
    /**
     * Filter, which AggProductPerformance to fetch.
     */
    where: AggProductPerformanceWhereUniqueInput
  }

  /**
   * AggProductPerformance findUniqueOrThrow
   */
  export type AggProductPerformanceFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AggProductPerformance
     */
    select?: AggProductPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AggProductPerformance
     */
    omit?: AggProductPerformanceOmit<ExtArgs> | null
    /**
     * Filter, which AggProductPerformance to fetch.
     */
    where: AggProductPerformanceWhereUniqueInput
  }

  /**
   * AggProductPerformance findFirst
   */
  export type AggProductPerformanceFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AggProductPerformance
     */
    select?: AggProductPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AggProductPerformance
     */
    omit?: AggProductPerformanceOmit<ExtArgs> | null
    /**
     * Filter, which AggProductPerformance to fetch.
     */
    where?: AggProductPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AggProductPerformances to fetch.
     */
    orderBy?:
      | AggProductPerformanceOrderByWithRelationInput
      | AggProductPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AggProductPerformances.
     */
    cursor?: AggProductPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AggProductPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AggProductPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AggProductPerformances.
     */
    distinct?:
      | AggProductPerformanceScalarFieldEnum
      | AggProductPerformanceScalarFieldEnum[]
  }

  /**
   * AggProductPerformance findFirstOrThrow
   */
  export type AggProductPerformanceFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AggProductPerformance
     */
    select?: AggProductPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AggProductPerformance
     */
    omit?: AggProductPerformanceOmit<ExtArgs> | null
    /**
     * Filter, which AggProductPerformance to fetch.
     */
    where?: AggProductPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AggProductPerformances to fetch.
     */
    orderBy?:
      | AggProductPerformanceOrderByWithRelationInput
      | AggProductPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AggProductPerformances.
     */
    cursor?: AggProductPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AggProductPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AggProductPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AggProductPerformances.
     */
    distinct?:
      | AggProductPerformanceScalarFieldEnum
      | AggProductPerformanceScalarFieldEnum[]
  }

  /**
   * AggProductPerformance findMany
   */
  export type AggProductPerformanceFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AggProductPerformance
     */
    select?: AggProductPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AggProductPerformance
     */
    omit?: AggProductPerformanceOmit<ExtArgs> | null
    /**
     * Filter, which AggProductPerformances to fetch.
     */
    where?: AggProductPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AggProductPerformances to fetch.
     */
    orderBy?:
      | AggProductPerformanceOrderByWithRelationInput
      | AggProductPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing AggProductPerformances.
     */
    cursor?: AggProductPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AggProductPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AggProductPerformances.
     */
    skip?: number
    distinct?:
      | AggProductPerformanceScalarFieldEnum
      | AggProductPerformanceScalarFieldEnum[]
  }

  /**
   * AggProductPerformance create
   */
  export type AggProductPerformanceCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AggProductPerformance
     */
    select?: AggProductPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AggProductPerformance
     */
    omit?: AggProductPerformanceOmit<ExtArgs> | null
    /**
     * The data needed to create a AggProductPerformance.
     */
    data: XOR<
      AggProductPerformanceCreateInput,
      AggProductPerformanceUncheckedCreateInput
    >
  }

  /**
   * AggProductPerformance createMany
   */
  export type AggProductPerformanceCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many AggProductPerformances.
     */
    data:
      | AggProductPerformanceCreateManyInput
      | AggProductPerformanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AggProductPerformance createManyAndReturn
   */
  export type AggProductPerformanceCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AggProductPerformance
     */
    select?: AggProductPerformanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AggProductPerformance
     */
    omit?: AggProductPerformanceOmit<ExtArgs> | null
    /**
     * The data used to create many AggProductPerformances.
     */
    data:
      | AggProductPerformanceCreateManyInput
      | AggProductPerformanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AggProductPerformance update
   */
  export type AggProductPerformanceUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AggProductPerformance
     */
    select?: AggProductPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AggProductPerformance
     */
    omit?: AggProductPerformanceOmit<ExtArgs> | null
    /**
     * The data needed to update a AggProductPerformance.
     */
    data: XOR<
      AggProductPerformanceUpdateInput,
      AggProductPerformanceUncheckedUpdateInput
    >
    /**
     * Choose, which AggProductPerformance to update.
     */
    where: AggProductPerformanceWhereUniqueInput
  }

  /**
   * AggProductPerformance updateMany
   */
  export type AggProductPerformanceUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update AggProductPerformances.
     */
    data: XOR<
      AggProductPerformanceUpdateManyMutationInput,
      AggProductPerformanceUncheckedUpdateManyInput
    >
    /**
     * Filter which AggProductPerformances to update
     */
    where?: AggProductPerformanceWhereInput
    /**
     * Limit how many AggProductPerformances to update.
     */
    limit?: number
  }

  /**
   * AggProductPerformance updateManyAndReturn
   */
  export type AggProductPerformanceUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AggProductPerformance
     */
    select?: AggProductPerformanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AggProductPerformance
     */
    omit?: AggProductPerformanceOmit<ExtArgs> | null
    /**
     * The data used to update AggProductPerformances.
     */
    data: XOR<
      AggProductPerformanceUpdateManyMutationInput,
      AggProductPerformanceUncheckedUpdateManyInput
    >
    /**
     * Filter which AggProductPerformances to update
     */
    where?: AggProductPerformanceWhereInput
    /**
     * Limit how many AggProductPerformances to update.
     */
    limit?: number
  }

  /**
   * AggProductPerformance upsert
   */
  export type AggProductPerformanceUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AggProductPerformance
     */
    select?: AggProductPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AggProductPerformance
     */
    omit?: AggProductPerformanceOmit<ExtArgs> | null
    /**
     * The filter to search for the AggProductPerformance to update in case it exists.
     */
    where: AggProductPerformanceWhereUniqueInput
    /**
     * In case the AggProductPerformance found by the `where` argument doesn't exist, create a new AggProductPerformance with this data.
     */
    create: XOR<
      AggProductPerformanceCreateInput,
      AggProductPerformanceUncheckedCreateInput
    >
    /**
     * In case the AggProductPerformance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      AggProductPerformanceUpdateInput,
      AggProductPerformanceUncheckedUpdateInput
    >
  }

  /**
   * AggProductPerformance delete
   */
  export type AggProductPerformanceDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AggProductPerformance
     */
    select?: AggProductPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AggProductPerformance
     */
    omit?: AggProductPerformanceOmit<ExtArgs> | null
    /**
     * Filter which AggProductPerformance to delete.
     */
    where: AggProductPerformanceWhereUniqueInput
  }

  /**
   * AggProductPerformance deleteMany
   */
  export type AggProductPerformanceDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AggProductPerformances to delete
     */
    where?: AggProductPerformanceWhereInput
    /**
     * Limit how many AggProductPerformances to delete.
     */
    limit?: number
  }

  /**
   * AggProductPerformance without action
   */
  export type AggProductPerformanceDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AggProductPerformance
     */
    select?: AggProductPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AggProductPerformance
     */
    omit?: AggProductPerformanceOmit<ExtArgs> | null
  }

  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted'
    ReadCommitted: 'ReadCommitted'
    RepeatableRead: 'RepeatableRead'
    Serializable: 'Serializable'
  }

  export type TransactionIsolationLevel =
    (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]

  export const FactOrderScalarFieldEnum: {
    id: 'id'
    orderId: 'orderId'
    userId: 'userId'
    orderTs: 'orderTs'
    dateId: 'dateId'
    subtotal: 'subtotal'
    taxTotal: 'taxTotal'
    shippingTotal: 'shippingTotal'
    discountTotal: 'discountTotal'
    grandTotal: 'grandTotal'
    marginTotal: 'marginTotal'
    itemCount: 'itemCount'
    status: 'status'
    paymentStatus: 'paymentStatus'
    shippingStatus: 'shippingStatus'
    currency: 'currency'
    source: 'source'
    couponCode: 'couponCode'
    createdAt: 'createdAt'
    updatedAt: 'updatedAt'
    shippedAt: 'shippedAt'
    deliveredAt: 'deliveredAt'
  }

  export type FactOrderScalarFieldEnum =
    (typeof FactOrderScalarFieldEnum)[keyof typeof FactOrderScalarFieldEnum]

  export const FactOrderItemScalarFieldEnum: {
    id: 'id'
    orderItemId: 'orderItemId'
    orderId: 'orderId'
    productId: 'productId'
    productScId: 'productScId'
    dateId: 'dateId'
    orderTs: 'orderTs'
    qty: 'qty'
    unitPrice: 'unitPrice'
    unitCost: 'unitCost'
    taxAmount: 'taxAmount'
    discountAmount: 'discountAmount'
    extendedPrice: 'extendedPrice'
    margin: 'margin'
    variantSku: 'variantSku'
    productName: 'productName'
    categoryName: 'categoryName'
    brandName: 'brandName'
    isReturned: 'isReturned'
    createdAt: 'createdAt'
  }

  export type FactOrderItemScalarFieldEnum =
    (typeof FactOrderItemScalarFieldEnum)[keyof typeof FactOrderItemScalarFieldEnum]

  export const FactPaymentScalarFieldEnum: {
    id: 'id'
    paymentId: 'paymentId'
    orderId: 'orderId'
    dateId: 'dateId'
    timestamp: 'timestamp'
    amount: 'amount'
    currency: 'currency'
    provider: 'provider'
    method: 'method'
    status: 'status'
    errorCode: 'errorCode'
    isSuccess: 'isSuccess'
    createdAt: 'createdAt'
  }

  export type FactPaymentScalarFieldEnum =
    (typeof FactPaymentScalarFieldEnum)[keyof typeof FactPaymentScalarFieldEnum]

  export const FactShipmentScalarFieldEnum: {
    id: 'id'
    shipmentId: 'shipmentId'
    orderId: 'orderId'
    dateId: 'dateId'
    weight: 'weight'
    cost: 'cost'
    carrier: 'carrier'
    serviceLevel: 'serviceLevel'
    shippedTs: 'shippedTs'
    deliveredTs: 'deliveredTs'
    deliveryDays: 'deliveryDays'
    isOnTime: 'isOnTime'
    createdAt: 'createdAt'
  }

  export type FactShipmentScalarFieldEnum =
    (typeof FactShipmentScalarFieldEnum)[keyof typeof FactShipmentScalarFieldEnum]

  export const FactSessionScalarFieldEnum: {
    id: 'id'
    sessionId: 'sessionId'
    userId: 'userId'
    visitorId: 'visitorId'
    dateId: 'dateId'
    startTime: 'startTime'
    endTime: 'endTime'
    durationSec: 'durationSec'
    pageViews: 'pageViews'
    eventsCount: 'eventsCount'
    cartAddCount: 'cartAddCount'
    orderCount: 'orderCount'
    bounce: 'bounce'
    source: 'source'
    medium: 'medium'
    campaign: 'campaign'
    deviceType: 'deviceType'
    browser: 'browser'
    os: 'os'
    country: 'country'
    city: 'city'
  }

  export type FactSessionScalarFieldEnum =
    (typeof FactSessionScalarFieldEnum)[keyof typeof FactSessionScalarFieldEnum]

  export const FactPageviewScalarFieldEnum: {
    id: 'id'
    sessionId: 'sessionId'
    userId: 'userId'
    url: 'url'
    path: 'path'
    referrer: 'referrer'
    timestamp: 'timestamp'
    timeOnPageSec: 'timeOnPageSec'
    scrollDepth: 'scrollDepth'
    loadTimeMs: 'loadTimeMs'
    productId: 'productId'
    categoryId: 'categoryId'
  }

  export type FactPageviewScalarFieldEnum =
    (typeof FactPageviewScalarFieldEnum)[keyof typeof FactPageviewScalarFieldEnum]

  export const FactSearchScalarFieldEnum: {
    id: 'id'
    sessionId: 'sessionId'
    timestamp: 'timestamp'
    query: 'query'
    resultCount: 'resultCount'
    clickedResultPos: 'clickedResultPos'
    converted: 'converted'
  }

  export type FactSearchScalarFieldEnum =
    (typeof FactSearchScalarFieldEnum)[keyof typeof FactSearchScalarFieldEnum]

  export const FactCartActivityScalarFieldEnum: {
    id: 'id'
    sessionId: 'sessionId'
    userId: 'userId'
    timestamp: 'timestamp'
    action: 'action'
    productId: 'productId'
    sku: 'sku'
    quantityDelta: 'quantityDelta'
    priceSnapshot: 'priceSnapshot'
  }

  export type FactCartActivityScalarFieldEnum =
    (typeof FactCartActivityScalarFieldEnum)[keyof typeof FactCartActivityScalarFieldEnum]

  export const FactReviewScalarFieldEnum: {
    id: 'id'
    reviewId: 'reviewId'
    productId: 'productId'
    userId: 'userId'
    dateId: 'dateId'
    timestamp: 'timestamp'
    rating: 'rating'
    hasText: 'hasText'
    hasImages: 'hasImages'
    textLength: 'textLength'
    sentimentScore: 'sentimentScore'
    verified: 'verified'
  }

  export type FactReviewScalarFieldEnum =
    (typeof FactReviewScalarFieldEnum)[keyof typeof FactReviewScalarFieldEnum]

  export const DimProductScalarFieldEnum: {
    productScId: 'productScId'
    productId: 'productId'
    sku: 'sku'
    name: 'name'
    categoryId: 'categoryId'
    brandId: 'brandId'
    currentPrice: 'currentPrice'
    costPrice: 'costPrice'
    isActive: 'isActive'
    validFrom: 'validFrom'
    validTo: 'validTo'
    isCurrent: 'isCurrent'
    categoryName: 'categoryName'
    brandName: 'brandName'
    supplier: 'supplier'
    tags: 'tags'
  }

  export type DimProductScalarFieldEnum =
    (typeof DimProductScalarFieldEnum)[keyof typeof DimProductScalarFieldEnum]

  export const DimUserScalarFieldEnum: {
    userScId: 'userScId'
    userId: 'userId'
    email: 'email'
    city: 'city'
    country: 'country'
    gender: 'gender'
    ageGroup: 'ageGroup'
    segment: 'segment'
    ltv: 'ltv'
    firstOrderDate: 'firstOrderDate'
    validFrom: 'validFrom'
    validTo: 'validTo'
    isCurrent: 'isCurrent'
  }

  export type DimUserScalarFieldEnum =
    (typeof DimUserScalarFieldEnum)[keyof typeof DimUserScalarFieldEnum]

  export const DimDateScalarFieldEnum: {
    dateId: 'dateId'
    date: 'date'
    dayOfWeek: 'dayOfWeek'
    dayName: 'dayName'
    dayOfMonth: 'dayOfMonth'
    weekOfYear: 'weekOfYear'
    month: 'month'
    monthName: 'monthName'
    quarter: 'quarter'
    year: 'year'
    isWeekend: 'isWeekend'
    isHoliday: 'isHoliday'
    fiscalYear: 'fiscalYear'
    fiscalPeriod: 'fiscalPeriod'
  }

  export type DimDateScalarFieldEnum =
    (typeof DimDateScalarFieldEnum)[keyof typeof DimDateScalarFieldEnum]

  export const DimMarketingScalarFieldEnum: {
    id: 'id'
    utmSource: 'utmSource'
    utmMedium: 'utmMedium'
    utmCampaign: 'utmCampaign'
    utmTerm: 'utmTerm'
    utmContent: 'utmContent'
    channelGroup: 'channelGroup'
    createdAt: 'createdAt'
  }

  export type DimMarketingScalarFieldEnum =
    (typeof DimMarketingScalarFieldEnum)[keyof typeof DimMarketingScalarFieldEnum]

  export const DimLocationScalarFieldEnum: {
    id: 'id'
    city: 'city'
    state: 'state'
    postalCode: 'postalCode'
    country: 'country'
    countryCode: 'countryCode'
    region: 'region'
  }

  export type DimLocationScalarFieldEnum =
    (typeof DimLocationScalarFieldEnum)[keyof typeof DimLocationScalarFieldEnum]

  export const IngestOffsetScalarFieldEnum: {
    id: 'id'
    source: 'source'
    partition: 'partition'
    lastOffset: 'lastOffset'
    lastTimestamp: 'lastTimestamp'
    payloadHash: 'payloadHash'
    updatedAt: 'updatedAt'
  }

  export type IngestOffsetScalarFieldEnum =
    (typeof IngestOffsetScalarFieldEnum)[keyof typeof IngestOffsetScalarFieldEnum]

  export const StagingRawEventScalarFieldEnum: {
    id: 'id'
    eventType: 'eventType'
    source: 'source'
    payload: 'payload'
    headers: 'headers'
    receivedAt: 'receivedAt'
    processedAt: 'processedAt'
    status: 'status'
    error: 'error'
    retryCount: 'retryCount'
  }

  export type StagingRawEventScalarFieldEnum =
    (typeof StagingRawEventScalarFieldEnum)[keyof typeof StagingRawEventScalarFieldEnum]

  export const AggDailyStatsScalarFieldEnum: {
    dateId: 'dateId'
    totalRevenue: 'totalRevenue'
    totalOrders: 'totalOrders'
    totalVisits: 'totalVisits'
    conversionRate: 'conversionRate'
    aov: 'aov'
    updatedAt: 'updatedAt'
  }

  export type AggDailyStatsScalarFieldEnum =
    (typeof AggDailyStatsScalarFieldEnum)[keyof typeof AggDailyStatsScalarFieldEnum]

  export const AggProductPerformanceScalarFieldEnum: {
    dateId: 'dateId'
    productId: 'productId'
    views: 'views'
    cartAdds: 'cartAdds'
    purchases: 'purchases'
    revenue: 'revenue'
    returns: 'returns'
  }

  export type AggProductPerformanceScalarFieldEnum =
    (typeof AggProductPerformanceScalarFieldEnum)[keyof typeof AggProductPerformanceScalarFieldEnum]

  export const SortOrder: {
    asc: 'asc'
    desc: 'desc'
  }

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]

  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  }

  export type JsonNullValueInput =
    (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]

  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull
    JsonNull: typeof JsonNull
  }

  export type NullableJsonNullValueInput =
    (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]

  export const QueryMode: {
    default: 'default'
    insensitive: 'insensitive'
  }

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]

  export const NullsOrder: {
    first: 'first'
    last: 'last'
  }

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]

  export const JsonNullValueFilter: {
    DbNull: typeof DbNull
    JsonNull: typeof JsonNull
    AnyNull: typeof AnyNull
  }

  export type JsonNullValueFilter =
    (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'BigInt'
  >

  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'BigInt[]'
  >

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DateTime'
  >

  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DateTime[]'
  >

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Int'
  >

  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Int[]'
  >

  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Decimal'
  >

  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Decimal[]'
  >

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'String'
  >

  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'String[]'
  >

  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Boolean'
  >

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Float'
  >

  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Float[]'
  >

  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Json'
  >

  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'QueryMode'
  >

  /**
   * Deep Input Types
   */

  export type FactOrderWhereInput = {
    AND?: FactOrderWhereInput | FactOrderWhereInput[]
    OR?: FactOrderWhereInput[]
    NOT?: FactOrderWhereInput | FactOrderWhereInput[]
    id?: BigIntFilter<'FactOrder'> | bigint | number
    orderId?: BigIntFilter<'FactOrder'> | bigint | number
    userId?: BigIntNullableFilter<'FactOrder'> | bigint | number | null
    orderTs?: DateTimeFilter<'FactOrder'> | Date | string
    dateId?: IntFilter<'FactOrder'> | number
    subtotal?:
      | DecimalFilter<'FactOrder'>
      | Decimal
      | DecimalJsLike
      | number
      | string
    taxTotal?:
      | DecimalFilter<'FactOrder'>
      | Decimal
      | DecimalJsLike
      | number
      | string
    shippingTotal?:
      | DecimalFilter<'FactOrder'>
      | Decimal
      | DecimalJsLike
      | number
      | string
    discountTotal?:
      | DecimalFilter<'FactOrder'>
      | Decimal
      | DecimalJsLike
      | number
      | string
    grandTotal?:
      | DecimalFilter<'FactOrder'>
      | Decimal
      | DecimalJsLike
      | number
      | string
    marginTotal?:
      | DecimalNullableFilter<'FactOrder'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    itemCount?: IntFilter<'FactOrder'> | number
    status?: StringFilter<'FactOrder'> | string
    paymentStatus?: StringFilter<'FactOrder'> | string
    shippingStatus?: StringFilter<'FactOrder'> | string
    currency?: StringFilter<'FactOrder'> | string
    source?: StringNullableFilter<'FactOrder'> | string | null
    couponCode?: StringNullableFilter<'FactOrder'> | string | null
    createdAt?: DateTimeFilter<'FactOrder'> | Date | string
    updatedAt?: DateTimeFilter<'FactOrder'> | Date | string
    shippedAt?: DateTimeNullableFilter<'FactOrder'> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<'FactOrder'> | Date | string | null
  }

  export type FactOrderOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    userId?: SortOrderInput | SortOrder
    orderTs?: SortOrder
    dateId?: SortOrder
    subtotal?: SortOrder
    taxTotal?: SortOrder
    shippingTotal?: SortOrder
    discountTotal?: SortOrder
    grandTotal?: SortOrder
    marginTotal?: SortOrderInput | SortOrder
    itemCount?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    shippingStatus?: SortOrder
    currency?: SortOrder
    source?: SortOrderInput | SortOrder
    couponCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shippedAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
  }

  export type FactOrderWhereUniqueInput = Prisma.AtLeast<
    {
      id?: bigint | number
      orderId?: bigint | number
      AND?: FactOrderWhereInput | FactOrderWhereInput[]
      OR?: FactOrderWhereInput[]
      NOT?: FactOrderWhereInput | FactOrderWhereInput[]
      userId?: BigIntNullableFilter<'FactOrder'> | bigint | number | null
      orderTs?: DateTimeFilter<'FactOrder'> | Date | string
      dateId?: IntFilter<'FactOrder'> | number
      subtotal?:
        | DecimalFilter<'FactOrder'>
        | Decimal
        | DecimalJsLike
        | number
        | string
      taxTotal?:
        | DecimalFilter<'FactOrder'>
        | Decimal
        | DecimalJsLike
        | number
        | string
      shippingTotal?:
        | DecimalFilter<'FactOrder'>
        | Decimal
        | DecimalJsLike
        | number
        | string
      discountTotal?:
        | DecimalFilter<'FactOrder'>
        | Decimal
        | DecimalJsLike
        | number
        | string
      grandTotal?:
        | DecimalFilter<'FactOrder'>
        | Decimal
        | DecimalJsLike
        | number
        | string
      marginTotal?:
        | DecimalNullableFilter<'FactOrder'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null
      itemCount?: IntFilter<'FactOrder'> | number
      status?: StringFilter<'FactOrder'> | string
      paymentStatus?: StringFilter<'FactOrder'> | string
      shippingStatus?: StringFilter<'FactOrder'> | string
      currency?: StringFilter<'FactOrder'> | string
      source?: StringNullableFilter<'FactOrder'> | string | null
      couponCode?: StringNullableFilter<'FactOrder'> | string | null
      createdAt?: DateTimeFilter<'FactOrder'> | Date | string
      updatedAt?: DateTimeFilter<'FactOrder'> | Date | string
      shippedAt?: DateTimeNullableFilter<'FactOrder'> | Date | string | null
      deliveredAt?: DateTimeNullableFilter<'FactOrder'> | Date | string | null
    },
    'id' | 'orderId'
  >

  export type FactOrderOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    userId?: SortOrderInput | SortOrder
    orderTs?: SortOrder
    dateId?: SortOrder
    subtotal?: SortOrder
    taxTotal?: SortOrder
    shippingTotal?: SortOrder
    discountTotal?: SortOrder
    grandTotal?: SortOrder
    marginTotal?: SortOrderInput | SortOrder
    itemCount?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    shippingStatus?: SortOrder
    currency?: SortOrder
    source?: SortOrderInput | SortOrder
    couponCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shippedAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    _count?: FactOrderCountOrderByAggregateInput
    _avg?: FactOrderAvgOrderByAggregateInput
    _max?: FactOrderMaxOrderByAggregateInput
    _min?: FactOrderMinOrderByAggregateInput
    _sum?: FactOrderSumOrderByAggregateInput
  }

  export type FactOrderScalarWhereWithAggregatesInput = {
    AND?:
      | FactOrderScalarWhereWithAggregatesInput
      | FactOrderScalarWhereWithAggregatesInput[]
    OR?: FactOrderScalarWhereWithAggregatesInput[]
    NOT?:
      | FactOrderScalarWhereWithAggregatesInput
      | FactOrderScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<'FactOrder'> | bigint | number
    orderId?: BigIntWithAggregatesFilter<'FactOrder'> | bigint | number
    userId?:
      | BigIntNullableWithAggregatesFilter<'FactOrder'>
      | bigint
      | number
      | null
    orderTs?: DateTimeWithAggregatesFilter<'FactOrder'> | Date | string
    dateId?: IntWithAggregatesFilter<'FactOrder'> | number
    subtotal?:
      | DecimalWithAggregatesFilter<'FactOrder'>
      | Decimal
      | DecimalJsLike
      | number
      | string
    taxTotal?:
      | DecimalWithAggregatesFilter<'FactOrder'>
      | Decimal
      | DecimalJsLike
      | number
      | string
    shippingTotal?:
      | DecimalWithAggregatesFilter<'FactOrder'>
      | Decimal
      | DecimalJsLike
      | number
      | string
    discountTotal?:
      | DecimalWithAggregatesFilter<'FactOrder'>
      | Decimal
      | DecimalJsLike
      | number
      | string
    grandTotal?:
      | DecimalWithAggregatesFilter<'FactOrder'>
      | Decimal
      | DecimalJsLike
      | number
      | string
    marginTotal?:
      | DecimalNullableWithAggregatesFilter<'FactOrder'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    itemCount?: IntWithAggregatesFilter<'FactOrder'> | number
    status?: StringWithAggregatesFilter<'FactOrder'> | string
    paymentStatus?: StringWithAggregatesFilter<'FactOrder'> | string
    shippingStatus?: StringWithAggregatesFilter<'FactOrder'> | string
    currency?: StringWithAggregatesFilter<'FactOrder'> | string
    source?: StringNullableWithAggregatesFilter<'FactOrder'> | string | null
    couponCode?: StringNullableWithAggregatesFilter<'FactOrder'> | string | null
    createdAt?: DateTimeWithAggregatesFilter<'FactOrder'> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<'FactOrder'> | Date | string
    shippedAt?:
      | DateTimeNullableWithAggregatesFilter<'FactOrder'>
      | Date
      | string
      | null
    deliveredAt?:
      | DateTimeNullableWithAggregatesFilter<'FactOrder'>
      | Date
      | string
      | null
  }

  export type FactOrderItemWhereInput = {
    AND?: FactOrderItemWhereInput | FactOrderItemWhereInput[]
    OR?: FactOrderItemWhereInput[]
    NOT?: FactOrderItemWhereInput | FactOrderItemWhereInput[]
    id?: BigIntFilter<'FactOrderItem'> | bigint | number
    orderItemId?: BigIntFilter<'FactOrderItem'> | bigint | number
    orderId?: BigIntFilter<'FactOrderItem'> | bigint | number
    productId?: BigIntFilter<'FactOrderItem'> | bigint | number
    productScId?: BigIntNullableFilter<'FactOrderItem'> | bigint | number | null
    dateId?: IntFilter<'FactOrderItem'> | number
    orderTs?: DateTimeFilter<'FactOrderItem'> | Date | string
    qty?: IntFilter<'FactOrderItem'> | number
    unitPrice?:
      | DecimalFilter<'FactOrderItem'>
      | Decimal
      | DecimalJsLike
      | number
      | string
    unitCost?:
      | DecimalNullableFilter<'FactOrderItem'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    taxAmount?:
      | DecimalFilter<'FactOrderItem'>
      | Decimal
      | DecimalJsLike
      | number
      | string
    discountAmount?:
      | DecimalFilter<'FactOrderItem'>
      | Decimal
      | DecimalJsLike
      | number
      | string
    extendedPrice?:
      | DecimalFilter<'FactOrderItem'>
      | Decimal
      | DecimalJsLike
      | number
      | string
    margin?:
      | DecimalNullableFilter<'FactOrderItem'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    variantSku?: StringNullableFilter<'FactOrderItem'> | string | null
    productName?: StringFilter<'FactOrderItem'> | string
    categoryName?: StringNullableFilter<'FactOrderItem'> | string | null
    brandName?: StringNullableFilter<'FactOrderItem'> | string | null
    isReturned?: BoolFilter<'FactOrderItem'> | boolean
    createdAt?: DateTimeFilter<'FactOrderItem'> | Date | string
  }

  export type FactOrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    productScId?: SortOrderInput | SortOrder
    dateId?: SortOrder
    orderTs?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    unitCost?: SortOrderInput | SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    extendedPrice?: SortOrder
    margin?: SortOrderInput | SortOrder
    variantSku?: SortOrderInput | SortOrder
    productName?: SortOrder
    categoryName?: SortOrderInput | SortOrder
    brandName?: SortOrderInput | SortOrder
    isReturned?: SortOrder
    createdAt?: SortOrder
  }

  export type FactOrderItemWhereUniqueInput = Prisma.AtLeast<
    {
      id?: bigint | number
      orderItemId?: bigint | number
      AND?: FactOrderItemWhereInput | FactOrderItemWhereInput[]
      OR?: FactOrderItemWhereInput[]
      NOT?: FactOrderItemWhereInput | FactOrderItemWhereInput[]
      orderId?: BigIntFilter<'FactOrderItem'> | bigint | number
      productId?: BigIntFilter<'FactOrderItem'> | bigint | number
      productScId?:
        | BigIntNullableFilter<'FactOrderItem'>
        | bigint
        | number
        | null
      dateId?: IntFilter<'FactOrderItem'> | number
      orderTs?: DateTimeFilter<'FactOrderItem'> | Date | string
      qty?: IntFilter<'FactOrderItem'> | number
      unitPrice?:
        | DecimalFilter<'FactOrderItem'>
        | Decimal
        | DecimalJsLike
        | number
        | string
      unitCost?:
        | DecimalNullableFilter<'FactOrderItem'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null
      taxAmount?:
        | DecimalFilter<'FactOrderItem'>
        | Decimal
        | DecimalJsLike
        | number
        | string
      discountAmount?:
        | DecimalFilter<'FactOrderItem'>
        | Decimal
        | DecimalJsLike
        | number
        | string
      extendedPrice?:
        | DecimalFilter<'FactOrderItem'>
        | Decimal
        | DecimalJsLike
        | number
        | string
      margin?:
        | DecimalNullableFilter<'FactOrderItem'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null
      variantSku?: StringNullableFilter<'FactOrderItem'> | string | null
      productName?: StringFilter<'FactOrderItem'> | string
      categoryName?: StringNullableFilter<'FactOrderItem'> | string | null
      brandName?: StringNullableFilter<'FactOrderItem'> | string | null
      isReturned?: BoolFilter<'FactOrderItem'> | boolean
      createdAt?: DateTimeFilter<'FactOrderItem'> | Date | string
    },
    'id' | 'orderItemId'
  >

  export type FactOrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    productScId?: SortOrderInput | SortOrder
    dateId?: SortOrder
    orderTs?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    unitCost?: SortOrderInput | SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    extendedPrice?: SortOrder
    margin?: SortOrderInput | SortOrder
    variantSku?: SortOrderInput | SortOrder
    productName?: SortOrder
    categoryName?: SortOrderInput | SortOrder
    brandName?: SortOrderInput | SortOrder
    isReturned?: SortOrder
    createdAt?: SortOrder
    _count?: FactOrderItemCountOrderByAggregateInput
    _avg?: FactOrderItemAvgOrderByAggregateInput
    _max?: FactOrderItemMaxOrderByAggregateInput
    _min?: FactOrderItemMinOrderByAggregateInput
    _sum?: FactOrderItemSumOrderByAggregateInput
  }

  export type FactOrderItemScalarWhereWithAggregatesInput = {
    AND?:
      | FactOrderItemScalarWhereWithAggregatesInput
      | FactOrderItemScalarWhereWithAggregatesInput[]
    OR?: FactOrderItemScalarWhereWithAggregatesInput[]
    NOT?:
      | FactOrderItemScalarWhereWithAggregatesInput
      | FactOrderItemScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<'FactOrderItem'> | bigint | number
    orderItemId?: BigIntWithAggregatesFilter<'FactOrderItem'> | bigint | number
    orderId?: BigIntWithAggregatesFilter<'FactOrderItem'> | bigint | number
    productId?: BigIntWithAggregatesFilter<'FactOrderItem'> | bigint | number
    productScId?:
      | BigIntNullableWithAggregatesFilter<'FactOrderItem'>
      | bigint
      | number
      | null
    dateId?: IntWithAggregatesFilter<'FactOrderItem'> | number
    orderTs?: DateTimeWithAggregatesFilter<'FactOrderItem'> | Date | string
    qty?: IntWithAggregatesFilter<'FactOrderItem'> | number
    unitPrice?:
      | DecimalWithAggregatesFilter<'FactOrderItem'>
      | Decimal
      | DecimalJsLike
      | number
      | string
    unitCost?:
      | DecimalNullableWithAggregatesFilter<'FactOrderItem'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    taxAmount?:
      | DecimalWithAggregatesFilter<'FactOrderItem'>
      | Decimal
      | DecimalJsLike
      | number
      | string
    discountAmount?:
      | DecimalWithAggregatesFilter<'FactOrderItem'>
      | Decimal
      | DecimalJsLike
      | number
      | string
    extendedPrice?:
      | DecimalWithAggregatesFilter<'FactOrderItem'>
      | Decimal
      | DecimalJsLike
      | number
      | string
    margin?:
      | DecimalNullableWithAggregatesFilter<'FactOrderItem'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    variantSku?:
      | StringNullableWithAggregatesFilter<'FactOrderItem'>
      | string
      | null
    productName?: StringWithAggregatesFilter<'FactOrderItem'> | string
    categoryName?:
      | StringNullableWithAggregatesFilter<'FactOrderItem'>
      | string
      | null
    brandName?:
      | StringNullableWithAggregatesFilter<'FactOrderItem'>
      | string
      | null
    isReturned?: BoolWithAggregatesFilter<'FactOrderItem'> | boolean
    createdAt?: DateTimeWithAggregatesFilter<'FactOrderItem'> | Date | string
  }

  export type FactPaymentWhereInput = {
    AND?: FactPaymentWhereInput | FactPaymentWhereInput[]
    OR?: FactPaymentWhereInput[]
    NOT?: FactPaymentWhereInput | FactPaymentWhereInput[]
    id?: BigIntFilter<'FactPayment'> | bigint | number
    paymentId?: BigIntFilter<'FactPayment'> | bigint | number
    orderId?: BigIntNullableFilter<'FactPayment'> | bigint | number | null
    dateId?: IntFilter<'FactPayment'> | number
    timestamp?: DateTimeFilter<'FactPayment'> | Date | string
    amount?:
      | DecimalFilter<'FactPayment'>
      | Decimal
      | DecimalJsLike
      | number
      | string
    currency?: StringFilter<'FactPayment'> | string
    provider?: StringFilter<'FactPayment'> | string
    method?: StringNullableFilter<'FactPayment'> | string | null
    status?: StringFilter<'FactPayment'> | string
    errorCode?: StringNullableFilter<'FactPayment'> | string | null
    isSuccess?: BoolFilter<'FactPayment'> | boolean
    createdAt?: DateTimeFilter<'FactPayment'> | Date | string
  }

  export type FactPaymentOrderByWithRelationInput = {
    id?: SortOrder
    paymentId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    dateId?: SortOrder
    timestamp?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    provider?: SortOrder
    method?: SortOrderInput | SortOrder
    status?: SortOrder
    errorCode?: SortOrderInput | SortOrder
    isSuccess?: SortOrder
    createdAt?: SortOrder
  }

  export type FactPaymentWhereUniqueInput = Prisma.AtLeast<
    {
      id?: bigint | number
      paymentId?: bigint | number
      AND?: FactPaymentWhereInput | FactPaymentWhereInput[]
      OR?: FactPaymentWhereInput[]
      NOT?: FactPaymentWhereInput | FactPaymentWhereInput[]
      orderId?: BigIntNullableFilter<'FactPayment'> | bigint | number | null
      dateId?: IntFilter<'FactPayment'> | number
      timestamp?: DateTimeFilter<'FactPayment'> | Date | string
      amount?:
        | DecimalFilter<'FactPayment'>
        | Decimal
        | DecimalJsLike
        | number
        | string
      currency?: StringFilter<'FactPayment'> | string
      provider?: StringFilter<'FactPayment'> | string
      method?: StringNullableFilter<'FactPayment'> | string | null
      status?: StringFilter<'FactPayment'> | string
      errorCode?: StringNullableFilter<'FactPayment'> | string | null
      isSuccess?: BoolFilter<'FactPayment'> | boolean
      createdAt?: DateTimeFilter<'FactPayment'> | Date | string
    },
    'id' | 'paymentId'
  >

  export type FactPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    paymentId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    dateId?: SortOrder
    timestamp?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    provider?: SortOrder
    method?: SortOrderInput | SortOrder
    status?: SortOrder
    errorCode?: SortOrderInput | SortOrder
    isSuccess?: SortOrder
    createdAt?: SortOrder
    _count?: FactPaymentCountOrderByAggregateInput
    _avg?: FactPaymentAvgOrderByAggregateInput
    _max?: FactPaymentMaxOrderByAggregateInput
    _min?: FactPaymentMinOrderByAggregateInput
    _sum?: FactPaymentSumOrderByAggregateInput
  }

  export type FactPaymentScalarWhereWithAggregatesInput = {
    AND?:
      | FactPaymentScalarWhereWithAggregatesInput
      | FactPaymentScalarWhereWithAggregatesInput[]
    OR?: FactPaymentScalarWhereWithAggregatesInput[]
    NOT?:
      | FactPaymentScalarWhereWithAggregatesInput
      | FactPaymentScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<'FactPayment'> | bigint | number
    paymentId?: BigIntWithAggregatesFilter<'FactPayment'> | bigint | number
    orderId?:
      | BigIntNullableWithAggregatesFilter<'FactPayment'>
      | bigint
      | number
      | null
    dateId?: IntWithAggregatesFilter<'FactPayment'> | number
    timestamp?: DateTimeWithAggregatesFilter<'FactPayment'> | Date | string
    amount?:
      | DecimalWithAggregatesFilter<'FactPayment'>
      | Decimal
      | DecimalJsLike
      | number
      | string
    currency?: StringWithAggregatesFilter<'FactPayment'> | string
    provider?: StringWithAggregatesFilter<'FactPayment'> | string
    method?: StringNullableWithAggregatesFilter<'FactPayment'> | string | null
    status?: StringWithAggregatesFilter<'FactPayment'> | string
    errorCode?:
      | StringNullableWithAggregatesFilter<'FactPayment'>
      | string
      | null
    isSuccess?: BoolWithAggregatesFilter<'FactPayment'> | boolean
    createdAt?: DateTimeWithAggregatesFilter<'FactPayment'> | Date | string
  }

  export type FactShipmentWhereInput = {
    AND?: FactShipmentWhereInput | FactShipmentWhereInput[]
    OR?: FactShipmentWhereInput[]
    NOT?: FactShipmentWhereInput | FactShipmentWhereInput[]
    id?: BigIntFilter<'FactShipment'> | bigint | number
    shipmentId?: BigIntFilter<'FactShipment'> | bigint | number
    orderId?: BigIntFilter<'FactShipment'> | bigint | number
    dateId?: IntFilter<'FactShipment'> | number
    weight?: FloatNullableFilter<'FactShipment'> | number | null
    cost?:
      | DecimalNullableFilter<'FactShipment'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    carrier?: StringFilter<'FactShipment'> | string
    serviceLevel?: StringNullableFilter<'FactShipment'> | string | null
    shippedTs?: DateTimeNullableFilter<'FactShipment'> | Date | string | null
    deliveredTs?: DateTimeNullableFilter<'FactShipment'> | Date | string | null
    deliveryDays?: FloatNullableFilter<'FactShipment'> | number | null
    isOnTime?: BoolNullableFilter<'FactShipment'> | boolean | null
    createdAt?: DateTimeFilter<'FactShipment'> | Date | string
  }

  export type FactShipmentOrderByWithRelationInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    orderId?: SortOrder
    dateId?: SortOrder
    weight?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    carrier?: SortOrder
    serviceLevel?: SortOrderInput | SortOrder
    shippedTs?: SortOrderInput | SortOrder
    deliveredTs?: SortOrderInput | SortOrder
    deliveryDays?: SortOrderInput | SortOrder
    isOnTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type FactShipmentWhereUniqueInput = Prisma.AtLeast<
    {
      id?: bigint | number
      shipmentId?: bigint | number
      AND?: FactShipmentWhereInput | FactShipmentWhereInput[]
      OR?: FactShipmentWhereInput[]
      NOT?: FactShipmentWhereInput | FactShipmentWhereInput[]
      orderId?: BigIntFilter<'FactShipment'> | bigint | number
      dateId?: IntFilter<'FactShipment'> | number
      weight?: FloatNullableFilter<'FactShipment'> | number | null
      cost?:
        | DecimalNullableFilter<'FactShipment'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null
      carrier?: StringFilter<'FactShipment'> | string
      serviceLevel?: StringNullableFilter<'FactShipment'> | string | null
      shippedTs?: DateTimeNullableFilter<'FactShipment'> | Date | string | null
      deliveredTs?:
        | DateTimeNullableFilter<'FactShipment'>
        | Date
        | string
        | null
      deliveryDays?: FloatNullableFilter<'FactShipment'> | number | null
      isOnTime?: BoolNullableFilter<'FactShipment'> | boolean | null
      createdAt?: DateTimeFilter<'FactShipment'> | Date | string
    },
    'id' | 'shipmentId'
  >

  export type FactShipmentOrderByWithAggregationInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    orderId?: SortOrder
    dateId?: SortOrder
    weight?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    carrier?: SortOrder
    serviceLevel?: SortOrderInput | SortOrder
    shippedTs?: SortOrderInput | SortOrder
    deliveredTs?: SortOrderInput | SortOrder
    deliveryDays?: SortOrderInput | SortOrder
    isOnTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: FactShipmentCountOrderByAggregateInput
    _avg?: FactShipmentAvgOrderByAggregateInput
    _max?: FactShipmentMaxOrderByAggregateInput
    _min?: FactShipmentMinOrderByAggregateInput
    _sum?: FactShipmentSumOrderByAggregateInput
  }

  export type FactShipmentScalarWhereWithAggregatesInput = {
    AND?:
      | FactShipmentScalarWhereWithAggregatesInput
      | FactShipmentScalarWhereWithAggregatesInput[]
    OR?: FactShipmentScalarWhereWithAggregatesInput[]
    NOT?:
      | FactShipmentScalarWhereWithAggregatesInput
      | FactShipmentScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<'FactShipment'> | bigint | number
    shipmentId?: BigIntWithAggregatesFilter<'FactShipment'> | bigint | number
    orderId?: BigIntWithAggregatesFilter<'FactShipment'> | bigint | number
    dateId?: IntWithAggregatesFilter<'FactShipment'> | number
    weight?: FloatNullableWithAggregatesFilter<'FactShipment'> | number | null
    cost?:
      | DecimalNullableWithAggregatesFilter<'FactShipment'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    carrier?: StringWithAggregatesFilter<'FactShipment'> | string
    serviceLevel?:
      | StringNullableWithAggregatesFilter<'FactShipment'>
      | string
      | null
    shippedTs?:
      | DateTimeNullableWithAggregatesFilter<'FactShipment'>
      | Date
      | string
      | null
    deliveredTs?:
      | DateTimeNullableWithAggregatesFilter<'FactShipment'>
      | Date
      | string
      | null
    deliveryDays?:
      | FloatNullableWithAggregatesFilter<'FactShipment'>
      | number
      | null
    isOnTime?: BoolNullableWithAggregatesFilter<'FactShipment'> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<'FactShipment'> | Date | string
  }

  export type FactSessionWhereInput = {
    AND?: FactSessionWhereInput | FactSessionWhereInput[]
    OR?: FactSessionWhereInput[]
    NOT?: FactSessionWhereInput | FactSessionWhereInput[]
    id?: BigIntFilter<'FactSession'> | bigint | number
    sessionId?: StringFilter<'FactSession'> | string
    userId?: BigIntNullableFilter<'FactSession'> | bigint | number | null
    visitorId?: StringNullableFilter<'FactSession'> | string | null
    dateId?: IntFilter<'FactSession'> | number
    startTime?: DateTimeFilter<'FactSession'> | Date | string
    endTime?: DateTimeNullableFilter<'FactSession'> | Date | string | null
    durationSec?: IntNullableFilter<'FactSession'> | number | null
    pageViews?: IntFilter<'FactSession'> | number
    eventsCount?: IntFilter<'FactSession'> | number
    cartAddCount?: IntFilter<'FactSession'> | number
    orderCount?: IntFilter<'FactSession'> | number
    bounce?: BoolFilter<'FactSession'> | boolean
    source?: StringNullableFilter<'FactSession'> | string | null
    medium?: StringNullableFilter<'FactSession'> | string | null
    campaign?: StringNullableFilter<'FactSession'> | string | null
    deviceType?: StringNullableFilter<'FactSession'> | string | null
    browser?: StringNullableFilter<'FactSession'> | string | null
    os?: StringNullableFilter<'FactSession'> | string | null
    country?: StringNullableFilter<'FactSession'> | string | null
    city?: StringNullableFilter<'FactSession'> | string | null
  }

  export type FactSessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrderInput | SortOrder
    visitorId?: SortOrderInput | SortOrder
    dateId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    durationSec?: SortOrderInput | SortOrder
    pageViews?: SortOrder
    eventsCount?: SortOrder
    cartAddCount?: SortOrder
    orderCount?: SortOrder
    bounce?: SortOrder
    source?: SortOrderInput | SortOrder
    medium?: SortOrderInput | SortOrder
    campaign?: SortOrderInput | SortOrder
    deviceType?: SortOrderInput | SortOrder
    browser?: SortOrderInput | SortOrder
    os?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
  }

  export type FactSessionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: bigint | number
      sessionId?: string
      AND?: FactSessionWhereInput | FactSessionWhereInput[]
      OR?: FactSessionWhereInput[]
      NOT?: FactSessionWhereInput | FactSessionWhereInput[]
      userId?: BigIntNullableFilter<'FactSession'> | bigint | number | null
      visitorId?: StringNullableFilter<'FactSession'> | string | null
      dateId?: IntFilter<'FactSession'> | number
      startTime?: DateTimeFilter<'FactSession'> | Date | string
      endTime?: DateTimeNullableFilter<'FactSession'> | Date | string | null
      durationSec?: IntNullableFilter<'FactSession'> | number | null
      pageViews?: IntFilter<'FactSession'> | number
      eventsCount?: IntFilter<'FactSession'> | number
      cartAddCount?: IntFilter<'FactSession'> | number
      orderCount?: IntFilter<'FactSession'> | number
      bounce?: BoolFilter<'FactSession'> | boolean
      source?: StringNullableFilter<'FactSession'> | string | null
      medium?: StringNullableFilter<'FactSession'> | string | null
      campaign?: StringNullableFilter<'FactSession'> | string | null
      deviceType?: StringNullableFilter<'FactSession'> | string | null
      browser?: StringNullableFilter<'FactSession'> | string | null
      os?: StringNullableFilter<'FactSession'> | string | null
      country?: StringNullableFilter<'FactSession'> | string | null
      city?: StringNullableFilter<'FactSession'> | string | null
    },
    'id' | 'sessionId'
  >

  export type FactSessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrderInput | SortOrder
    visitorId?: SortOrderInput | SortOrder
    dateId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    durationSec?: SortOrderInput | SortOrder
    pageViews?: SortOrder
    eventsCount?: SortOrder
    cartAddCount?: SortOrder
    orderCount?: SortOrder
    bounce?: SortOrder
    source?: SortOrderInput | SortOrder
    medium?: SortOrderInput | SortOrder
    campaign?: SortOrderInput | SortOrder
    deviceType?: SortOrderInput | SortOrder
    browser?: SortOrderInput | SortOrder
    os?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    _count?: FactSessionCountOrderByAggregateInput
    _avg?: FactSessionAvgOrderByAggregateInput
    _max?: FactSessionMaxOrderByAggregateInput
    _min?: FactSessionMinOrderByAggregateInput
    _sum?: FactSessionSumOrderByAggregateInput
  }

  export type FactSessionScalarWhereWithAggregatesInput = {
    AND?:
      | FactSessionScalarWhereWithAggregatesInput
      | FactSessionScalarWhereWithAggregatesInput[]
    OR?: FactSessionScalarWhereWithAggregatesInput[]
    NOT?:
      | FactSessionScalarWhereWithAggregatesInput
      | FactSessionScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<'FactSession'> | bigint | number
    sessionId?: StringWithAggregatesFilter<'FactSession'> | string
    userId?:
      | BigIntNullableWithAggregatesFilter<'FactSession'>
      | bigint
      | number
      | null
    visitorId?:
      | StringNullableWithAggregatesFilter<'FactSession'>
      | string
      | null
    dateId?: IntWithAggregatesFilter<'FactSession'> | number
    startTime?: DateTimeWithAggregatesFilter<'FactSession'> | Date | string
    endTime?:
      | DateTimeNullableWithAggregatesFilter<'FactSession'>
      | Date
      | string
      | null
    durationSec?: IntNullableWithAggregatesFilter<'FactSession'> | number | null
    pageViews?: IntWithAggregatesFilter<'FactSession'> | number
    eventsCount?: IntWithAggregatesFilter<'FactSession'> | number
    cartAddCount?: IntWithAggregatesFilter<'FactSession'> | number
    orderCount?: IntWithAggregatesFilter<'FactSession'> | number
    bounce?: BoolWithAggregatesFilter<'FactSession'> | boolean
    source?: StringNullableWithAggregatesFilter<'FactSession'> | string | null
    medium?: StringNullableWithAggregatesFilter<'FactSession'> | string | null
    campaign?: StringNullableWithAggregatesFilter<'FactSession'> | string | null
    deviceType?:
      | StringNullableWithAggregatesFilter<'FactSession'>
      | string
      | null
    browser?: StringNullableWithAggregatesFilter<'FactSession'> | string | null
    os?: StringNullableWithAggregatesFilter<'FactSession'> | string | null
    country?: StringNullableWithAggregatesFilter<'FactSession'> | string | null
    city?: StringNullableWithAggregatesFilter<'FactSession'> | string | null
  }

  export type FactPageviewWhereInput = {
    AND?: FactPageviewWhereInput | FactPageviewWhereInput[]
    OR?: FactPageviewWhereInput[]
    NOT?: FactPageviewWhereInput | FactPageviewWhereInput[]
    id?: BigIntFilter<'FactPageview'> | bigint | number
    sessionId?: StringFilter<'FactPageview'> | string
    userId?: BigIntNullableFilter<'FactPageview'> | bigint | number | null
    url?: StringFilter<'FactPageview'> | string
    path?: StringFilter<'FactPageview'> | string
    referrer?: StringNullableFilter<'FactPageview'> | string | null
    timestamp?: DateTimeFilter<'FactPageview'> | Date | string
    timeOnPageSec?: IntNullableFilter<'FactPageview'> | number | null
    scrollDepth?: IntNullableFilter<'FactPageview'> | number | null
    loadTimeMs?: IntNullableFilter<'FactPageview'> | number | null
    productId?: BigIntNullableFilter<'FactPageview'> | bigint | number | null
    categoryId?: IntNullableFilter<'FactPageview'> | number | null
  }

  export type FactPageviewOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrderInput | SortOrder
    url?: SortOrder
    path?: SortOrder
    referrer?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    timeOnPageSec?: SortOrderInput | SortOrder
    scrollDepth?: SortOrderInput | SortOrder
    loadTimeMs?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
  }

  export type FactPageviewWhereUniqueInput = Prisma.AtLeast<
    {
      id?: bigint | number
      AND?: FactPageviewWhereInput | FactPageviewWhereInput[]
      OR?: FactPageviewWhereInput[]
      NOT?: FactPageviewWhereInput | FactPageviewWhereInput[]
      sessionId?: StringFilter<'FactPageview'> | string
      userId?: BigIntNullableFilter<'FactPageview'> | bigint | number | null
      url?: StringFilter<'FactPageview'> | string
      path?: StringFilter<'FactPageview'> | string
      referrer?: StringNullableFilter<'FactPageview'> | string | null
      timestamp?: DateTimeFilter<'FactPageview'> | Date | string
      timeOnPageSec?: IntNullableFilter<'FactPageview'> | number | null
      scrollDepth?: IntNullableFilter<'FactPageview'> | number | null
      loadTimeMs?: IntNullableFilter<'FactPageview'> | number | null
      productId?: BigIntNullableFilter<'FactPageview'> | bigint | number | null
      categoryId?: IntNullableFilter<'FactPageview'> | number | null
    },
    'id'
  >

  export type FactPageviewOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrderInput | SortOrder
    url?: SortOrder
    path?: SortOrder
    referrer?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    timeOnPageSec?: SortOrderInput | SortOrder
    scrollDepth?: SortOrderInput | SortOrder
    loadTimeMs?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    _count?: FactPageviewCountOrderByAggregateInput
    _avg?: FactPageviewAvgOrderByAggregateInput
    _max?: FactPageviewMaxOrderByAggregateInput
    _min?: FactPageviewMinOrderByAggregateInput
    _sum?: FactPageviewSumOrderByAggregateInput
  }

  export type FactPageviewScalarWhereWithAggregatesInput = {
    AND?:
      | FactPageviewScalarWhereWithAggregatesInput
      | FactPageviewScalarWhereWithAggregatesInput[]
    OR?: FactPageviewScalarWhereWithAggregatesInput[]
    NOT?:
      | FactPageviewScalarWhereWithAggregatesInput
      | FactPageviewScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<'FactPageview'> | bigint | number
    sessionId?: StringWithAggregatesFilter<'FactPageview'> | string
    userId?:
      | BigIntNullableWithAggregatesFilter<'FactPageview'>
      | bigint
      | number
      | null
    url?: StringWithAggregatesFilter<'FactPageview'> | string
    path?: StringWithAggregatesFilter<'FactPageview'> | string
    referrer?:
      | StringNullableWithAggregatesFilter<'FactPageview'>
      | string
      | null
    timestamp?: DateTimeWithAggregatesFilter<'FactPageview'> | Date | string
    timeOnPageSec?:
      | IntNullableWithAggregatesFilter<'FactPageview'>
      | number
      | null
    scrollDepth?:
      | IntNullableWithAggregatesFilter<'FactPageview'>
      | number
      | null
    loadTimeMs?: IntNullableWithAggregatesFilter<'FactPageview'> | number | null
    productId?:
      | BigIntNullableWithAggregatesFilter<'FactPageview'>
      | bigint
      | number
      | null
    categoryId?: IntNullableWithAggregatesFilter<'FactPageview'> | number | null
  }

  export type FactSearchWhereInput = {
    AND?: FactSearchWhereInput | FactSearchWhereInput[]
    OR?: FactSearchWhereInput[]
    NOT?: FactSearchWhereInput | FactSearchWhereInput[]
    id?: BigIntFilter<'FactSearch'> | bigint | number
    sessionId?: StringFilter<'FactSearch'> | string
    timestamp?: DateTimeFilter<'FactSearch'> | Date | string
    query?: StringFilter<'FactSearch'> | string
    resultCount?: IntFilter<'FactSearch'> | number
    clickedResultPos?: IntNullableFilter<'FactSearch'> | number | null
    converted?: BoolFilter<'FactSearch'> | boolean
  }

  export type FactSearchOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    timestamp?: SortOrder
    query?: SortOrder
    resultCount?: SortOrder
    clickedResultPos?: SortOrderInput | SortOrder
    converted?: SortOrder
  }

  export type FactSearchWhereUniqueInput = Prisma.AtLeast<
    {
      id?: bigint | number
      AND?: FactSearchWhereInput | FactSearchWhereInput[]
      OR?: FactSearchWhereInput[]
      NOT?: FactSearchWhereInput | FactSearchWhereInput[]
      sessionId?: StringFilter<'FactSearch'> | string
      timestamp?: DateTimeFilter<'FactSearch'> | Date | string
      query?: StringFilter<'FactSearch'> | string
      resultCount?: IntFilter<'FactSearch'> | number
      clickedResultPos?: IntNullableFilter<'FactSearch'> | number | null
      converted?: BoolFilter<'FactSearch'> | boolean
    },
    'id'
  >

  export type FactSearchOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    timestamp?: SortOrder
    query?: SortOrder
    resultCount?: SortOrder
    clickedResultPos?: SortOrderInput | SortOrder
    converted?: SortOrder
    _count?: FactSearchCountOrderByAggregateInput
    _avg?: FactSearchAvgOrderByAggregateInput
    _max?: FactSearchMaxOrderByAggregateInput
    _min?: FactSearchMinOrderByAggregateInput
    _sum?: FactSearchSumOrderByAggregateInput
  }

  export type FactSearchScalarWhereWithAggregatesInput = {
    AND?:
      | FactSearchScalarWhereWithAggregatesInput
      | FactSearchScalarWhereWithAggregatesInput[]
    OR?: FactSearchScalarWhereWithAggregatesInput[]
    NOT?:
      | FactSearchScalarWhereWithAggregatesInput
      | FactSearchScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<'FactSearch'> | bigint | number
    sessionId?: StringWithAggregatesFilter<'FactSearch'> | string
    timestamp?: DateTimeWithAggregatesFilter<'FactSearch'> | Date | string
    query?: StringWithAggregatesFilter<'FactSearch'> | string
    resultCount?: IntWithAggregatesFilter<'FactSearch'> | number
    clickedResultPos?:
      | IntNullableWithAggregatesFilter<'FactSearch'>
      | number
      | null
    converted?: BoolWithAggregatesFilter<'FactSearch'> | boolean
  }

  export type FactCartActivityWhereInput = {
    AND?: FactCartActivityWhereInput | FactCartActivityWhereInput[]
    OR?: FactCartActivityWhereInput[]
    NOT?: FactCartActivityWhereInput | FactCartActivityWhereInput[]
    id?: BigIntFilter<'FactCartActivity'> | bigint | number
    sessionId?: StringFilter<'FactCartActivity'> | string
    userId?: BigIntNullableFilter<'FactCartActivity'> | bigint | number | null
    timestamp?: DateTimeFilter<'FactCartActivity'> | Date | string
    action?: StringFilter<'FactCartActivity'> | string
    productId?: BigIntFilter<'FactCartActivity'> | bigint | number
    sku?: StringFilter<'FactCartActivity'> | string
    quantityDelta?: IntFilter<'FactCartActivity'> | number
    priceSnapshot?:
      | DecimalFilter<'FactCartActivity'>
      | Decimal
      | DecimalJsLike
      | number
      | string
  }

  export type FactCartActivityOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    action?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    quantityDelta?: SortOrder
    priceSnapshot?: SortOrder
  }

  export type FactCartActivityWhereUniqueInput = Prisma.AtLeast<
    {
      id?: bigint | number
      AND?: FactCartActivityWhereInput | FactCartActivityWhereInput[]
      OR?: FactCartActivityWhereInput[]
      NOT?: FactCartActivityWhereInput | FactCartActivityWhereInput[]
      sessionId?: StringFilter<'FactCartActivity'> | string
      userId?: BigIntNullableFilter<'FactCartActivity'> | bigint | number | null
      timestamp?: DateTimeFilter<'FactCartActivity'> | Date | string
      action?: StringFilter<'FactCartActivity'> | string
      productId?: BigIntFilter<'FactCartActivity'> | bigint | number
      sku?: StringFilter<'FactCartActivity'> | string
      quantityDelta?: IntFilter<'FactCartActivity'> | number
      priceSnapshot?:
        | DecimalFilter<'FactCartActivity'>
        | Decimal
        | DecimalJsLike
        | number
        | string
    },
    'id'
  >

  export type FactCartActivityOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    action?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    quantityDelta?: SortOrder
    priceSnapshot?: SortOrder
    _count?: FactCartActivityCountOrderByAggregateInput
    _avg?: FactCartActivityAvgOrderByAggregateInput
    _max?: FactCartActivityMaxOrderByAggregateInput
    _min?: FactCartActivityMinOrderByAggregateInput
    _sum?: FactCartActivitySumOrderByAggregateInput
  }

  export type FactCartActivityScalarWhereWithAggregatesInput = {
    AND?:
      | FactCartActivityScalarWhereWithAggregatesInput
      | FactCartActivityScalarWhereWithAggregatesInput[]
    OR?: FactCartActivityScalarWhereWithAggregatesInput[]
    NOT?:
      | FactCartActivityScalarWhereWithAggregatesInput
      | FactCartActivityScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<'FactCartActivity'> | bigint | number
    sessionId?: StringWithAggregatesFilter<'FactCartActivity'> | string
    userId?:
      | BigIntNullableWithAggregatesFilter<'FactCartActivity'>
      | bigint
      | number
      | null
    timestamp?: DateTimeWithAggregatesFilter<'FactCartActivity'> | Date | string
    action?: StringWithAggregatesFilter<'FactCartActivity'> | string
    productId?: BigIntWithAggregatesFilter<'FactCartActivity'> | bigint | number
    sku?: StringWithAggregatesFilter<'FactCartActivity'> | string
    quantityDelta?: IntWithAggregatesFilter<'FactCartActivity'> | number
    priceSnapshot?:
      | DecimalWithAggregatesFilter<'FactCartActivity'>
      | Decimal
      | DecimalJsLike
      | number
      | string
  }

  export type FactReviewWhereInput = {
    AND?: FactReviewWhereInput | FactReviewWhereInput[]
    OR?: FactReviewWhereInput[]
    NOT?: FactReviewWhereInput | FactReviewWhereInput[]
    id?: BigIntFilter<'FactReview'> | bigint | number
    reviewId?: BigIntFilter<'FactReview'> | bigint | number
    productId?: BigIntFilter<'FactReview'> | bigint | number
    userId?: BigIntNullableFilter<'FactReview'> | bigint | number | null
    dateId?: IntFilter<'FactReview'> | number
    timestamp?: DateTimeFilter<'FactReview'> | Date | string
    rating?: IntFilter<'FactReview'> | number
    hasText?: BoolFilter<'FactReview'> | boolean
    hasImages?: BoolFilter<'FactReview'> | boolean
    textLength?: IntFilter<'FactReview'> | number
    sentimentScore?: FloatNullableFilter<'FactReview'> | number | null
    verified?: BoolFilter<'FactReview'> | boolean
  }

  export type FactReviewOrderByWithRelationInput = {
    id?: SortOrder
    reviewId?: SortOrder
    productId?: SortOrder
    userId?: SortOrderInput | SortOrder
    dateId?: SortOrder
    timestamp?: SortOrder
    rating?: SortOrder
    hasText?: SortOrder
    hasImages?: SortOrder
    textLength?: SortOrder
    sentimentScore?: SortOrderInput | SortOrder
    verified?: SortOrder
  }

  export type FactReviewWhereUniqueInput = Prisma.AtLeast<
    {
      id?: bigint | number
      reviewId?: bigint | number
      AND?: FactReviewWhereInput | FactReviewWhereInput[]
      OR?: FactReviewWhereInput[]
      NOT?: FactReviewWhereInput | FactReviewWhereInput[]
      productId?: BigIntFilter<'FactReview'> | bigint | number
      userId?: BigIntNullableFilter<'FactReview'> | bigint | number | null
      dateId?: IntFilter<'FactReview'> | number
      timestamp?: DateTimeFilter<'FactReview'> | Date | string
      rating?: IntFilter<'FactReview'> | number
      hasText?: BoolFilter<'FactReview'> | boolean
      hasImages?: BoolFilter<'FactReview'> | boolean
      textLength?: IntFilter<'FactReview'> | number
      sentimentScore?: FloatNullableFilter<'FactReview'> | number | null
      verified?: BoolFilter<'FactReview'> | boolean
    },
    'id' | 'reviewId'
  >

  export type FactReviewOrderByWithAggregationInput = {
    id?: SortOrder
    reviewId?: SortOrder
    productId?: SortOrder
    userId?: SortOrderInput | SortOrder
    dateId?: SortOrder
    timestamp?: SortOrder
    rating?: SortOrder
    hasText?: SortOrder
    hasImages?: SortOrder
    textLength?: SortOrder
    sentimentScore?: SortOrderInput | SortOrder
    verified?: SortOrder
    _count?: FactReviewCountOrderByAggregateInput
    _avg?: FactReviewAvgOrderByAggregateInput
    _max?: FactReviewMaxOrderByAggregateInput
    _min?: FactReviewMinOrderByAggregateInput
    _sum?: FactReviewSumOrderByAggregateInput
  }

  export type FactReviewScalarWhereWithAggregatesInput = {
    AND?:
      | FactReviewScalarWhereWithAggregatesInput
      | FactReviewScalarWhereWithAggregatesInput[]
    OR?: FactReviewScalarWhereWithAggregatesInput[]
    NOT?:
      | FactReviewScalarWhereWithAggregatesInput
      | FactReviewScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<'FactReview'> | bigint | number
    reviewId?: BigIntWithAggregatesFilter<'FactReview'> | bigint | number
    productId?: BigIntWithAggregatesFilter<'FactReview'> | bigint | number
    userId?:
      | BigIntNullableWithAggregatesFilter<'FactReview'>
      | bigint
      | number
      | null
    dateId?: IntWithAggregatesFilter<'FactReview'> | number
    timestamp?: DateTimeWithAggregatesFilter<'FactReview'> | Date | string
    rating?: IntWithAggregatesFilter<'FactReview'> | number
    hasText?: BoolWithAggregatesFilter<'FactReview'> | boolean
    hasImages?: BoolWithAggregatesFilter<'FactReview'> | boolean
    textLength?: IntWithAggregatesFilter<'FactReview'> | number
    sentimentScore?:
      | FloatNullableWithAggregatesFilter<'FactReview'>
      | number
      | null
    verified?: BoolWithAggregatesFilter<'FactReview'> | boolean
  }

  export type DimProductWhereInput = {
    AND?: DimProductWhereInput | DimProductWhereInput[]
    OR?: DimProductWhereInput[]
    NOT?: DimProductWhereInput | DimProductWhereInput[]
    productScId?: BigIntFilter<'DimProduct'> | bigint | number
    productId?: BigIntFilter<'DimProduct'> | bigint | number
    sku?: StringFilter<'DimProduct'> | string
    name?: StringFilter<'DimProduct'> | string
    categoryId?: IntNullableFilter<'DimProduct'> | number | null
    brandId?: IntNullableFilter<'DimProduct'> | number | null
    currentPrice?:
      | DecimalFilter<'DimProduct'>
      | Decimal
      | DecimalJsLike
      | number
      | string
    costPrice?:
      | DecimalNullableFilter<'DimProduct'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    isActive?: BoolFilter<'DimProduct'> | boolean
    validFrom?: DateTimeFilter<'DimProduct'> | Date | string
    validTo?: DateTimeNullableFilter<'DimProduct'> | Date | string | null
    isCurrent?: BoolFilter<'DimProduct'> | boolean
    categoryName?: StringNullableFilter<'DimProduct'> | string | null
    brandName?: StringNullableFilter<'DimProduct'> | string | null
    supplier?: StringNullableFilter<'DimProduct'> | string | null
    tags?: StringNullableListFilter<'DimProduct'>
  }

  export type DimProductOrderByWithRelationInput = {
    productScId?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    brandId?: SortOrderInput | SortOrder
    currentPrice?: SortOrder
    costPrice?: SortOrderInput | SortOrder
    isActive?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrderInput | SortOrder
    isCurrent?: SortOrder
    categoryName?: SortOrderInput | SortOrder
    brandName?: SortOrderInput | SortOrder
    supplier?: SortOrderInput | SortOrder
    tags?: SortOrder
  }

  export type DimProductWhereUniqueInput = Prisma.AtLeast<
    {
      productScId?: bigint | number
      AND?: DimProductWhereInput | DimProductWhereInput[]
      OR?: DimProductWhereInput[]
      NOT?: DimProductWhereInput | DimProductWhereInput[]
      productId?: BigIntFilter<'DimProduct'> | bigint | number
      sku?: StringFilter<'DimProduct'> | string
      name?: StringFilter<'DimProduct'> | string
      categoryId?: IntNullableFilter<'DimProduct'> | number | null
      brandId?: IntNullableFilter<'DimProduct'> | number | null
      currentPrice?:
        | DecimalFilter<'DimProduct'>
        | Decimal
        | DecimalJsLike
        | number
        | string
      costPrice?:
        | DecimalNullableFilter<'DimProduct'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null
      isActive?: BoolFilter<'DimProduct'> | boolean
      validFrom?: DateTimeFilter<'DimProduct'> | Date | string
      validTo?: DateTimeNullableFilter<'DimProduct'> | Date | string | null
      isCurrent?: BoolFilter<'DimProduct'> | boolean
      categoryName?: StringNullableFilter<'DimProduct'> | string | null
      brandName?: StringNullableFilter<'DimProduct'> | string | null
      supplier?: StringNullableFilter<'DimProduct'> | string | null
      tags?: StringNullableListFilter<'DimProduct'>
    },
    'productScId'
  >

  export type DimProductOrderByWithAggregationInput = {
    productScId?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    brandId?: SortOrderInput | SortOrder
    currentPrice?: SortOrder
    costPrice?: SortOrderInput | SortOrder
    isActive?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrderInput | SortOrder
    isCurrent?: SortOrder
    categoryName?: SortOrderInput | SortOrder
    brandName?: SortOrderInput | SortOrder
    supplier?: SortOrderInput | SortOrder
    tags?: SortOrder
    _count?: DimProductCountOrderByAggregateInput
    _avg?: DimProductAvgOrderByAggregateInput
    _max?: DimProductMaxOrderByAggregateInput
    _min?: DimProductMinOrderByAggregateInput
    _sum?: DimProductSumOrderByAggregateInput
  }

  export type DimProductScalarWhereWithAggregatesInput = {
    AND?:
      | DimProductScalarWhereWithAggregatesInput
      | DimProductScalarWhereWithAggregatesInput[]
    OR?: DimProductScalarWhereWithAggregatesInput[]
    NOT?:
      | DimProductScalarWhereWithAggregatesInput
      | DimProductScalarWhereWithAggregatesInput[]
    productScId?: BigIntWithAggregatesFilter<'DimProduct'> | bigint | number
    productId?: BigIntWithAggregatesFilter<'DimProduct'> | bigint | number
    sku?: StringWithAggregatesFilter<'DimProduct'> | string
    name?: StringWithAggregatesFilter<'DimProduct'> | string
    categoryId?: IntNullableWithAggregatesFilter<'DimProduct'> | number | null
    brandId?: IntNullableWithAggregatesFilter<'DimProduct'> | number | null
    currentPrice?:
      | DecimalWithAggregatesFilter<'DimProduct'>
      | Decimal
      | DecimalJsLike
      | number
      | string
    costPrice?:
      | DecimalNullableWithAggregatesFilter<'DimProduct'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    isActive?: BoolWithAggregatesFilter<'DimProduct'> | boolean
    validFrom?: DateTimeWithAggregatesFilter<'DimProduct'> | Date | string
    validTo?:
      | DateTimeNullableWithAggregatesFilter<'DimProduct'>
      | Date
      | string
      | null
    isCurrent?: BoolWithAggregatesFilter<'DimProduct'> | boolean
    categoryName?:
      | StringNullableWithAggregatesFilter<'DimProduct'>
      | string
      | null
    brandName?: StringNullableWithAggregatesFilter<'DimProduct'> | string | null
    supplier?: StringNullableWithAggregatesFilter<'DimProduct'> | string | null
    tags?: StringNullableListFilter<'DimProduct'>
  }

  export type DimUserWhereInput = {
    AND?: DimUserWhereInput | DimUserWhereInput[]
    OR?: DimUserWhereInput[]
    NOT?: DimUserWhereInput | DimUserWhereInput[]
    userScId?: BigIntFilter<'DimUser'> | bigint | number
    userId?: BigIntFilter<'DimUser'> | bigint | number
    email?: StringNullableFilter<'DimUser'> | string | null
    city?: StringNullableFilter<'DimUser'> | string | null
    country?: StringNullableFilter<'DimUser'> | string | null
    gender?: StringNullableFilter<'DimUser'> | string | null
    ageGroup?: StringNullableFilter<'DimUser'> | string | null
    segment?: StringNullableFilter<'DimUser'> | string | null
    ltv?:
      | DecimalNullableFilter<'DimUser'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    firstOrderDate?: DateTimeNullableFilter<'DimUser'> | Date | string | null
    validFrom?: DateTimeFilter<'DimUser'> | Date | string
    validTo?: DateTimeNullableFilter<'DimUser'> | Date | string | null
    isCurrent?: BoolFilter<'DimUser'> | boolean
  }

  export type DimUserOrderByWithRelationInput = {
    userScId?: SortOrder
    userId?: SortOrder
    email?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    ageGroup?: SortOrderInput | SortOrder
    segment?: SortOrderInput | SortOrder
    ltv?: SortOrderInput | SortOrder
    firstOrderDate?: SortOrderInput | SortOrder
    validFrom?: SortOrder
    validTo?: SortOrderInput | SortOrder
    isCurrent?: SortOrder
  }

  export type DimUserWhereUniqueInput = Prisma.AtLeast<
    {
      userScId?: bigint | number
      AND?: DimUserWhereInput | DimUserWhereInput[]
      OR?: DimUserWhereInput[]
      NOT?: DimUserWhereInput | DimUserWhereInput[]
      userId?: BigIntFilter<'DimUser'> | bigint | number
      email?: StringNullableFilter<'DimUser'> | string | null
      city?: StringNullableFilter<'DimUser'> | string | null
      country?: StringNullableFilter<'DimUser'> | string | null
      gender?: StringNullableFilter<'DimUser'> | string | null
      ageGroup?: StringNullableFilter<'DimUser'> | string | null
      segment?: StringNullableFilter<'DimUser'> | string | null
      ltv?:
        | DecimalNullableFilter<'DimUser'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null
      firstOrderDate?: DateTimeNullableFilter<'DimUser'> | Date | string | null
      validFrom?: DateTimeFilter<'DimUser'> | Date | string
      validTo?: DateTimeNullableFilter<'DimUser'> | Date | string | null
      isCurrent?: BoolFilter<'DimUser'> | boolean
    },
    'userScId'
  >

  export type DimUserOrderByWithAggregationInput = {
    userScId?: SortOrder
    userId?: SortOrder
    email?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    ageGroup?: SortOrderInput | SortOrder
    segment?: SortOrderInput | SortOrder
    ltv?: SortOrderInput | SortOrder
    firstOrderDate?: SortOrderInput | SortOrder
    validFrom?: SortOrder
    validTo?: SortOrderInput | SortOrder
    isCurrent?: SortOrder
    _count?: DimUserCountOrderByAggregateInput
    _avg?: DimUserAvgOrderByAggregateInput
    _max?: DimUserMaxOrderByAggregateInput
    _min?: DimUserMinOrderByAggregateInput
    _sum?: DimUserSumOrderByAggregateInput
  }

  export type DimUserScalarWhereWithAggregatesInput = {
    AND?:
      | DimUserScalarWhereWithAggregatesInput
      | DimUserScalarWhereWithAggregatesInput[]
    OR?: DimUserScalarWhereWithAggregatesInput[]
    NOT?:
      | DimUserScalarWhereWithAggregatesInput
      | DimUserScalarWhereWithAggregatesInput[]
    userScId?: BigIntWithAggregatesFilter<'DimUser'> | bigint | number
    userId?: BigIntWithAggregatesFilter<'DimUser'> | bigint | number
    email?: StringNullableWithAggregatesFilter<'DimUser'> | string | null
    city?: StringNullableWithAggregatesFilter<'DimUser'> | string | null
    country?: StringNullableWithAggregatesFilter<'DimUser'> | string | null
    gender?: StringNullableWithAggregatesFilter<'DimUser'> | string | null
    ageGroup?: StringNullableWithAggregatesFilter<'DimUser'> | string | null
    segment?: StringNullableWithAggregatesFilter<'DimUser'> | string | null
    ltv?:
      | DecimalNullableWithAggregatesFilter<'DimUser'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    firstOrderDate?:
      | DateTimeNullableWithAggregatesFilter<'DimUser'>
      | Date
      | string
      | null
    validFrom?: DateTimeWithAggregatesFilter<'DimUser'> | Date | string
    validTo?:
      | DateTimeNullableWithAggregatesFilter<'DimUser'>
      | Date
      | string
      | null
    isCurrent?: BoolWithAggregatesFilter<'DimUser'> | boolean
  }

  export type DimDateWhereInput = {
    AND?: DimDateWhereInput | DimDateWhereInput[]
    OR?: DimDateWhereInput[]
    NOT?: DimDateWhereInput | DimDateWhereInput[]
    dateId?: IntFilter<'DimDate'> | number
    date?: DateTimeFilter<'DimDate'> | Date | string
    dayOfWeek?: IntFilter<'DimDate'> | number
    dayName?: StringFilter<'DimDate'> | string
    dayOfMonth?: IntFilter<'DimDate'> | number
    weekOfYear?: IntFilter<'DimDate'> | number
    month?: IntFilter<'DimDate'> | number
    monthName?: StringFilter<'DimDate'> | string
    quarter?: IntFilter<'DimDate'> | number
    year?: IntFilter<'DimDate'> | number
    isWeekend?: BoolFilter<'DimDate'> | boolean
    isHoliday?: BoolFilter<'DimDate'> | boolean
    fiscalYear?: IntNullableFilter<'DimDate'> | number | null
    fiscalPeriod?: IntNullableFilter<'DimDate'> | number | null
  }

  export type DimDateOrderByWithRelationInput = {
    dateId?: SortOrder
    date?: SortOrder
    dayOfWeek?: SortOrder
    dayName?: SortOrder
    dayOfMonth?: SortOrder
    weekOfYear?: SortOrder
    month?: SortOrder
    monthName?: SortOrder
    quarter?: SortOrder
    year?: SortOrder
    isWeekend?: SortOrder
    isHoliday?: SortOrder
    fiscalYear?: SortOrderInput | SortOrder
    fiscalPeriod?: SortOrderInput | SortOrder
  }

  export type DimDateWhereUniqueInput = Prisma.AtLeast<
    {
      dateId?: number
      date?: Date | string
      AND?: DimDateWhereInput | DimDateWhereInput[]
      OR?: DimDateWhereInput[]
      NOT?: DimDateWhereInput | DimDateWhereInput[]
      dayOfWeek?: IntFilter<'DimDate'> | number
      dayName?: StringFilter<'DimDate'> | string
      dayOfMonth?: IntFilter<'DimDate'> | number
      weekOfYear?: IntFilter<'DimDate'> | number
      month?: IntFilter<'DimDate'> | number
      monthName?: StringFilter<'DimDate'> | string
      quarter?: IntFilter<'DimDate'> | number
      year?: IntFilter<'DimDate'> | number
      isWeekend?: BoolFilter<'DimDate'> | boolean
      isHoliday?: BoolFilter<'DimDate'> | boolean
      fiscalYear?: IntNullableFilter<'DimDate'> | number | null
      fiscalPeriod?: IntNullableFilter<'DimDate'> | number | null
    },
    'dateId' | 'date'
  >

  export type DimDateOrderByWithAggregationInput = {
    dateId?: SortOrder
    date?: SortOrder
    dayOfWeek?: SortOrder
    dayName?: SortOrder
    dayOfMonth?: SortOrder
    weekOfYear?: SortOrder
    month?: SortOrder
    monthName?: SortOrder
    quarter?: SortOrder
    year?: SortOrder
    isWeekend?: SortOrder
    isHoliday?: SortOrder
    fiscalYear?: SortOrderInput | SortOrder
    fiscalPeriod?: SortOrderInput | SortOrder
    _count?: DimDateCountOrderByAggregateInput
    _avg?: DimDateAvgOrderByAggregateInput
    _max?: DimDateMaxOrderByAggregateInput
    _min?: DimDateMinOrderByAggregateInput
    _sum?: DimDateSumOrderByAggregateInput
  }

  export type DimDateScalarWhereWithAggregatesInput = {
    AND?:
      | DimDateScalarWhereWithAggregatesInput
      | DimDateScalarWhereWithAggregatesInput[]
    OR?: DimDateScalarWhereWithAggregatesInput[]
    NOT?:
      | DimDateScalarWhereWithAggregatesInput
      | DimDateScalarWhereWithAggregatesInput[]
    dateId?: IntWithAggregatesFilter<'DimDate'> | number
    date?: DateTimeWithAggregatesFilter<'DimDate'> | Date | string
    dayOfWeek?: IntWithAggregatesFilter<'DimDate'> | number
    dayName?: StringWithAggregatesFilter<'DimDate'> | string
    dayOfMonth?: IntWithAggregatesFilter<'DimDate'> | number
    weekOfYear?: IntWithAggregatesFilter<'DimDate'> | number
    month?: IntWithAggregatesFilter<'DimDate'> | number
    monthName?: StringWithAggregatesFilter<'DimDate'> | string
    quarter?: IntWithAggregatesFilter<'DimDate'> | number
    year?: IntWithAggregatesFilter<'DimDate'> | number
    isWeekend?: BoolWithAggregatesFilter<'DimDate'> | boolean
    isHoliday?: BoolWithAggregatesFilter<'DimDate'> | boolean
    fiscalYear?: IntNullableWithAggregatesFilter<'DimDate'> | number | null
    fiscalPeriod?: IntNullableWithAggregatesFilter<'DimDate'> | number | null
  }

  export type DimMarketingWhereInput = {
    AND?: DimMarketingWhereInput | DimMarketingWhereInput[]
    OR?: DimMarketingWhereInput[]
    NOT?: DimMarketingWhereInput | DimMarketingWhereInput[]
    id?: BigIntFilter<'DimMarketing'> | bigint | number
    utmSource?: StringNullableFilter<'DimMarketing'> | string | null
    utmMedium?: StringNullableFilter<'DimMarketing'> | string | null
    utmCampaign?: StringNullableFilter<'DimMarketing'> | string | null
    utmTerm?: StringNullableFilter<'DimMarketing'> | string | null
    utmContent?: StringNullableFilter<'DimMarketing'> | string | null
    channelGroup?: StringNullableFilter<'DimMarketing'> | string | null
    createdAt?: DateTimeFilter<'DimMarketing'> | Date | string
  }

  export type DimMarketingOrderByWithRelationInput = {
    id?: SortOrder
    utmSource?: SortOrderInput | SortOrder
    utmMedium?: SortOrderInput | SortOrder
    utmCampaign?: SortOrderInput | SortOrder
    utmTerm?: SortOrderInput | SortOrder
    utmContent?: SortOrderInput | SortOrder
    channelGroup?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type DimMarketingWhereUniqueInput = Prisma.AtLeast<
    {
      id?: bigint | number
      utmSource_utmMedium_utmCampaign_utmTerm_utmContent?: DimMarketingUtmSourceUtmMediumUtmCampaignUtmTermUtmContentCompoundUniqueInput
      AND?: DimMarketingWhereInput | DimMarketingWhereInput[]
      OR?: DimMarketingWhereInput[]
      NOT?: DimMarketingWhereInput | DimMarketingWhereInput[]
      utmSource?: StringNullableFilter<'DimMarketing'> | string | null
      utmMedium?: StringNullableFilter<'DimMarketing'> | string | null
      utmCampaign?: StringNullableFilter<'DimMarketing'> | string | null
      utmTerm?: StringNullableFilter<'DimMarketing'> | string | null
      utmContent?: StringNullableFilter<'DimMarketing'> | string | null
      channelGroup?: StringNullableFilter<'DimMarketing'> | string | null
      createdAt?: DateTimeFilter<'DimMarketing'> | Date | string
    },
    'id' | 'utmSource_utmMedium_utmCampaign_utmTerm_utmContent'
  >

  export type DimMarketingOrderByWithAggregationInput = {
    id?: SortOrder
    utmSource?: SortOrderInput | SortOrder
    utmMedium?: SortOrderInput | SortOrder
    utmCampaign?: SortOrderInput | SortOrder
    utmTerm?: SortOrderInput | SortOrder
    utmContent?: SortOrderInput | SortOrder
    channelGroup?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DimMarketingCountOrderByAggregateInput
    _avg?: DimMarketingAvgOrderByAggregateInput
    _max?: DimMarketingMaxOrderByAggregateInput
    _min?: DimMarketingMinOrderByAggregateInput
    _sum?: DimMarketingSumOrderByAggregateInput
  }

  export type DimMarketingScalarWhereWithAggregatesInput = {
    AND?:
      | DimMarketingScalarWhereWithAggregatesInput
      | DimMarketingScalarWhereWithAggregatesInput[]
    OR?: DimMarketingScalarWhereWithAggregatesInput[]
    NOT?:
      | DimMarketingScalarWhereWithAggregatesInput
      | DimMarketingScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<'DimMarketing'> | bigint | number
    utmSource?:
      | StringNullableWithAggregatesFilter<'DimMarketing'>
      | string
      | null
    utmMedium?:
      | StringNullableWithAggregatesFilter<'DimMarketing'>
      | string
      | null
    utmCampaign?:
      | StringNullableWithAggregatesFilter<'DimMarketing'>
      | string
      | null
    utmTerm?: StringNullableWithAggregatesFilter<'DimMarketing'> | string | null
    utmContent?:
      | StringNullableWithAggregatesFilter<'DimMarketing'>
      | string
      | null
    channelGroup?:
      | StringNullableWithAggregatesFilter<'DimMarketing'>
      | string
      | null
    createdAt?: DateTimeWithAggregatesFilter<'DimMarketing'> | Date | string
  }

  export type DimLocationWhereInput = {
    AND?: DimLocationWhereInput | DimLocationWhereInput[]
    OR?: DimLocationWhereInput[]
    NOT?: DimLocationWhereInput | DimLocationWhereInput[]
    id?: IntFilter<'DimLocation'> | number
    city?: StringNullableFilter<'DimLocation'> | string | null
    state?: StringNullableFilter<'DimLocation'> | string | null
    postalCode?: StringNullableFilter<'DimLocation'> | string | null
    country?: StringFilter<'DimLocation'> | string
    countryCode?: StringFilter<'DimLocation'> | string
    region?: StringNullableFilter<'DimLocation'> | string | null
  }

  export type DimLocationOrderByWithRelationInput = {
    id?: SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrder
    countryCode?: SortOrder
    region?: SortOrderInput | SortOrder
  }

  export type DimLocationWhereUniqueInput = Prisma.AtLeast<
    {
      id?: number
      country_state_city_postalCode?: DimLocationCountryStateCityPostalCodeCompoundUniqueInput
      AND?: DimLocationWhereInput | DimLocationWhereInput[]
      OR?: DimLocationWhereInput[]
      NOT?: DimLocationWhereInput | DimLocationWhereInput[]
      city?: StringNullableFilter<'DimLocation'> | string | null
      state?: StringNullableFilter<'DimLocation'> | string | null
      postalCode?: StringNullableFilter<'DimLocation'> | string | null
      country?: StringFilter<'DimLocation'> | string
      countryCode?: StringFilter<'DimLocation'> | string
      region?: StringNullableFilter<'DimLocation'> | string | null
    },
    'id' | 'country_state_city_postalCode'
  >

  export type DimLocationOrderByWithAggregationInput = {
    id?: SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrder
    countryCode?: SortOrder
    region?: SortOrderInput | SortOrder
    _count?: DimLocationCountOrderByAggregateInput
    _avg?: DimLocationAvgOrderByAggregateInput
    _max?: DimLocationMaxOrderByAggregateInput
    _min?: DimLocationMinOrderByAggregateInput
    _sum?: DimLocationSumOrderByAggregateInput
  }

  export type DimLocationScalarWhereWithAggregatesInput = {
    AND?:
      | DimLocationScalarWhereWithAggregatesInput
      | DimLocationScalarWhereWithAggregatesInput[]
    OR?: DimLocationScalarWhereWithAggregatesInput[]
    NOT?:
      | DimLocationScalarWhereWithAggregatesInput
      | DimLocationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<'DimLocation'> | number
    city?: StringNullableWithAggregatesFilter<'DimLocation'> | string | null
    state?: StringNullableWithAggregatesFilter<'DimLocation'> | string | null
    postalCode?:
      | StringNullableWithAggregatesFilter<'DimLocation'>
      | string
      | null
    country?: StringWithAggregatesFilter<'DimLocation'> | string
    countryCode?: StringWithAggregatesFilter<'DimLocation'> | string
    region?: StringNullableWithAggregatesFilter<'DimLocation'> | string | null
  }

  export type IngestOffsetWhereInput = {
    AND?: IngestOffsetWhereInput | IngestOffsetWhereInput[]
    OR?: IngestOffsetWhereInput[]
    NOT?: IngestOffsetWhereInput | IngestOffsetWhereInput[]
    id?: BigIntFilter<'IngestOffset'> | bigint | number
    source?: StringFilter<'IngestOffset'> | string
    partition?: IntFilter<'IngestOffset'> | number
    lastOffset?: BigIntNullableFilter<'IngestOffset'> | bigint | number | null
    lastTimestamp?:
      | DateTimeNullableFilter<'IngestOffset'>
      | Date
      | string
      | null
    payloadHash?: StringNullableFilter<'IngestOffset'> | string | null
    updatedAt?: DateTimeFilter<'IngestOffset'> | Date | string
  }

  export type IngestOffsetOrderByWithRelationInput = {
    id?: SortOrder
    source?: SortOrder
    partition?: SortOrder
    lastOffset?: SortOrderInput | SortOrder
    lastTimestamp?: SortOrderInput | SortOrder
    payloadHash?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
  }

  export type IngestOffsetWhereUniqueInput = Prisma.AtLeast<
    {
      id?: bigint | number
      source?: string
      AND?: IngestOffsetWhereInput | IngestOffsetWhereInput[]
      OR?: IngestOffsetWhereInput[]
      NOT?: IngestOffsetWhereInput | IngestOffsetWhereInput[]
      partition?: IntFilter<'IngestOffset'> | number
      lastOffset?: BigIntNullableFilter<'IngestOffset'> | bigint | number | null
      lastTimestamp?:
        | DateTimeNullableFilter<'IngestOffset'>
        | Date
        | string
        | null
      payloadHash?: StringNullableFilter<'IngestOffset'> | string | null
      updatedAt?: DateTimeFilter<'IngestOffset'> | Date | string
    },
    'id' | 'source'
  >

  export type IngestOffsetOrderByWithAggregationInput = {
    id?: SortOrder
    source?: SortOrder
    partition?: SortOrder
    lastOffset?: SortOrderInput | SortOrder
    lastTimestamp?: SortOrderInput | SortOrder
    payloadHash?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: IngestOffsetCountOrderByAggregateInput
    _avg?: IngestOffsetAvgOrderByAggregateInput
    _max?: IngestOffsetMaxOrderByAggregateInput
    _min?: IngestOffsetMinOrderByAggregateInput
    _sum?: IngestOffsetSumOrderByAggregateInput
  }

  export type IngestOffsetScalarWhereWithAggregatesInput = {
    AND?:
      | IngestOffsetScalarWhereWithAggregatesInput
      | IngestOffsetScalarWhereWithAggregatesInput[]
    OR?: IngestOffsetScalarWhereWithAggregatesInput[]
    NOT?:
      | IngestOffsetScalarWhereWithAggregatesInput
      | IngestOffsetScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<'IngestOffset'> | bigint | number
    source?: StringWithAggregatesFilter<'IngestOffset'> | string
    partition?: IntWithAggregatesFilter<'IngestOffset'> | number
    lastOffset?:
      | BigIntNullableWithAggregatesFilter<'IngestOffset'>
      | bigint
      | number
      | null
    lastTimestamp?:
      | DateTimeNullableWithAggregatesFilter<'IngestOffset'>
      | Date
      | string
      | null
    payloadHash?:
      | StringNullableWithAggregatesFilter<'IngestOffset'>
      | string
      | null
    updatedAt?: DateTimeWithAggregatesFilter<'IngestOffset'> | Date | string
  }

  export type StagingRawEventWhereInput = {
    AND?: StagingRawEventWhereInput | StagingRawEventWhereInput[]
    OR?: StagingRawEventWhereInput[]
    NOT?: StagingRawEventWhereInput | StagingRawEventWhereInput[]
    id?: BigIntFilter<'StagingRawEvent'> | bigint | number
    eventType?: StringFilter<'StagingRawEvent'> | string
    source?: StringFilter<'StagingRawEvent'> | string
    payload?: JsonFilter<'StagingRawEvent'>
    headers?: JsonNullableFilter<'StagingRawEvent'>
    receivedAt?: DateTimeFilter<'StagingRawEvent'> | Date | string
    processedAt?:
      | DateTimeNullableFilter<'StagingRawEvent'>
      | Date
      | string
      | null
    status?: StringFilter<'StagingRawEvent'> | string
    error?: StringNullableFilter<'StagingRawEvent'> | string | null
    retryCount?: IntFilter<'StagingRawEvent'> | number
  }

  export type StagingRawEventOrderByWithRelationInput = {
    id?: SortOrder
    eventType?: SortOrder
    source?: SortOrder
    payload?: SortOrder
    headers?: SortOrderInput | SortOrder
    receivedAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    retryCount?: SortOrder
  }

  export type StagingRawEventWhereUniqueInput = Prisma.AtLeast<
    {
      id?: bigint | number
      AND?: StagingRawEventWhereInput | StagingRawEventWhereInput[]
      OR?: StagingRawEventWhereInput[]
      NOT?: StagingRawEventWhereInput | StagingRawEventWhereInput[]
      eventType?: StringFilter<'StagingRawEvent'> | string
      source?: StringFilter<'StagingRawEvent'> | string
      payload?: JsonFilter<'StagingRawEvent'>
      headers?: JsonNullableFilter<'StagingRawEvent'>
      receivedAt?: DateTimeFilter<'StagingRawEvent'> | Date | string
      processedAt?:
        | DateTimeNullableFilter<'StagingRawEvent'>
        | Date
        | string
        | null
      status?: StringFilter<'StagingRawEvent'> | string
      error?: StringNullableFilter<'StagingRawEvent'> | string | null
      retryCount?: IntFilter<'StagingRawEvent'> | number
    },
    'id'
  >

  export type StagingRawEventOrderByWithAggregationInput = {
    id?: SortOrder
    eventType?: SortOrder
    source?: SortOrder
    payload?: SortOrder
    headers?: SortOrderInput | SortOrder
    receivedAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    _count?: StagingRawEventCountOrderByAggregateInput
    _avg?: StagingRawEventAvgOrderByAggregateInput
    _max?: StagingRawEventMaxOrderByAggregateInput
    _min?: StagingRawEventMinOrderByAggregateInput
    _sum?: StagingRawEventSumOrderByAggregateInput
  }

  export type StagingRawEventScalarWhereWithAggregatesInput = {
    AND?:
      | StagingRawEventScalarWhereWithAggregatesInput
      | StagingRawEventScalarWhereWithAggregatesInput[]
    OR?: StagingRawEventScalarWhereWithAggregatesInput[]
    NOT?:
      | StagingRawEventScalarWhereWithAggregatesInput
      | StagingRawEventScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<'StagingRawEvent'> | bigint | number
    eventType?: StringWithAggregatesFilter<'StagingRawEvent'> | string
    source?: StringWithAggregatesFilter<'StagingRawEvent'> | string
    payload?: JsonWithAggregatesFilter<'StagingRawEvent'>
    headers?: JsonNullableWithAggregatesFilter<'StagingRawEvent'>
    receivedAt?: DateTimeWithAggregatesFilter<'StagingRawEvent'> | Date | string
    processedAt?:
      | DateTimeNullableWithAggregatesFilter<'StagingRawEvent'>
      | Date
      | string
      | null
    status?: StringWithAggregatesFilter<'StagingRawEvent'> | string
    error?:
      | StringNullableWithAggregatesFilter<'StagingRawEvent'>
      | string
      | null
    retryCount?: IntWithAggregatesFilter<'StagingRawEvent'> | number
  }

  export type AggDailyStatsWhereInput = {
    AND?: AggDailyStatsWhereInput | AggDailyStatsWhereInput[]
    OR?: AggDailyStatsWhereInput[]
    NOT?: AggDailyStatsWhereInput | AggDailyStatsWhereInput[]
    dateId?: IntFilter<'AggDailyStats'> | number
    totalRevenue?:
      | DecimalFilter<'AggDailyStats'>
      | Decimal
      | DecimalJsLike
      | number
      | string
    totalOrders?: IntFilter<'AggDailyStats'> | number
    totalVisits?: IntFilter<'AggDailyStats'> | number
    conversionRate?:
      | DecimalNullableFilter<'AggDailyStats'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    aov?:
      | DecimalNullableFilter<'AggDailyStats'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    updatedAt?: DateTimeFilter<'AggDailyStats'> | Date | string
  }

  export type AggDailyStatsOrderByWithRelationInput = {
    dateId?: SortOrder
    totalRevenue?: SortOrder
    totalOrders?: SortOrder
    totalVisits?: SortOrder
    conversionRate?: SortOrderInput | SortOrder
    aov?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
  }

  export type AggDailyStatsWhereUniqueInput = Prisma.AtLeast<
    {
      dateId?: number
      AND?: AggDailyStatsWhereInput | AggDailyStatsWhereInput[]
      OR?: AggDailyStatsWhereInput[]
      NOT?: AggDailyStatsWhereInput | AggDailyStatsWhereInput[]
      totalRevenue?:
        | DecimalFilter<'AggDailyStats'>
        | Decimal
        | DecimalJsLike
        | number
        | string
      totalOrders?: IntFilter<'AggDailyStats'> | number
      totalVisits?: IntFilter<'AggDailyStats'> | number
      conversionRate?:
        | DecimalNullableFilter<'AggDailyStats'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null
      aov?:
        | DecimalNullableFilter<'AggDailyStats'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null
      updatedAt?: DateTimeFilter<'AggDailyStats'> | Date | string
    },
    'dateId'
  >

  export type AggDailyStatsOrderByWithAggregationInput = {
    dateId?: SortOrder
    totalRevenue?: SortOrder
    totalOrders?: SortOrder
    totalVisits?: SortOrder
    conversionRate?: SortOrderInput | SortOrder
    aov?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: AggDailyStatsCountOrderByAggregateInput
    _avg?: AggDailyStatsAvgOrderByAggregateInput
    _max?: AggDailyStatsMaxOrderByAggregateInput
    _min?: AggDailyStatsMinOrderByAggregateInput
    _sum?: AggDailyStatsSumOrderByAggregateInput
  }

  export type AggDailyStatsScalarWhereWithAggregatesInput = {
    AND?:
      | AggDailyStatsScalarWhereWithAggregatesInput
      | AggDailyStatsScalarWhereWithAggregatesInput[]
    OR?: AggDailyStatsScalarWhereWithAggregatesInput[]
    NOT?:
      | AggDailyStatsScalarWhereWithAggregatesInput
      | AggDailyStatsScalarWhereWithAggregatesInput[]
    dateId?: IntWithAggregatesFilter<'AggDailyStats'> | number
    totalRevenue?:
      | DecimalWithAggregatesFilter<'AggDailyStats'>
      | Decimal
      | DecimalJsLike
      | number
      | string
    totalOrders?: IntWithAggregatesFilter<'AggDailyStats'> | number
    totalVisits?: IntWithAggregatesFilter<'AggDailyStats'> | number
    conversionRate?:
      | DecimalNullableWithAggregatesFilter<'AggDailyStats'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    aov?:
      | DecimalNullableWithAggregatesFilter<'AggDailyStats'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    updatedAt?: DateTimeWithAggregatesFilter<'AggDailyStats'> | Date | string
  }

  export type AggProductPerformanceWhereInput = {
    AND?: AggProductPerformanceWhereInput | AggProductPerformanceWhereInput[]
    OR?: AggProductPerformanceWhereInput[]
    NOT?: AggProductPerformanceWhereInput | AggProductPerformanceWhereInput[]
    dateId?: IntFilter<'AggProductPerformance'> | number
    productId?: BigIntFilter<'AggProductPerformance'> | bigint | number
    views?: IntFilter<'AggProductPerformance'> | number
    cartAdds?: IntFilter<'AggProductPerformance'> | number
    purchases?: IntFilter<'AggProductPerformance'> | number
    revenue?:
      | DecimalFilter<'AggProductPerformance'>
      | Decimal
      | DecimalJsLike
      | number
      | string
    returns?: IntFilter<'AggProductPerformance'> | number
  }

  export type AggProductPerformanceOrderByWithRelationInput = {
    dateId?: SortOrder
    productId?: SortOrder
    views?: SortOrder
    cartAdds?: SortOrder
    purchases?: SortOrder
    revenue?: SortOrder
    returns?: SortOrder
  }

  export type AggProductPerformanceWhereUniqueInput = Prisma.AtLeast<
    {
      dateId_productId?: AggProductPerformanceDateIdProductIdCompoundUniqueInput
      AND?: AggProductPerformanceWhereInput | AggProductPerformanceWhereInput[]
      OR?: AggProductPerformanceWhereInput[]
      NOT?: AggProductPerformanceWhereInput | AggProductPerformanceWhereInput[]
      dateId?: IntFilter<'AggProductPerformance'> | number
      productId?: BigIntFilter<'AggProductPerformance'> | bigint | number
      views?: IntFilter<'AggProductPerformance'> | number
      cartAdds?: IntFilter<'AggProductPerformance'> | number
      purchases?: IntFilter<'AggProductPerformance'> | number
      revenue?:
        | DecimalFilter<'AggProductPerformance'>
        | Decimal
        | DecimalJsLike
        | number
        | string
      returns?: IntFilter<'AggProductPerformance'> | number
    },
    'dateId_productId'
  >

  export type AggProductPerformanceOrderByWithAggregationInput = {
    dateId?: SortOrder
    productId?: SortOrder
    views?: SortOrder
    cartAdds?: SortOrder
    purchases?: SortOrder
    revenue?: SortOrder
    returns?: SortOrder
    _count?: AggProductPerformanceCountOrderByAggregateInput
    _avg?: AggProductPerformanceAvgOrderByAggregateInput
    _max?: AggProductPerformanceMaxOrderByAggregateInput
    _min?: AggProductPerformanceMinOrderByAggregateInput
    _sum?: AggProductPerformanceSumOrderByAggregateInput
  }

  export type AggProductPerformanceScalarWhereWithAggregatesInput = {
    AND?:
      | AggProductPerformanceScalarWhereWithAggregatesInput
      | AggProductPerformanceScalarWhereWithAggregatesInput[]
    OR?: AggProductPerformanceScalarWhereWithAggregatesInput[]
    NOT?:
      | AggProductPerformanceScalarWhereWithAggregatesInput
      | AggProductPerformanceScalarWhereWithAggregatesInput[]
    dateId?: IntWithAggregatesFilter<'AggProductPerformance'> | number
    productId?:
      | BigIntWithAggregatesFilter<'AggProductPerformance'>
      | bigint
      | number
    views?: IntWithAggregatesFilter<'AggProductPerformance'> | number
    cartAdds?: IntWithAggregatesFilter<'AggProductPerformance'> | number
    purchases?: IntWithAggregatesFilter<'AggProductPerformance'> | number
    revenue?:
      | DecimalWithAggregatesFilter<'AggProductPerformance'>
      | Decimal
      | DecimalJsLike
      | number
      | string
    returns?: IntWithAggregatesFilter<'AggProductPerformance'> | number
  }

  export type FactOrderCreateInput = {
    id?: bigint | number
    orderId: bigint | number
    userId?: bigint | number | null
    orderTs: Date | string
    dateId: number
    subtotal: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    shippingTotal: Decimal | DecimalJsLike | number | string
    discountTotal: Decimal | DecimalJsLike | number | string
    grandTotal: Decimal | DecimalJsLike | number | string
    marginTotal?: Decimal | DecimalJsLike | number | string | null
    itemCount: number
    status: string
    paymentStatus: string
    shippingStatus: string
    currency: string
    source?: string | null
    couponCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
  }

  export type FactOrderUncheckedCreateInput = {
    id?: bigint | number
    orderId: bigint | number
    userId?: bigint | number | null
    orderTs: Date | string
    dateId: number
    subtotal: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    shippingTotal: Decimal | DecimalJsLike | number | string
    discountTotal: Decimal | DecimalJsLike | number | string
    grandTotal: Decimal | DecimalJsLike | number | string
    marginTotal?: Decimal | DecimalJsLike | number | string | null
    itemCount: number
    status: string
    paymentStatus: string
    shippingStatus: string
    currency: string
    source?: string | null
    couponCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
  }

  export type FactOrderUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    orderId?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    orderTs?: DateTimeFieldUpdateOperationsInput | Date | string
    dateId?: IntFieldUpdateOperationsInput | number
    subtotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    taxTotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    shippingTotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    discountTotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    grandTotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    marginTotal?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    itemCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    shippingStatus?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null
    deliveredAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null
  }

  export type FactOrderUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    orderId?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    orderTs?: DateTimeFieldUpdateOperationsInput | Date | string
    dateId?: IntFieldUpdateOperationsInput | number
    subtotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    taxTotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    shippingTotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    discountTotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    grandTotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    marginTotal?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    itemCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    shippingStatus?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null
    deliveredAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null
  }

  export type FactOrderCreateManyInput = {
    id?: bigint | number
    orderId: bigint | number
    userId?: bigint | number | null
    orderTs: Date | string
    dateId: number
    subtotal: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    shippingTotal: Decimal | DecimalJsLike | number | string
    discountTotal: Decimal | DecimalJsLike | number | string
    grandTotal: Decimal | DecimalJsLike | number | string
    marginTotal?: Decimal | DecimalJsLike | number | string | null
    itemCount: number
    status: string
    paymentStatus: string
    shippingStatus: string
    currency: string
    source?: string | null
    couponCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
  }

  export type FactOrderUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    orderId?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    orderTs?: DateTimeFieldUpdateOperationsInput | Date | string
    dateId?: IntFieldUpdateOperationsInput | number
    subtotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    taxTotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    shippingTotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    discountTotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    grandTotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    marginTotal?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    itemCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    shippingStatus?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null
    deliveredAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null
  }

  export type FactOrderUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    orderId?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    orderTs?: DateTimeFieldUpdateOperationsInput | Date | string
    dateId?: IntFieldUpdateOperationsInput | number
    subtotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    taxTotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    shippingTotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    discountTotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    grandTotal?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    marginTotal?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    itemCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    shippingStatus?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null
    deliveredAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null
  }

  export type FactOrderItemCreateInput = {
    id?: bigint | number
    orderItemId: bigint | number
    orderId: bigint | number
    productId: bigint | number
    productScId?: bigint | number | null
    dateId: number
    orderTs: Date | string
    qty: number
    unitPrice: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string | null
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    extendedPrice: Decimal | DecimalJsLike | number | string
    margin?: Decimal | DecimalJsLike | number | string | null
    variantSku?: string | null
    productName: string
    categoryName?: string | null
    brandName?: string | null
    isReturned?: boolean
    createdAt?: Date | string
  }

  export type FactOrderItemUncheckedCreateInput = {
    id?: bigint | number
    orderItemId: bigint | number
    orderId: bigint | number
    productId: bigint | number
    productScId?: bigint | number | null
    dateId: number
    orderTs: Date | string
    qty: number
    unitPrice: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string | null
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    extendedPrice: Decimal | DecimalJsLike | number | string
    margin?: Decimal | DecimalJsLike | number | string | null
    variantSku?: string | null
    productName: string
    categoryName?: string | null
    brandName?: string | null
    isReturned?: boolean
    createdAt?: Date | string
  }

  export type FactOrderItemUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    orderItemId?: BigIntFieldUpdateOperationsInput | bigint | number
    orderId?: BigIntFieldUpdateOperationsInput | bigint | number
    productId?: BigIntFieldUpdateOperationsInput | bigint | number
    productScId?:
      | NullableBigIntFieldUpdateOperationsInput
      | bigint
      | number
      | null
    dateId?: IntFieldUpdateOperationsInput | number
    orderTs?: DateTimeFieldUpdateOperationsInput | Date | string
    qty?: IntFieldUpdateOperationsInput | number
    unitPrice?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    unitCost?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    taxAmount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    discountAmount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    extendedPrice?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    margin?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    variantSku?: NullableStringFieldUpdateOperationsInput | string | null
    productName?: StringFieldUpdateOperationsInput | string
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    isReturned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FactOrderItemUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    orderItemId?: BigIntFieldUpdateOperationsInput | bigint | number
    orderId?: BigIntFieldUpdateOperationsInput | bigint | number
    productId?: BigIntFieldUpdateOperationsInput | bigint | number
    productScId?:
      | NullableBigIntFieldUpdateOperationsInput
      | bigint
      | number
      | null
    dateId?: IntFieldUpdateOperationsInput | number
    orderTs?: DateTimeFieldUpdateOperationsInput | Date | string
    qty?: IntFieldUpdateOperationsInput | number
    unitPrice?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    unitCost?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    taxAmount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    discountAmount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    extendedPrice?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    margin?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    variantSku?: NullableStringFieldUpdateOperationsInput | string | null
    productName?: StringFieldUpdateOperationsInput | string
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    isReturned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FactOrderItemCreateManyInput = {
    id?: bigint | number
    orderItemId: bigint | number
    orderId: bigint | number
    productId: bigint | number
    productScId?: bigint | number | null
    dateId: number
    orderTs: Date | string
    qty: number
    unitPrice: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string | null
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    extendedPrice: Decimal | DecimalJsLike | number | string
    margin?: Decimal | DecimalJsLike | number | string | null
    variantSku?: string | null
    productName: string
    categoryName?: string | null
    brandName?: string | null
    isReturned?: boolean
    createdAt?: Date | string
  }

  export type FactOrderItemUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    orderItemId?: BigIntFieldUpdateOperationsInput | bigint | number
    orderId?: BigIntFieldUpdateOperationsInput | bigint | number
    productId?: BigIntFieldUpdateOperationsInput | bigint | number
    productScId?:
      | NullableBigIntFieldUpdateOperationsInput
      | bigint
      | number
      | null
    dateId?: IntFieldUpdateOperationsInput | number
    orderTs?: DateTimeFieldUpdateOperationsInput | Date | string
    qty?: IntFieldUpdateOperationsInput | number
    unitPrice?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    unitCost?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    taxAmount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    discountAmount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    extendedPrice?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    margin?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    variantSku?: NullableStringFieldUpdateOperationsInput | string | null
    productName?: StringFieldUpdateOperationsInput | string
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    isReturned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FactOrderItemUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    orderItemId?: BigIntFieldUpdateOperationsInput | bigint | number
    orderId?: BigIntFieldUpdateOperationsInput | bigint | number
    productId?: BigIntFieldUpdateOperationsInput | bigint | number
    productScId?:
      | NullableBigIntFieldUpdateOperationsInput
      | bigint
      | number
      | null
    dateId?: IntFieldUpdateOperationsInput | number
    orderTs?: DateTimeFieldUpdateOperationsInput | Date | string
    qty?: IntFieldUpdateOperationsInput | number
    unitPrice?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    unitCost?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    taxAmount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    discountAmount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    extendedPrice?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    margin?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    variantSku?: NullableStringFieldUpdateOperationsInput | string | null
    productName?: StringFieldUpdateOperationsInput | string
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    isReturned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FactPaymentCreateInput = {
    id?: bigint | number
    paymentId: bigint | number
    orderId?: bigint | number | null
    dateId: number
    timestamp: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    provider: string
    method?: string | null
    status: string
    errorCode?: string | null
    isSuccess: boolean
    createdAt?: Date | string
  }

  export type FactPaymentUncheckedCreateInput = {
    id?: bigint | number
    paymentId: bigint | number
    orderId?: bigint | number | null
    dateId: number
    timestamp: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    provider: string
    method?: string | null
    status: string
    errorCode?: string | null
    isSuccess: boolean
    createdAt?: Date | string
  }

  export type FactPaymentUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    paymentId?: BigIntFieldUpdateOperationsInput | bigint | number
    orderId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dateId?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    currency?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    isSuccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FactPaymentUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    paymentId?: BigIntFieldUpdateOperationsInput | bigint | number
    orderId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dateId?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    currency?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    isSuccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FactPaymentCreateManyInput = {
    id?: bigint | number
    paymentId: bigint | number
    orderId?: bigint | number | null
    dateId: number
    timestamp: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    provider: string
    method?: string | null
    status: string
    errorCode?: string | null
    isSuccess: boolean
    createdAt?: Date | string
  }

  export type FactPaymentUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    paymentId?: BigIntFieldUpdateOperationsInput | bigint | number
    orderId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dateId?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    currency?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    isSuccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FactPaymentUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    paymentId?: BigIntFieldUpdateOperationsInput | bigint | number
    orderId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dateId?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    currency?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    isSuccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FactShipmentCreateInput = {
    id?: bigint | number
    shipmentId: bigint | number
    orderId: bigint | number
    dateId: number
    weight?: number | null
    cost?: Decimal | DecimalJsLike | number | string | null
    carrier: string
    serviceLevel?: string | null
    shippedTs?: Date | string | null
    deliveredTs?: Date | string | null
    deliveryDays?: number | null
    isOnTime?: boolean | null
    createdAt?: Date | string
  }

  export type FactShipmentUncheckedCreateInput = {
    id?: bigint | number
    shipmentId: bigint | number
    orderId: bigint | number
    dateId: number
    weight?: number | null
    cost?: Decimal | DecimalJsLike | number | string | null
    carrier: string
    serviceLevel?: string | null
    shippedTs?: Date | string | null
    deliveredTs?: Date | string | null
    deliveryDays?: number | null
    isOnTime?: boolean | null
    createdAt?: Date | string
  }

  export type FactShipmentUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    shipmentId?: BigIntFieldUpdateOperationsInput | bigint | number
    orderId?: BigIntFieldUpdateOperationsInput | bigint | number
    dateId?: IntFieldUpdateOperationsInput | number
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    cost?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    carrier?: StringFieldUpdateOperationsInput | string
    serviceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    shippedTs?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null
    deliveredTs?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null
    deliveryDays?: NullableFloatFieldUpdateOperationsInput | number | null
    isOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FactShipmentUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    shipmentId?: BigIntFieldUpdateOperationsInput | bigint | number
    orderId?: BigIntFieldUpdateOperationsInput | bigint | number
    dateId?: IntFieldUpdateOperationsInput | number
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    cost?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    carrier?: StringFieldUpdateOperationsInput | string
    serviceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    shippedTs?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null
    deliveredTs?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null
    deliveryDays?: NullableFloatFieldUpdateOperationsInput | number | null
    isOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FactShipmentCreateManyInput = {
    id?: bigint | number
    shipmentId: bigint | number
    orderId: bigint | number
    dateId: number
    weight?: number | null
    cost?: Decimal | DecimalJsLike | number | string | null
    carrier: string
    serviceLevel?: string | null
    shippedTs?: Date | string | null
    deliveredTs?: Date | string | null
    deliveryDays?: number | null
    isOnTime?: boolean | null
    createdAt?: Date | string
  }

  export type FactShipmentUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    shipmentId?: BigIntFieldUpdateOperationsInput | bigint | number
    orderId?: BigIntFieldUpdateOperationsInput | bigint | number
    dateId?: IntFieldUpdateOperationsInput | number
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    cost?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    carrier?: StringFieldUpdateOperationsInput | string
    serviceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    shippedTs?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null
    deliveredTs?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null
    deliveryDays?: NullableFloatFieldUpdateOperationsInput | number | null
    isOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FactShipmentUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    shipmentId?: BigIntFieldUpdateOperationsInput | bigint | number
    orderId?: BigIntFieldUpdateOperationsInput | bigint | number
    dateId?: IntFieldUpdateOperationsInput | number
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    cost?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    carrier?: StringFieldUpdateOperationsInput | string
    serviceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    shippedTs?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null
    deliveredTs?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null
    deliveryDays?: NullableFloatFieldUpdateOperationsInput | number | null
    isOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FactSessionCreateInput = {
    id?: bigint | number
    sessionId: string
    userId?: bigint | number | null
    visitorId?: string | null
    dateId: number
    startTime: Date | string
    endTime?: Date | string | null
    durationSec?: number | null
    pageViews?: number
    eventsCount?: number
    cartAddCount?: number
    orderCount?: number
    bounce?: boolean
    source?: string | null
    medium?: string | null
    campaign?: string | null
    deviceType?: string | null
    browser?: string | null
    os?: string | null
    country?: string | null
    city?: string | null
  }

  export type FactSessionUncheckedCreateInput = {
    id?: bigint | number
    sessionId: string
    userId?: bigint | number | null
    visitorId?: string | null
    dateId: number
    startTime: Date | string
    endTime?: Date | string | null
    durationSec?: number | null
    pageViews?: number
    eventsCount?: number
    cartAddCount?: number
    orderCount?: number
    bounce?: boolean
    source?: string | null
    medium?: string | null
    campaign?: string | null
    deviceType?: string | null
    browser?: string | null
    os?: string | null
    country?: string | null
    city?: string | null
  }

  export type FactSessionUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    visitorId?: NullableStringFieldUpdateOperationsInput | string | null
    dateId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSec?: NullableIntFieldUpdateOperationsInput | number | null
    pageViews?: IntFieldUpdateOperationsInput | number
    eventsCount?: IntFieldUpdateOperationsInput | number
    cartAddCount?: IntFieldUpdateOperationsInput | number
    orderCount?: IntFieldUpdateOperationsInput | number
    bounce?: BoolFieldUpdateOperationsInput | boolean
    source?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FactSessionUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    visitorId?: NullableStringFieldUpdateOperationsInput | string | null
    dateId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSec?: NullableIntFieldUpdateOperationsInput | number | null
    pageViews?: IntFieldUpdateOperationsInput | number
    eventsCount?: IntFieldUpdateOperationsInput | number
    cartAddCount?: IntFieldUpdateOperationsInput | number
    orderCount?: IntFieldUpdateOperationsInput | number
    bounce?: BoolFieldUpdateOperationsInput | boolean
    source?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FactSessionCreateManyInput = {
    id?: bigint | number
    sessionId: string
    userId?: bigint | number | null
    visitorId?: string | null
    dateId: number
    startTime: Date | string
    endTime?: Date | string | null
    durationSec?: number | null
    pageViews?: number
    eventsCount?: number
    cartAddCount?: number
    orderCount?: number
    bounce?: boolean
    source?: string | null
    medium?: string | null
    campaign?: string | null
    deviceType?: string | null
    browser?: string | null
    os?: string | null
    country?: string | null
    city?: string | null
  }

  export type FactSessionUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    visitorId?: NullableStringFieldUpdateOperationsInput | string | null
    dateId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSec?: NullableIntFieldUpdateOperationsInput | number | null
    pageViews?: IntFieldUpdateOperationsInput | number
    eventsCount?: IntFieldUpdateOperationsInput | number
    cartAddCount?: IntFieldUpdateOperationsInput | number
    orderCount?: IntFieldUpdateOperationsInput | number
    bounce?: BoolFieldUpdateOperationsInput | boolean
    source?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FactSessionUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    visitorId?: NullableStringFieldUpdateOperationsInput | string | null
    dateId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationSec?: NullableIntFieldUpdateOperationsInput | number | null
    pageViews?: IntFieldUpdateOperationsInput | number
    eventsCount?: IntFieldUpdateOperationsInput | number
    cartAddCount?: IntFieldUpdateOperationsInput | number
    orderCount?: IntFieldUpdateOperationsInput | number
    bounce?: BoolFieldUpdateOperationsInput | boolean
    source?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FactPageviewCreateInput = {
    id?: bigint | number
    sessionId: string
    userId?: bigint | number | null
    url: string
    path: string
    referrer?: string | null
    timestamp: Date | string
    timeOnPageSec?: number | null
    scrollDepth?: number | null
    loadTimeMs?: number | null
    productId?: bigint | number | null
    categoryId?: number | null
  }

  export type FactPageviewUncheckedCreateInput = {
    id?: bigint | number
    sessionId: string
    userId?: bigint | number | null
    url: string
    path: string
    referrer?: string | null
    timestamp: Date | string
    timeOnPageSec?: number | null
    scrollDepth?: number | null
    loadTimeMs?: number | null
    productId?: bigint | number | null
    categoryId?: number | null
  }

  export type FactPageviewUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    url?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    timeOnPageSec?: NullableIntFieldUpdateOperationsInput | number | null
    scrollDepth?: NullableIntFieldUpdateOperationsInput | number | null
    loadTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    productId?:
      | NullableBigIntFieldUpdateOperationsInput
      | bigint
      | number
      | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FactPageviewUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    url?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    timeOnPageSec?: NullableIntFieldUpdateOperationsInput | number | null
    scrollDepth?: NullableIntFieldUpdateOperationsInput | number | null
    loadTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    productId?:
      | NullableBigIntFieldUpdateOperationsInput
      | bigint
      | number
      | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FactPageviewCreateManyInput = {
    id?: bigint | number
    sessionId: string
    userId?: bigint | number | null
    url: string
    path: string
    referrer?: string | null
    timestamp: Date | string
    timeOnPageSec?: number | null
    scrollDepth?: number | null
    loadTimeMs?: number | null
    productId?: bigint | number | null
    categoryId?: number | null
  }

  export type FactPageviewUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    url?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    timeOnPageSec?: NullableIntFieldUpdateOperationsInput | number | null
    scrollDepth?: NullableIntFieldUpdateOperationsInput | number | null
    loadTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    productId?:
      | NullableBigIntFieldUpdateOperationsInput
      | bigint
      | number
      | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FactPageviewUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    url?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    timeOnPageSec?: NullableIntFieldUpdateOperationsInput | number | null
    scrollDepth?: NullableIntFieldUpdateOperationsInput | number | null
    loadTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    productId?:
      | NullableBigIntFieldUpdateOperationsInput
      | bigint
      | number
      | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FactSearchCreateInput = {
    id?: bigint | number
    sessionId: string
    timestamp: Date | string
    query: string
    resultCount: number
    clickedResultPos?: number | null
    converted?: boolean
  }

  export type FactSearchUncheckedCreateInput = {
    id?: bigint | number
    sessionId: string
    timestamp: Date | string
    query: string
    resultCount: number
    clickedResultPos?: number | null
    converted?: boolean
  }

  export type FactSearchUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    sessionId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    query?: StringFieldUpdateOperationsInput | string
    resultCount?: IntFieldUpdateOperationsInput | number
    clickedResultPos?: NullableIntFieldUpdateOperationsInput | number | null
    converted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FactSearchUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    sessionId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    query?: StringFieldUpdateOperationsInput | string
    resultCount?: IntFieldUpdateOperationsInput | number
    clickedResultPos?: NullableIntFieldUpdateOperationsInput | number | null
    converted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FactSearchCreateManyInput = {
    id?: bigint | number
    sessionId: string
    timestamp: Date | string
    query: string
    resultCount: number
    clickedResultPos?: number | null
    converted?: boolean
  }

  export type FactSearchUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    sessionId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    query?: StringFieldUpdateOperationsInput | string
    resultCount?: IntFieldUpdateOperationsInput | number
    clickedResultPos?: NullableIntFieldUpdateOperationsInput | number | null
    converted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FactSearchUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    sessionId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    query?: StringFieldUpdateOperationsInput | string
    resultCount?: IntFieldUpdateOperationsInput | number
    clickedResultPos?: NullableIntFieldUpdateOperationsInput | number | null
    converted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FactCartActivityCreateInput = {
    id?: bigint | number
    sessionId: string
    userId?: bigint | number | null
    timestamp: Date | string
    action: string
    productId: bigint | number
    sku: string
    quantityDelta: number
    priceSnapshot: Decimal | DecimalJsLike | number | string
  }

  export type FactCartActivityUncheckedCreateInput = {
    id?: bigint | number
    sessionId: string
    userId?: bigint | number | null
    timestamp: Date | string
    action: string
    productId: bigint | number
    sku: string
    quantityDelta: number
    priceSnapshot: Decimal | DecimalJsLike | number | string
  }

  export type FactCartActivityUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    productId?: BigIntFieldUpdateOperationsInput | bigint | number
    sku?: StringFieldUpdateOperationsInput | string
    quantityDelta?: IntFieldUpdateOperationsInput | number
    priceSnapshot?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
  }

  export type FactCartActivityUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    productId?: BigIntFieldUpdateOperationsInput | bigint | number
    sku?: StringFieldUpdateOperationsInput | string
    quantityDelta?: IntFieldUpdateOperationsInput | number
    priceSnapshot?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
  }

  export type FactCartActivityCreateManyInput = {
    id?: bigint | number
    sessionId: string
    userId?: bigint | number | null
    timestamp: Date | string
    action: string
    productId: bigint | number
    sku: string
    quantityDelta: number
    priceSnapshot: Decimal | DecimalJsLike | number | string
  }

  export type FactCartActivityUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    productId?: BigIntFieldUpdateOperationsInput | bigint | number
    sku?: StringFieldUpdateOperationsInput | string
    quantityDelta?: IntFieldUpdateOperationsInput | number
    priceSnapshot?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
  }

  export type FactCartActivityUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    productId?: BigIntFieldUpdateOperationsInput | bigint | number
    sku?: StringFieldUpdateOperationsInput | string
    quantityDelta?: IntFieldUpdateOperationsInput | number
    priceSnapshot?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
  }

  export type FactReviewCreateInput = {
    id?: bigint | number
    reviewId: bigint | number
    productId: bigint | number
    userId?: bigint | number | null
    dateId: number
    timestamp: Date | string
    rating: number
    hasText: boolean
    hasImages: boolean
    textLength: number
    sentimentScore?: number | null
    verified: boolean
  }

  export type FactReviewUncheckedCreateInput = {
    id?: bigint | number
    reviewId: bigint | number
    productId: bigint | number
    userId?: bigint | number | null
    dateId: number
    timestamp: Date | string
    rating: number
    hasText: boolean
    hasImages: boolean
    textLength: number
    sentimentScore?: number | null
    verified: boolean
  }

  export type FactReviewUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    reviewId?: BigIntFieldUpdateOperationsInput | bigint | number
    productId?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dateId?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: IntFieldUpdateOperationsInput | number
    hasText?: BoolFieldUpdateOperationsInput | boolean
    hasImages?: BoolFieldUpdateOperationsInput | boolean
    textLength?: IntFieldUpdateOperationsInput | number
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FactReviewUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    reviewId?: BigIntFieldUpdateOperationsInput | bigint | number
    productId?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dateId?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: IntFieldUpdateOperationsInput | number
    hasText?: BoolFieldUpdateOperationsInput | boolean
    hasImages?: BoolFieldUpdateOperationsInput | boolean
    textLength?: IntFieldUpdateOperationsInput | number
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FactReviewCreateManyInput = {
    id?: bigint | number
    reviewId: bigint | number
    productId: bigint | number
    userId?: bigint | number | null
    dateId: number
    timestamp: Date | string
    rating: number
    hasText: boolean
    hasImages: boolean
    textLength: number
    sentimentScore?: number | null
    verified: boolean
  }

  export type FactReviewUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    reviewId?: BigIntFieldUpdateOperationsInput | bigint | number
    productId?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dateId?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: IntFieldUpdateOperationsInput | number
    hasText?: BoolFieldUpdateOperationsInput | boolean
    hasImages?: BoolFieldUpdateOperationsInput | boolean
    textLength?: IntFieldUpdateOperationsInput | number
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FactReviewUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    reviewId?: BigIntFieldUpdateOperationsInput | bigint | number
    productId?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    dateId?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: IntFieldUpdateOperationsInput | number
    hasText?: BoolFieldUpdateOperationsInput | boolean
    hasImages?: BoolFieldUpdateOperationsInput | boolean
    textLength?: IntFieldUpdateOperationsInput | number
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DimProductCreateInput = {
    productScId?: bigint | number
    productId: bigint | number
    sku: string
    name: string
    categoryId?: number | null
    brandId?: number | null
    currentPrice: Decimal | DecimalJsLike | number | string
    costPrice?: Decimal | DecimalJsLike | number | string | null
    isActive: boolean
    validFrom: Date | string
    validTo?: Date | string | null
    isCurrent?: boolean
    categoryName?: string | null
    brandName?: string | null
    supplier?: string | null
    tags?: DimProductCreatetagsInput | string[]
  }

  export type DimProductUncheckedCreateInput = {
    productScId?: bigint | number
    productId: bigint | number
    sku: string
    name: string
    categoryId?: number | null
    brandId?: number | null
    currentPrice: Decimal | DecimalJsLike | number | string
    costPrice?: Decimal | DecimalJsLike | number | string | null
    isActive: boolean
    validFrom: Date | string
    validTo?: Date | string | null
    isCurrent?: boolean
    categoryName?: string | null
    brandName?: string | null
    supplier?: string | null
    tags?: DimProductCreatetagsInput | string[]
  }

  export type DimProductUpdateInput = {
    productScId?: BigIntFieldUpdateOperationsInput | bigint | number
    productId?: BigIntFieldUpdateOperationsInput | bigint | number
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    costPrice?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DimProductUpdatetagsInput | string[]
  }

  export type DimProductUncheckedUpdateInput = {
    productScId?: BigIntFieldUpdateOperationsInput | bigint | number
    productId?: BigIntFieldUpdateOperationsInput | bigint | number
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    costPrice?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DimProductUpdatetagsInput | string[]
  }

  export type DimProductCreateManyInput = {
    productScId?: bigint | number
    productId: bigint | number
    sku: string
    name: string
    categoryId?: number | null
    brandId?: number | null
    currentPrice: Decimal | DecimalJsLike | number | string
    costPrice?: Decimal | DecimalJsLike | number | string | null
    isActive: boolean
    validFrom: Date | string
    validTo?: Date | string | null
    isCurrent?: boolean
    categoryName?: string | null
    brandName?: string | null
    supplier?: string | null
    tags?: DimProductCreatetagsInput | string[]
  }

  export type DimProductUpdateManyMutationInput = {
    productScId?: BigIntFieldUpdateOperationsInput | bigint | number
    productId?: BigIntFieldUpdateOperationsInput | bigint | number
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    costPrice?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DimProductUpdatetagsInput | string[]
  }

  export type DimProductUncheckedUpdateManyInput = {
    productScId?: BigIntFieldUpdateOperationsInput | bigint | number
    productId?: BigIntFieldUpdateOperationsInput | bigint | number
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    currentPrice?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    costPrice?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DimProductUpdatetagsInput | string[]
  }

  export type DimUserCreateInput = {
    userScId?: bigint | number
    userId: bigint | number
    email?: string | null
    city?: string | null
    country?: string | null
    gender?: string | null
    ageGroup?: string | null
    segment?: string | null
    ltv?: Decimal | DecimalJsLike | number | string | null
    firstOrderDate?: Date | string | null
    validFrom: Date | string
    validTo?: Date | string | null
    isCurrent?: boolean
  }

  export type DimUserUncheckedCreateInput = {
    userScId?: bigint | number
    userId: bigint | number
    email?: string | null
    city?: string | null
    country?: string | null
    gender?: string | null
    ageGroup?: string | null
    segment?: string | null
    ltv?: Decimal | DecimalJsLike | number | string | null
    firstOrderDate?: Date | string | null
    validFrom: Date | string
    validTo?: Date | string | null
    isCurrent?: boolean
  }

  export type DimUserUpdateInput = {
    userScId?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    ageGroup?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: NullableStringFieldUpdateOperationsInput | string | null
    ltv?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    firstOrderDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DimUserUncheckedUpdateInput = {
    userScId?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    ageGroup?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: NullableStringFieldUpdateOperationsInput | string | null
    ltv?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    firstOrderDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DimUserCreateManyInput = {
    userScId?: bigint | number
    userId: bigint | number
    email?: string | null
    city?: string | null
    country?: string | null
    gender?: string | null
    ageGroup?: string | null
    segment?: string | null
    ltv?: Decimal | DecimalJsLike | number | string | null
    firstOrderDate?: Date | string | null
    validFrom: Date | string
    validTo?: Date | string | null
    isCurrent?: boolean
  }

  export type DimUserUpdateManyMutationInput = {
    userScId?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    ageGroup?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: NullableStringFieldUpdateOperationsInput | string | null
    ltv?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    firstOrderDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DimUserUncheckedUpdateManyInput = {
    userScId?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    ageGroup?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: NullableStringFieldUpdateOperationsInput | string | null
    ltv?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    firstOrderDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DimDateCreateInput = {
    dateId: number
    date: Date | string
    dayOfWeek: number
    dayName: string
    dayOfMonth: number
    weekOfYear: number
    month: number
    monthName: string
    quarter: number
    year: number
    isWeekend: boolean
    isHoliday: boolean
    fiscalYear?: number | null
    fiscalPeriod?: number | null
  }

  export type DimDateUncheckedCreateInput = {
    dateId: number
    date: Date | string
    dayOfWeek: number
    dayName: string
    dayOfMonth: number
    weekOfYear: number
    month: number
    monthName: string
    quarter: number
    year: number
    isWeekend: boolean
    isHoliday: boolean
    fiscalYear?: number | null
    fiscalPeriod?: number | null
  }

  export type DimDateUpdateInput = {
    dateId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    dayName?: StringFieldUpdateOperationsInput | string
    dayOfMonth?: IntFieldUpdateOperationsInput | number
    weekOfYear?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    monthName?: StringFieldUpdateOperationsInput | string
    quarter?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isWeekend?: BoolFieldUpdateOperationsInput | boolean
    isHoliday?: BoolFieldUpdateOperationsInput | boolean
    fiscalYear?: NullableIntFieldUpdateOperationsInput | number | null
    fiscalPeriod?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DimDateUncheckedUpdateInput = {
    dateId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    dayName?: StringFieldUpdateOperationsInput | string
    dayOfMonth?: IntFieldUpdateOperationsInput | number
    weekOfYear?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    monthName?: StringFieldUpdateOperationsInput | string
    quarter?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isWeekend?: BoolFieldUpdateOperationsInput | boolean
    isHoliday?: BoolFieldUpdateOperationsInput | boolean
    fiscalYear?: NullableIntFieldUpdateOperationsInput | number | null
    fiscalPeriod?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DimDateCreateManyInput = {
    dateId: number
    date: Date | string
    dayOfWeek: number
    dayName: string
    dayOfMonth: number
    weekOfYear: number
    month: number
    monthName: string
    quarter: number
    year: number
    isWeekend: boolean
    isHoliday: boolean
    fiscalYear?: number | null
    fiscalPeriod?: number | null
  }

  export type DimDateUpdateManyMutationInput = {
    dateId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    dayName?: StringFieldUpdateOperationsInput | string
    dayOfMonth?: IntFieldUpdateOperationsInput | number
    weekOfYear?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    monthName?: StringFieldUpdateOperationsInput | string
    quarter?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isWeekend?: BoolFieldUpdateOperationsInput | boolean
    isHoliday?: BoolFieldUpdateOperationsInput | boolean
    fiscalYear?: NullableIntFieldUpdateOperationsInput | number | null
    fiscalPeriod?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DimDateUncheckedUpdateManyInput = {
    dateId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    dayName?: StringFieldUpdateOperationsInput | string
    dayOfMonth?: IntFieldUpdateOperationsInput | number
    weekOfYear?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    monthName?: StringFieldUpdateOperationsInput | string
    quarter?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    isWeekend?: BoolFieldUpdateOperationsInput | boolean
    isHoliday?: BoolFieldUpdateOperationsInput | boolean
    fiscalYear?: NullableIntFieldUpdateOperationsInput | number | null
    fiscalPeriod?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DimMarketingCreateInput = {
    id?: bigint | number
    utmSource?: string | null
    utmMedium?: string | null
    utmCampaign?: string | null
    utmTerm?: string | null
    utmContent?: string | null
    channelGroup?: string | null
    createdAt?: Date | string
  }

  export type DimMarketingUncheckedCreateInput = {
    id?: bigint | number
    utmSource?: string | null
    utmMedium?: string | null
    utmCampaign?: string | null
    utmTerm?: string | null
    utmContent?: string | null
    channelGroup?: string | null
    createdAt?: Date | string
  }

  export type DimMarketingUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    utmSource?: NullableStringFieldUpdateOperationsInput | string | null
    utmMedium?: NullableStringFieldUpdateOperationsInput | string | null
    utmCampaign?: NullableStringFieldUpdateOperationsInput | string | null
    utmTerm?: NullableStringFieldUpdateOperationsInput | string | null
    utmContent?: NullableStringFieldUpdateOperationsInput | string | null
    channelGroup?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DimMarketingUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    utmSource?: NullableStringFieldUpdateOperationsInput | string | null
    utmMedium?: NullableStringFieldUpdateOperationsInput | string | null
    utmCampaign?: NullableStringFieldUpdateOperationsInput | string | null
    utmTerm?: NullableStringFieldUpdateOperationsInput | string | null
    utmContent?: NullableStringFieldUpdateOperationsInput | string | null
    channelGroup?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DimMarketingCreateManyInput = {
    id?: bigint | number
    utmSource?: string | null
    utmMedium?: string | null
    utmCampaign?: string | null
    utmTerm?: string | null
    utmContent?: string | null
    channelGroup?: string | null
    createdAt?: Date | string
  }

  export type DimMarketingUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    utmSource?: NullableStringFieldUpdateOperationsInput | string | null
    utmMedium?: NullableStringFieldUpdateOperationsInput | string | null
    utmCampaign?: NullableStringFieldUpdateOperationsInput | string | null
    utmTerm?: NullableStringFieldUpdateOperationsInput | string | null
    utmContent?: NullableStringFieldUpdateOperationsInput | string | null
    channelGroup?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DimMarketingUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    utmSource?: NullableStringFieldUpdateOperationsInput | string | null
    utmMedium?: NullableStringFieldUpdateOperationsInput | string | null
    utmCampaign?: NullableStringFieldUpdateOperationsInput | string | null
    utmTerm?: NullableStringFieldUpdateOperationsInput | string | null
    utmContent?: NullableStringFieldUpdateOperationsInput | string | null
    channelGroup?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DimLocationCreateInput = {
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country: string
    countryCode: string
    region?: string | null
  }

  export type DimLocationUncheckedCreateInput = {
    id?: number
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country: string
    countryCode: string
    region?: string | null
  }

  export type DimLocationUpdateInput = {
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DimLocationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DimLocationCreateManyInput = {
    id?: number
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country: string
    countryCode: string
    region?: string | null
  }

  export type DimLocationUpdateManyMutationInput = {
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DimLocationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IngestOffsetCreateInput = {
    id?: bigint | number
    source: string
    partition?: number
    lastOffset?: bigint | number | null
    lastTimestamp?: Date | string | null
    payloadHash?: string | null
    updatedAt?: Date | string
  }

  export type IngestOffsetUncheckedCreateInput = {
    id?: bigint | number
    source: string
    partition?: number
    lastOffset?: bigint | number | null
    lastTimestamp?: Date | string | null
    payloadHash?: string | null
    updatedAt?: Date | string
  }

  export type IngestOffsetUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: StringFieldUpdateOperationsInput | string
    partition?: IntFieldUpdateOperationsInput | number
    lastOffset?:
      | NullableBigIntFieldUpdateOperationsInput
      | bigint
      | number
      | null
    lastTimestamp?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null
    payloadHash?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngestOffsetUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: StringFieldUpdateOperationsInput | string
    partition?: IntFieldUpdateOperationsInput | number
    lastOffset?:
      | NullableBigIntFieldUpdateOperationsInput
      | bigint
      | number
      | null
    lastTimestamp?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null
    payloadHash?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngestOffsetCreateManyInput = {
    id?: bigint | number
    source: string
    partition?: number
    lastOffset?: bigint | number | null
    lastTimestamp?: Date | string | null
    payloadHash?: string | null
    updatedAt?: Date | string
  }

  export type IngestOffsetUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: StringFieldUpdateOperationsInput | string
    partition?: IntFieldUpdateOperationsInput | number
    lastOffset?:
      | NullableBigIntFieldUpdateOperationsInput
      | bigint
      | number
      | null
    lastTimestamp?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null
    payloadHash?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngestOffsetUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: StringFieldUpdateOperationsInput | string
    partition?: IntFieldUpdateOperationsInput | number
    lastOffset?:
      | NullableBigIntFieldUpdateOperationsInput
      | bigint
      | number
      | null
    lastTimestamp?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null
    payloadHash?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StagingRawEventCreateInput = {
    id?: bigint | number
    eventType: string
    source: string
    payload: JsonNullValueInput | InputJsonValue
    headers?: NullableJsonNullValueInput | InputJsonValue
    receivedAt?: Date | string
    processedAt?: Date | string | null
    status?: string
    error?: string | null
    retryCount?: number
  }

  export type StagingRawEventUncheckedCreateInput = {
    id?: bigint | number
    eventType: string
    source: string
    payload: JsonNullValueInput | InputJsonValue
    headers?: NullableJsonNullValueInput | InputJsonValue
    receivedAt?: Date | string
    processedAt?: Date | string | null
    status?: string
    error?: string | null
    retryCount?: number
  }

  export type StagingRawEventUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    eventType?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    headers?: NullableJsonNullValueInput | InputJsonValue
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
  }

  export type StagingRawEventUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    eventType?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    headers?: NullableJsonNullValueInput | InputJsonValue
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
  }

  export type StagingRawEventCreateManyInput = {
    id?: bigint | number
    eventType: string
    source: string
    payload: JsonNullValueInput | InputJsonValue
    headers?: NullableJsonNullValueInput | InputJsonValue
    receivedAt?: Date | string
    processedAt?: Date | string | null
    status?: string
    error?: string | null
    retryCount?: number
  }

  export type StagingRawEventUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    eventType?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    headers?: NullableJsonNullValueInput | InputJsonValue
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
  }

  export type StagingRawEventUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    eventType?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    headers?: NullableJsonNullValueInput | InputJsonValue
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
  }

  export type AggDailyStatsCreateInput = {
    dateId: number
    totalRevenue: Decimal | DecimalJsLike | number | string
    totalOrders: number
    totalVisits: number
    conversionRate?: Decimal | DecimalJsLike | number | string | null
    aov?: Decimal | DecimalJsLike | number | string | null
    updatedAt?: Date | string
  }

  export type AggDailyStatsUncheckedCreateInput = {
    dateId: number
    totalRevenue: Decimal | DecimalJsLike | number | string
    totalOrders: number
    totalVisits: number
    conversionRate?: Decimal | DecimalJsLike | number | string | null
    aov?: Decimal | DecimalJsLike | number | string | null
    updatedAt?: Date | string
  }

  export type AggDailyStatsUpdateInput = {
    dateId?: IntFieldUpdateOperationsInput | number
    totalRevenue?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    totalOrders?: IntFieldUpdateOperationsInput | number
    totalVisits?: IntFieldUpdateOperationsInput | number
    conversionRate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    aov?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AggDailyStatsUncheckedUpdateInput = {
    dateId?: IntFieldUpdateOperationsInput | number
    totalRevenue?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    totalOrders?: IntFieldUpdateOperationsInput | number
    totalVisits?: IntFieldUpdateOperationsInput | number
    conversionRate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    aov?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AggDailyStatsCreateManyInput = {
    dateId: number
    totalRevenue: Decimal | DecimalJsLike | number | string
    totalOrders: number
    totalVisits: number
    conversionRate?: Decimal | DecimalJsLike | number | string | null
    aov?: Decimal | DecimalJsLike | number | string | null
    updatedAt?: Date | string
  }

  export type AggDailyStatsUpdateManyMutationInput = {
    dateId?: IntFieldUpdateOperationsInput | number
    totalRevenue?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    totalOrders?: IntFieldUpdateOperationsInput | number
    totalVisits?: IntFieldUpdateOperationsInput | number
    conversionRate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    aov?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AggDailyStatsUncheckedUpdateManyInput = {
    dateId?: IntFieldUpdateOperationsInput | number
    totalRevenue?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    totalOrders?: IntFieldUpdateOperationsInput | number
    totalVisits?: IntFieldUpdateOperationsInput | number
    conversionRate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    aov?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AggProductPerformanceCreateInput = {
    dateId: number
    productId: bigint | number
    views?: number
    cartAdds?: number
    purchases?: number
    revenue?: Decimal | DecimalJsLike | number | string
    returns?: number
  }

  export type AggProductPerformanceUncheckedCreateInput = {
    dateId: number
    productId: bigint | number
    views?: number
    cartAdds?: number
    purchases?: number
    revenue?: Decimal | DecimalJsLike | number | string
    returns?: number
  }

  export type AggProductPerformanceUpdateInput = {
    dateId?: IntFieldUpdateOperationsInput | number
    productId?: BigIntFieldUpdateOperationsInput | bigint | number
    views?: IntFieldUpdateOperationsInput | number
    cartAdds?: IntFieldUpdateOperationsInput | number
    purchases?: IntFieldUpdateOperationsInput | number
    revenue?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    returns?: IntFieldUpdateOperationsInput | number
  }

  export type AggProductPerformanceUncheckedUpdateInput = {
    dateId?: IntFieldUpdateOperationsInput | number
    productId?: BigIntFieldUpdateOperationsInput | bigint | number
    views?: IntFieldUpdateOperationsInput | number
    cartAdds?: IntFieldUpdateOperationsInput | number
    purchases?: IntFieldUpdateOperationsInput | number
    revenue?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    returns?: IntFieldUpdateOperationsInput | number
  }

  export type AggProductPerformanceCreateManyInput = {
    dateId: number
    productId: bigint | number
    views?: number
    cartAdds?: number
    purchases?: number
    revenue?: Decimal | DecimalJsLike | number | string
    returns?: number
  }

  export type AggProductPerformanceUpdateManyMutationInput = {
    dateId?: IntFieldUpdateOperationsInput | number
    productId?: BigIntFieldUpdateOperationsInput | bigint | number
    views?: IntFieldUpdateOperationsInput | number
    cartAdds?: IntFieldUpdateOperationsInput | number
    purchases?: IntFieldUpdateOperationsInput | number
    revenue?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    returns?: IntFieldUpdateOperationsInput | number
  }

  export type AggProductPerformanceUncheckedUpdateManyInput = {
    dateId?: IntFieldUpdateOperationsInput | number
    productId?: BigIntFieldUpdateOperationsInput | bigint | number
    views?: IntFieldUpdateOperationsInput | number
    cartAdds?: IntFieldUpdateOperationsInput | number
    purchases?: IntFieldUpdateOperationsInput | number
    revenue?:
      | DecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
    returns?: IntFieldUpdateOperationsInput | number
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
    not?:
      | NestedDecimalFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
      | null
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
      | null
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
      | null
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
    not?:
      | NestedDecimalNullableFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type FactOrderCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
    orderTs?: SortOrder
    dateId?: SortOrder
    subtotal?: SortOrder
    taxTotal?: SortOrder
    shippingTotal?: SortOrder
    discountTotal?: SortOrder
    grandTotal?: SortOrder
    marginTotal?: SortOrder
    itemCount?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    shippingStatus?: SortOrder
    currency?: SortOrder
    source?: SortOrder
    couponCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shippedAt?: SortOrder
    deliveredAt?: SortOrder
  }

  export type FactOrderAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
    dateId?: SortOrder
    subtotal?: SortOrder
    taxTotal?: SortOrder
    shippingTotal?: SortOrder
    discountTotal?: SortOrder
    grandTotal?: SortOrder
    marginTotal?: SortOrder
    itemCount?: SortOrder
  }

  export type FactOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
    orderTs?: SortOrder
    dateId?: SortOrder
    subtotal?: SortOrder
    taxTotal?: SortOrder
    shippingTotal?: SortOrder
    discountTotal?: SortOrder
    grandTotal?: SortOrder
    marginTotal?: SortOrder
    itemCount?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    shippingStatus?: SortOrder
    currency?: SortOrder
    source?: SortOrder
    couponCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shippedAt?: SortOrder
    deliveredAt?: SortOrder
  }

  export type FactOrderMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
    orderTs?: SortOrder
    dateId?: SortOrder
    subtotal?: SortOrder
    taxTotal?: SortOrder
    shippingTotal?: SortOrder
    discountTotal?: SortOrder
    grandTotal?: SortOrder
    marginTotal?: SortOrder
    itemCount?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    shippingStatus?: SortOrder
    currency?: SortOrder
    source?: SortOrder
    couponCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shippedAt?: SortOrder
    deliveredAt?: SortOrder
  }

  export type FactOrderSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    userId?: SortOrder
    dateId?: SortOrder
    subtotal?: SortOrder
    taxTotal?: SortOrder
    shippingTotal?: SortOrder
    discountTotal?: SortOrder
    grandTotal?: SortOrder
    marginTotal?: SortOrder
    itemCount?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?:
      | NestedBigIntNullableWithAggregatesFilter<$PrismaModel>
      | bigint
      | number
      | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
    not?:
      | NestedDecimalWithAggregatesFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
      | null
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
      | null
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
      | null
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
    not?:
      | NestedDecimalNullableWithAggregatesFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?:
      | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
      | Date
      | string
      | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type FactOrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    productScId?: SortOrder
    dateId?: SortOrder
    orderTs?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    unitCost?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    extendedPrice?: SortOrder
    margin?: SortOrder
    variantSku?: SortOrder
    productName?: SortOrder
    categoryName?: SortOrder
    brandName?: SortOrder
    isReturned?: SortOrder
    createdAt?: SortOrder
  }

  export type FactOrderItemAvgOrderByAggregateInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    productScId?: SortOrder
    dateId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    unitCost?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    extendedPrice?: SortOrder
    margin?: SortOrder
  }

  export type FactOrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    productScId?: SortOrder
    dateId?: SortOrder
    orderTs?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    unitCost?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    extendedPrice?: SortOrder
    margin?: SortOrder
    variantSku?: SortOrder
    productName?: SortOrder
    categoryName?: SortOrder
    brandName?: SortOrder
    isReturned?: SortOrder
    createdAt?: SortOrder
  }

  export type FactOrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    productScId?: SortOrder
    dateId?: SortOrder
    orderTs?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    unitCost?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    extendedPrice?: SortOrder
    margin?: SortOrder
    variantSku?: SortOrder
    productName?: SortOrder
    categoryName?: SortOrder
    brandName?: SortOrder
    isReturned?: SortOrder
    createdAt?: SortOrder
  }

  export type FactOrderItemSumOrderByAggregateInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    productScId?: SortOrder
    dateId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    unitCost?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    extendedPrice?: SortOrder
    margin?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FactPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    orderId?: SortOrder
    dateId?: SortOrder
    timestamp?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    provider?: SortOrder
    method?: SortOrder
    status?: SortOrder
    errorCode?: SortOrder
    isSuccess?: SortOrder
    createdAt?: SortOrder
  }

  export type FactPaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    orderId?: SortOrder
    dateId?: SortOrder
    amount?: SortOrder
  }

  export type FactPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    orderId?: SortOrder
    dateId?: SortOrder
    timestamp?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    provider?: SortOrder
    method?: SortOrder
    status?: SortOrder
    errorCode?: SortOrder
    isSuccess?: SortOrder
    createdAt?: SortOrder
  }

  export type FactPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    orderId?: SortOrder
    dateId?: SortOrder
    timestamp?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    provider?: SortOrder
    method?: SortOrder
    status?: SortOrder
    errorCode?: SortOrder
    isSuccess?: SortOrder
    createdAt?: SortOrder
  }

  export type FactPaymentSumOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    orderId?: SortOrder
    dateId?: SortOrder
    amount?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type FactShipmentCountOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    orderId?: SortOrder
    dateId?: SortOrder
    weight?: SortOrder
    cost?: SortOrder
    carrier?: SortOrder
    serviceLevel?: SortOrder
    shippedTs?: SortOrder
    deliveredTs?: SortOrder
    deliveryDays?: SortOrder
    isOnTime?: SortOrder
    createdAt?: SortOrder
  }

  export type FactShipmentAvgOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    orderId?: SortOrder
    dateId?: SortOrder
    weight?: SortOrder
    cost?: SortOrder
    deliveryDays?: SortOrder
  }

  export type FactShipmentMaxOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    orderId?: SortOrder
    dateId?: SortOrder
    weight?: SortOrder
    cost?: SortOrder
    carrier?: SortOrder
    serviceLevel?: SortOrder
    shippedTs?: SortOrder
    deliveredTs?: SortOrder
    deliveryDays?: SortOrder
    isOnTime?: SortOrder
    createdAt?: SortOrder
  }

  export type FactShipmentMinOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    orderId?: SortOrder
    dateId?: SortOrder
    weight?: SortOrder
    cost?: SortOrder
    carrier?: SortOrder
    serviceLevel?: SortOrder
    shippedTs?: SortOrder
    deliveredTs?: SortOrder
    deliveryDays?: SortOrder
    isOnTime?: SortOrder
    createdAt?: SortOrder
  }

  export type FactShipmentSumOrderByAggregateInput = {
    id?: SortOrder
    shipmentId?: SortOrder
    orderId?: SortOrder
    dateId?: SortOrder
    weight?: SortOrder
    cost?: SortOrder
    deliveryDays?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FactSessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    visitorId?: SortOrder
    dateId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    durationSec?: SortOrder
    pageViews?: SortOrder
    eventsCount?: SortOrder
    cartAddCount?: SortOrder
    orderCount?: SortOrder
    bounce?: SortOrder
    source?: SortOrder
    medium?: SortOrder
    campaign?: SortOrder
    deviceType?: SortOrder
    browser?: SortOrder
    os?: SortOrder
    country?: SortOrder
    city?: SortOrder
  }

  export type FactSessionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dateId?: SortOrder
    durationSec?: SortOrder
    pageViews?: SortOrder
    eventsCount?: SortOrder
    cartAddCount?: SortOrder
    orderCount?: SortOrder
  }

  export type FactSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    visitorId?: SortOrder
    dateId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    durationSec?: SortOrder
    pageViews?: SortOrder
    eventsCount?: SortOrder
    cartAddCount?: SortOrder
    orderCount?: SortOrder
    bounce?: SortOrder
    source?: SortOrder
    medium?: SortOrder
    campaign?: SortOrder
    deviceType?: SortOrder
    browser?: SortOrder
    os?: SortOrder
    country?: SortOrder
    city?: SortOrder
  }

  export type FactSessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    visitorId?: SortOrder
    dateId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    durationSec?: SortOrder
    pageViews?: SortOrder
    eventsCount?: SortOrder
    cartAddCount?: SortOrder
    orderCount?: SortOrder
    bounce?: SortOrder
    source?: SortOrder
    medium?: SortOrder
    campaign?: SortOrder
    deviceType?: SortOrder
    browser?: SortOrder
    os?: SortOrder
    country?: SortOrder
    city?: SortOrder
  }

  export type FactSessionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dateId?: SortOrder
    durationSec?: SortOrder
    pageViews?: SortOrder
    eventsCount?: SortOrder
    cartAddCount?: SortOrder
    orderCount?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FactPageviewCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    url?: SortOrder
    path?: SortOrder
    referrer?: SortOrder
    timestamp?: SortOrder
    timeOnPageSec?: SortOrder
    scrollDepth?: SortOrder
    loadTimeMs?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrder
  }

  export type FactPageviewAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    timeOnPageSec?: SortOrder
    scrollDepth?: SortOrder
    loadTimeMs?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrder
  }

  export type FactPageviewMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    url?: SortOrder
    path?: SortOrder
    referrer?: SortOrder
    timestamp?: SortOrder
    timeOnPageSec?: SortOrder
    scrollDepth?: SortOrder
    loadTimeMs?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrder
  }

  export type FactPageviewMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    url?: SortOrder
    path?: SortOrder
    referrer?: SortOrder
    timestamp?: SortOrder
    timeOnPageSec?: SortOrder
    scrollDepth?: SortOrder
    loadTimeMs?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrder
  }

  export type FactPageviewSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    timeOnPageSec?: SortOrder
    scrollDepth?: SortOrder
    loadTimeMs?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrder
  }

  export type FactSearchCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    timestamp?: SortOrder
    query?: SortOrder
    resultCount?: SortOrder
    clickedResultPos?: SortOrder
    converted?: SortOrder
  }

  export type FactSearchAvgOrderByAggregateInput = {
    id?: SortOrder
    resultCount?: SortOrder
    clickedResultPos?: SortOrder
  }

  export type FactSearchMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    timestamp?: SortOrder
    query?: SortOrder
    resultCount?: SortOrder
    clickedResultPos?: SortOrder
    converted?: SortOrder
  }

  export type FactSearchMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    timestamp?: SortOrder
    query?: SortOrder
    resultCount?: SortOrder
    clickedResultPos?: SortOrder
    converted?: SortOrder
  }

  export type FactSearchSumOrderByAggregateInput = {
    id?: SortOrder
    resultCount?: SortOrder
    clickedResultPos?: SortOrder
  }

  export type FactCartActivityCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    action?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    quantityDelta?: SortOrder
    priceSnapshot?: SortOrder
  }

  export type FactCartActivityAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    quantityDelta?: SortOrder
    priceSnapshot?: SortOrder
  }

  export type FactCartActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    action?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    quantityDelta?: SortOrder
    priceSnapshot?: SortOrder
  }

  export type FactCartActivityMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    action?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    quantityDelta?: SortOrder
    priceSnapshot?: SortOrder
  }

  export type FactCartActivitySumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    quantityDelta?: SortOrder
    priceSnapshot?: SortOrder
  }

  export type FactReviewCountOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    dateId?: SortOrder
    timestamp?: SortOrder
    rating?: SortOrder
    hasText?: SortOrder
    hasImages?: SortOrder
    textLength?: SortOrder
    sentimentScore?: SortOrder
    verified?: SortOrder
  }

  export type FactReviewAvgOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    dateId?: SortOrder
    rating?: SortOrder
    textLength?: SortOrder
    sentimentScore?: SortOrder
  }

  export type FactReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    dateId?: SortOrder
    timestamp?: SortOrder
    rating?: SortOrder
    hasText?: SortOrder
    hasImages?: SortOrder
    textLength?: SortOrder
    sentimentScore?: SortOrder
    verified?: SortOrder
  }

  export type FactReviewMinOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    dateId?: SortOrder
    timestamp?: SortOrder
    rating?: SortOrder
    hasText?: SortOrder
    hasImages?: SortOrder
    textLength?: SortOrder
    sentimentScore?: SortOrder
    verified?: SortOrder
  }

  export type FactReviewSumOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    dateId?: SortOrder
    rating?: SortOrder
    textLength?: SortOrder
    sentimentScore?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DimProductCountOrderByAggregateInput = {
    productScId?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    brandId?: SortOrder
    currentPrice?: SortOrder
    costPrice?: SortOrder
    isActive?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    isCurrent?: SortOrder
    categoryName?: SortOrder
    brandName?: SortOrder
    supplier?: SortOrder
    tags?: SortOrder
  }

  export type DimProductAvgOrderByAggregateInput = {
    productScId?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrder
    brandId?: SortOrder
    currentPrice?: SortOrder
    costPrice?: SortOrder
  }

  export type DimProductMaxOrderByAggregateInput = {
    productScId?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    brandId?: SortOrder
    currentPrice?: SortOrder
    costPrice?: SortOrder
    isActive?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    isCurrent?: SortOrder
    categoryName?: SortOrder
    brandName?: SortOrder
    supplier?: SortOrder
  }

  export type DimProductMinOrderByAggregateInput = {
    productScId?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    brandId?: SortOrder
    currentPrice?: SortOrder
    costPrice?: SortOrder
    isActive?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    isCurrent?: SortOrder
    categoryName?: SortOrder
    brandName?: SortOrder
    supplier?: SortOrder
  }

  export type DimProductSumOrderByAggregateInput = {
    productScId?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrder
    brandId?: SortOrder
    currentPrice?: SortOrder
    costPrice?: SortOrder
  }

  export type DimUserCountOrderByAggregateInput = {
    userScId?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    city?: SortOrder
    country?: SortOrder
    gender?: SortOrder
    ageGroup?: SortOrder
    segment?: SortOrder
    ltv?: SortOrder
    firstOrderDate?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    isCurrent?: SortOrder
  }

  export type DimUserAvgOrderByAggregateInput = {
    userScId?: SortOrder
    userId?: SortOrder
    ltv?: SortOrder
  }

  export type DimUserMaxOrderByAggregateInput = {
    userScId?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    city?: SortOrder
    country?: SortOrder
    gender?: SortOrder
    ageGroup?: SortOrder
    segment?: SortOrder
    ltv?: SortOrder
    firstOrderDate?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    isCurrent?: SortOrder
  }

  export type DimUserMinOrderByAggregateInput = {
    userScId?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    city?: SortOrder
    country?: SortOrder
    gender?: SortOrder
    ageGroup?: SortOrder
    segment?: SortOrder
    ltv?: SortOrder
    firstOrderDate?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    isCurrent?: SortOrder
  }

  export type DimUserSumOrderByAggregateInput = {
    userScId?: SortOrder
    userId?: SortOrder
    ltv?: SortOrder
  }

  export type DimDateCountOrderByAggregateInput = {
    dateId?: SortOrder
    date?: SortOrder
    dayOfWeek?: SortOrder
    dayName?: SortOrder
    dayOfMonth?: SortOrder
    weekOfYear?: SortOrder
    month?: SortOrder
    monthName?: SortOrder
    quarter?: SortOrder
    year?: SortOrder
    isWeekend?: SortOrder
    isHoliday?: SortOrder
    fiscalYear?: SortOrder
    fiscalPeriod?: SortOrder
  }

  export type DimDateAvgOrderByAggregateInput = {
    dateId?: SortOrder
    dayOfWeek?: SortOrder
    dayOfMonth?: SortOrder
    weekOfYear?: SortOrder
    month?: SortOrder
    quarter?: SortOrder
    year?: SortOrder
    fiscalYear?: SortOrder
    fiscalPeriod?: SortOrder
  }

  export type DimDateMaxOrderByAggregateInput = {
    dateId?: SortOrder
    date?: SortOrder
    dayOfWeek?: SortOrder
    dayName?: SortOrder
    dayOfMonth?: SortOrder
    weekOfYear?: SortOrder
    month?: SortOrder
    monthName?: SortOrder
    quarter?: SortOrder
    year?: SortOrder
    isWeekend?: SortOrder
    isHoliday?: SortOrder
    fiscalYear?: SortOrder
    fiscalPeriod?: SortOrder
  }

  export type DimDateMinOrderByAggregateInput = {
    dateId?: SortOrder
    date?: SortOrder
    dayOfWeek?: SortOrder
    dayName?: SortOrder
    dayOfMonth?: SortOrder
    weekOfYear?: SortOrder
    month?: SortOrder
    monthName?: SortOrder
    quarter?: SortOrder
    year?: SortOrder
    isWeekend?: SortOrder
    isHoliday?: SortOrder
    fiscalYear?: SortOrder
    fiscalPeriod?: SortOrder
  }

  export type DimDateSumOrderByAggregateInput = {
    dateId?: SortOrder
    dayOfWeek?: SortOrder
    dayOfMonth?: SortOrder
    weekOfYear?: SortOrder
    month?: SortOrder
    quarter?: SortOrder
    year?: SortOrder
    fiscalYear?: SortOrder
    fiscalPeriod?: SortOrder
  }

  export type DimMarketingUtmSourceUtmMediumUtmCampaignUtmTermUtmContentCompoundUniqueInput =
    {
      utmSource: string
      utmMedium: string
      utmCampaign: string
      utmTerm: string
      utmContent: string
    }

  export type DimMarketingCountOrderByAggregateInput = {
    id?: SortOrder
    utmSource?: SortOrder
    utmMedium?: SortOrder
    utmCampaign?: SortOrder
    utmTerm?: SortOrder
    utmContent?: SortOrder
    channelGroup?: SortOrder
    createdAt?: SortOrder
  }

  export type DimMarketingAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DimMarketingMaxOrderByAggregateInput = {
    id?: SortOrder
    utmSource?: SortOrder
    utmMedium?: SortOrder
    utmCampaign?: SortOrder
    utmTerm?: SortOrder
    utmContent?: SortOrder
    channelGroup?: SortOrder
    createdAt?: SortOrder
  }

  export type DimMarketingMinOrderByAggregateInput = {
    id?: SortOrder
    utmSource?: SortOrder
    utmMedium?: SortOrder
    utmCampaign?: SortOrder
    utmTerm?: SortOrder
    utmContent?: SortOrder
    channelGroup?: SortOrder
    createdAt?: SortOrder
  }

  export type DimMarketingSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DimLocationCountryStateCityPostalCodeCompoundUniqueInput = {
    country: string
    state: string
    city: string
    postalCode: string
  }

  export type DimLocationCountOrderByAggregateInput = {
    id?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    countryCode?: SortOrder
    region?: SortOrder
  }

  export type DimLocationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DimLocationMaxOrderByAggregateInput = {
    id?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    countryCode?: SortOrder
    region?: SortOrder
  }

  export type DimLocationMinOrderByAggregateInput = {
    id?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    countryCode?: SortOrder
    region?: SortOrder
  }

  export type DimLocationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IngestOffsetCountOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    partition?: SortOrder
    lastOffset?: SortOrder
    lastTimestamp?: SortOrder
    payloadHash?: SortOrder
    updatedAt?: SortOrder
  }

  export type IngestOffsetAvgOrderByAggregateInput = {
    id?: SortOrder
    partition?: SortOrder
    lastOffset?: SortOrder
  }

  export type IngestOffsetMaxOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    partition?: SortOrder
    lastOffset?: SortOrder
    lastTimestamp?: SortOrder
    payloadHash?: SortOrder
    updatedAt?: SortOrder
  }

  export type IngestOffsetMinOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    partition?: SortOrder
    lastOffset?: SortOrder
    lastTimestamp?: SortOrder
    payloadHash?: SortOrder
    updatedAt?: SortOrder
  }

  export type IngestOffsetSumOrderByAggregateInput = {
    id?: SortOrder
    partition?: SortOrder
    lastOffset?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type StagingRawEventCountOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    source?: SortOrder
    payload?: SortOrder
    headers?: SortOrder
    receivedAt?: SortOrder
    processedAt?: SortOrder
    status?: SortOrder
    error?: SortOrder
    retryCount?: SortOrder
  }

  export type StagingRawEventAvgOrderByAggregateInput = {
    id?: SortOrder
    retryCount?: SortOrder
  }

  export type StagingRawEventMaxOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    source?: SortOrder
    receivedAt?: SortOrder
    processedAt?: SortOrder
    status?: SortOrder
    error?: SortOrder
    retryCount?: SortOrder
  }

  export type StagingRawEventMinOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    source?: SortOrder
    receivedAt?: SortOrder
    processedAt?: SortOrder
    status?: SortOrder
    error?: SortOrder
    retryCount?: SortOrder
  }

  export type StagingRawEventSumOrderByAggregateInput = {
    id?: SortOrder
    retryCount?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>,
            'path'
          >
        >,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>
      >

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
            'path'
          >
        >,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<
          Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
          'path'
        >
      >

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type AggDailyStatsCountOrderByAggregateInput = {
    dateId?: SortOrder
    totalRevenue?: SortOrder
    totalOrders?: SortOrder
    totalVisits?: SortOrder
    conversionRate?: SortOrder
    aov?: SortOrder
    updatedAt?: SortOrder
  }

  export type AggDailyStatsAvgOrderByAggregateInput = {
    dateId?: SortOrder
    totalRevenue?: SortOrder
    totalOrders?: SortOrder
    totalVisits?: SortOrder
    conversionRate?: SortOrder
    aov?: SortOrder
  }

  export type AggDailyStatsMaxOrderByAggregateInput = {
    dateId?: SortOrder
    totalRevenue?: SortOrder
    totalOrders?: SortOrder
    totalVisits?: SortOrder
    conversionRate?: SortOrder
    aov?: SortOrder
    updatedAt?: SortOrder
  }

  export type AggDailyStatsMinOrderByAggregateInput = {
    dateId?: SortOrder
    totalRevenue?: SortOrder
    totalOrders?: SortOrder
    totalVisits?: SortOrder
    conversionRate?: SortOrder
    aov?: SortOrder
    updatedAt?: SortOrder
  }

  export type AggDailyStatsSumOrderByAggregateInput = {
    dateId?: SortOrder
    totalRevenue?: SortOrder
    totalOrders?: SortOrder
    totalVisits?: SortOrder
    conversionRate?: SortOrder
    aov?: SortOrder
  }

  export type AggProductPerformanceDateIdProductIdCompoundUniqueInput = {
    dateId: number
    productId: bigint | number
  }

  export type AggProductPerformanceCountOrderByAggregateInput = {
    dateId?: SortOrder
    productId?: SortOrder
    views?: SortOrder
    cartAdds?: SortOrder
    purchases?: SortOrder
    revenue?: SortOrder
    returns?: SortOrder
  }

  export type AggProductPerformanceAvgOrderByAggregateInput = {
    dateId?: SortOrder
    productId?: SortOrder
    views?: SortOrder
    cartAdds?: SortOrder
    purchases?: SortOrder
    revenue?: SortOrder
    returns?: SortOrder
  }

  export type AggProductPerformanceMaxOrderByAggregateInput = {
    dateId?: SortOrder
    productId?: SortOrder
    views?: SortOrder
    cartAdds?: SortOrder
    purchases?: SortOrder
    revenue?: SortOrder
    returns?: SortOrder
  }

  export type AggProductPerformanceMinOrderByAggregateInput = {
    dateId?: SortOrder
    productId?: SortOrder
    views?: SortOrder
    cartAdds?: SortOrder
    purchases?: SortOrder
    revenue?: SortOrder
    returns?: SortOrder
  }

  export type AggProductPerformanceSumOrderByAggregateInput = {
    dateId?: SortOrder
    productId?: SortOrder
    views?: SortOrder
    cartAdds?: SortOrder
    purchases?: SortOrder
    revenue?: SortOrder
    returns?: SortOrder
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DimProductCreatetagsInput = {
    set: string[]
  }

  export type DimProductUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
    not?:
      | NestedDecimalFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
      | null
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
      | null
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
      | null
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
    not?:
      | NestedDecimalNullableFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?:
      | NestedBigIntNullableWithAggregatesFilter<$PrismaModel>
      | bigint
      | number
      | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
    lt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
    lte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
    gt?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
    gte?:
      | Decimal
      | DecimalJsLike
      | number
      | string
      | DecimalFieldRefInput<$PrismaModel>
    not?:
      | NestedDecimalWithAggregatesFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?:
        | Decimal
        | DecimalJsLike
        | number
        | string
        | DecimalFieldRefInput<$PrismaModel>
        | null
      in?:
        | Decimal[]
        | DecimalJsLike[]
        | number[]
        | string[]
        | ListDecimalFieldRefInput<$PrismaModel>
        | null
      notIn?:
        | Decimal[]
        | DecimalJsLike[]
        | number[]
        | string[]
        | ListDecimalFieldRefInput<$PrismaModel>
        | null
      lt?:
        | Decimal
        | DecimalJsLike
        | number
        | string
        | DecimalFieldRefInput<$PrismaModel>
      lte?:
        | Decimal
        | DecimalJsLike
        | number
        | string
        | DecimalFieldRefInput<$PrismaModel>
      gt?:
        | Decimal
        | DecimalJsLike
        | number
        | string
        | DecimalFieldRefInput<$PrismaModel>
      gte?:
        | Decimal
        | DecimalJsLike
        | number
        | string
        | DecimalFieldRefInput<$PrismaModel>
      not?:
        | NestedDecimalNullableWithAggregatesFilter<$PrismaModel>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null
      _count?: NestedIntNullableFilter<$PrismaModel>
      _avg?: NestedDecimalNullableFilter<$PrismaModel>
      _sum?: NestedDecimalNullableFilter<$PrismaModel>
      _min?: NestedDecimalNullableFilter<$PrismaModel>
      _max?: NestedDecimalNullableFilter<$PrismaModel>
    }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
      in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
      notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
      lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
      lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
      gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
      gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
      not?:
        | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
        | Date
        | string
        | null
      _count?: NestedIntNullableFilter<$PrismaModel>
      _min?: NestedDateTimeNullableFilter<$PrismaModel>
      _max?: NestedDateTimeNullableFilter<$PrismaModel>
    }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonNullableFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>,
            'path'
          >
        >,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>
      >

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}
